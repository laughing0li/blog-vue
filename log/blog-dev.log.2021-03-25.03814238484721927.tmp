2021-03-25 18:05:08.513  INFO 36287 --- [http-nio-8080-exec-6] com.banjo.blogvue.aspect.LogAspect       : Request: RequestLog{url='http://localhost:8080/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.banjo.blogvue.controller.admin.BlogController.list', args=[1, 4]}
2021-03-25 18:05:08.535  INFO 36287 --- [http-nio-8080-exec-6] com.banjo.blogvue.aspect.LogAspect       : Result: Result(code=0, message=, data=Page4Navigator(pageFromJPA=Page 2 of 2 containing com.banjo.blogvue.pojo.Blog instances, navigatePages=0, navigatePageNums=null, totalPages=2, number=1, totalElements=7, size=4, numberOfElements=3, content=[Blog(id=17, title=React Hooks, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=33, content=#### useState 和 useEffect的使用

```react
import React, { useState, useEffect } from 'react';

export default function Example () {
    // 下面的写法是ES6的数组解构
    // [] use**里面接收的是数组里的第一个参数的默认值
    // set**是用来改变第一个参数的值的
    const [ age, setAge ] = useState(20)
    const [ gender, setGen] = useState('male')
    const [occupation, setOccupation] = useState('None')
    const [count, setCount] = useState(0)

    // useEffect是用来代替生命周期函数的，比如：componentDidMount
    // 和componentDidUpdate这些函数。它包含了上面两个生命周期函数的
    // 功能

    useEffect(()=> {
        console.log(`useEffect=>you clicked ${count} times`)
      // 数组里面需要放的东西是这个副作用是由哪些引起变化的，如果不指定，那么上面的
      // age，gender，occu，count随便哪一个的变化都会引起这里被调用。
      // 所以如果数组里面放入count，那么就表示只对count的变化起作用
    }, [])

    return (
        <div>
            <p>年龄：{age}</p>
            <p>性别：{gender}</p>
            <p>职业：{occupation}</p>
            <p>you clicked { count } times</p>
            <button onClick={()=>{setCount(count+1)}}> click me </button>
        </div>
    )
}
```



#### useContext的使用

> 它的作用就是将状态共享给其他的组件

```react
import React, { createContext, useContext, useState } from 'react'

const CountContext = createContext({});

function Counter() {
    return (
        <h2> {useContext(CountContext)} </h2>
    )
}

export default function Example02() {
    const [ count, setCount ] = useState(0)
    return(
        <div>
            <p>you clicked { count } times</p>
            <button onClick={ () => { setCount(count + 1) } }> click me </button>
            <CountContext.Provider value = {count}>
                <Counter />
            </CountContext.Provider>
        </div>
    );
}
```



#### useReducer 的使用

```react
import React, { useReducer } from 'react'

export default function Example03() {
    const [count, dispatch] = useReducer((state, action)=>{
        switch(action) {
            case 'add':
                return state + 1
            case 'sub':
                return state - 1
            default:
                return state
        }
    }, 0)
    return (
        <div>
            <h2>现在的分数是{count}</h2>
             <button onClick={()=>{dispatch('add')}}  >ADD</button>
             <button onClick={()=>{dispatch('sub')}}  >SUB</button>
        </div>
    );
}
```

#### useReducer、useContext代替redux使用案例

> Color.js文件

```react
import React, { createContext, useReducer } from 'react'
import Display from "./Display";
import Button from "./Button";

export const ColorContext = createContext({})
export const COLOR_TYPE = 'COLOR_TYPE'
const reducer = (state, action) => {
    switch (action.type) {
        case COLOR_TYPE:
            return action.color
        default:
            return state
    }
}

export default function Color() {
    const [ color, dispatch ] = useReducer(reducer, 'pink')
    return(
        <div>
            <ColorContext.Provider value={{color, dispatch}}>
                <Display />
                <Button />
            </ColorContext.Provider>
        </div>
    )
}
```

> Button.js 文件

```react
import React, { useContext } from 'react'
import {COLOR_TYPE, ColorContext} from "./Color";

export default function Button() {
    const { dispatch } = useContext(ColorContext)
    return(
        <div>
            <button onClick={()=>{dispatch({type:COLOR_TYPE, color: 'red'})}}>red</button>
            <button onClick={()=>{dispatch({type:COLOR_TYPE, color: 'green'})}}>green</button>
        </div>
    )
}
```



> Display.js 文件

```react
import React, { useContext } from 'react'
import {ColorContext} from "./Color";

export default function Display() {
    const {color} = useContext(ColorContext)
    return(
        <div>
            <h2 style={{color: color}}> 字体的颜色是 {color} </h2>
        </div>
    )
}
```

, description=React Hooks Study Notes, createTime=2020-07-15, updateTime=2021-02-25, category=Category{id=25, name='React'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=16, title=Git Notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=2, content=#### 1.安装Git

##### Mac 下安装

> 通过homebrew进行安装：brew install git

##### Linux下安装

> 我用的是CentOS，可以通过：yum install git 进行安装



#### Git基本命令

建议先创建一个空目录，举例创建一个目录叫learngit，然后将这个空目录变成Git可以管理的仓库

==创建仓库==：进入到该空目录，然后使用git init命令即可

==工作区==：learngit目录就是一个工作区

==版本库(Repository)==：该目录下有一个隐藏文件 .git是Git的版本库

==暂存区==：版本库中存储了许多东西，其中最重要的是称为==stage==(或者叫==index==)的暂存区，还包括Git为我们自动创建的第一个分支==maste==，以及指向==master==的指针叫做==HEAD==。



==添加文件==：git add <file>，注意，可反复多次使用，添加多个文件；这个操作实际上就是将文件添加或修改到==暂存区==。同时，在每次修改或者新增文件都需要使用git add，将这些文件添加到暂存区。这样使用git commit才能将修改过或者新增加的文件添加到master分支。因为git commit提交的是暂存区的文件。



==提交文件==：git commit -m <message>，用于将添加的文件提交到仓库。其中的 -m 后面是用户自己可以添加的描述当前操作的信息。这个操作才是将所有新增或者修改后的文件提交到==master==分支上去。



==查看状态==：git status 可以查看当前仓库的状态，是否有文件被修改过

==查看修改内容==：git diff 可以查看当前哪里被修改了

==查看历史信息==：git log/ git log --pretty=oneline.后面的命令输出会更简洁

![image-20200709101956674](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200709101956674.png)

上图中，的一连串字符表示的是commit id(版本号) 版本号后面显示的是 -m的信息。

其中==HEAD==表示当前文件处于的版本。

==版本回退==：git reset --hard HEAD^ 跳转到当前版本的上一个版本

如果跳转到上一个版本之后又想再跳转回去，那么可以使用：

git reset --hard ==commit id(版本号)== 就可以跳转到指定的版本。

==git reflog 会记录用户的每一次命令==，所以可以根据这个找到commit id(版本号)。

==撤销修改==：前提是没有提交到远程库

1. git checkout -- file(这里是这个文件的全称加上文件属性，eg: readme.txt)，但是只能用于还没有执行 ==git add== 这个命令的情况下
2. 如果已经对修改的文件执行了==git add==命令，那么则可以使用==git restore --staged readme.txt== 来撤销git add命令。然后再使用 ==git checkout==这个命令就可以将所有修改撤销
3. 同时，还可以使用版本回退命令==git reset==来直接跳过修改，然后回到修改之前



==删除文件==：git rm file(文件名) 删除文件，git commit 确认从版本库中删除

#### Git 连接远程GitHub仓库

1. 先创建GitHub账号

2. 在Mac的终端里面使用==cd ~/.ssh== 检查是否存在==id_rsa==和==id_rsa.pub== 如果没有的话直接创建

3. ssh-keygen -t rsa -C "youremail@email.com" 这里的email使用GitHub账号的email。并且一直按enter知道出现下图

   ![image-20200709141353368](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200709141353368.png)

   说明创建成功。

4. 然后拿到==id_rsa.pub==里面的内容去GitHub自己的主页，找到setting然后找到下图

   ![image-20200709141452672](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200709155134899.png)

   然后点击添加new SSH keys 然后把上面==id_rsa.pub==的内容复制进去即可。

5. 在GitHub主页![image-20200709152725148](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200709152725148.png)

6. 然后再在电脑端terminal输入以下内容，就可以将本地和远程的仓库连接起来

   ![image-20200709155134899](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200709141452672.png)

   红线的部分，每一个仓库不一样。 当push之后还需要输入GitHub的Username和Password

   其中==origin==就表示远程库。第一次push的时候需要加上==-u== 以后每次更新只需要使用

   ==git push origin master==

#### 从远程库克隆项目

1. 首先进入一个指定的空目录，在terminal中输入以下命令

   git clone + 远程库的地址即可

   ![image-20200709160655068](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200709160655068.png)

   

#### 创建与合并分支

1. git branch dev: 创建一个名为dev的分支

2. git checkout dev：切换到dev分支

   git switch dev: 也表示切换到fev分支

   

3. git checkout -b dev：表示创建并且切换到dev分支。

   git switch -c dev: 也表示创建并且切换到dev分支

   

4. git branch: 表示查看分支情况，并且在当前分支前面标 ==*==号。

5. git merge dev: 如果现在的分支是master，那么这个命令会将dev分支的成果合并到master分支。

6. git branch -d dev: 删除dev分支

![image-20200709172934807](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200709172934807.png)

#### IDEA集成git

如图

![image-20200709193615178](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200709193633209.png)

![image-20200709193633209](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200709193615178.png)

![image-20200709193655770](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200709193655770.png)

然后根据提示进行下一步操作, description=Git basic infos, createTime=2020-07-09, updateTime=2021-02-25, category=Category{id=24, name='Git'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=10, title=Jenkins Install note, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=41, content=#### Mac 安装

> brew install jenkins

默认的端口号修改



首先需要进入到存放 jenkins.war 这个路径  然后执行下面的命令

```bash
java -jar jenkins.war --ajp13Port=-1 --httpPort=9001
```



生成的密钥需要存储好

cb2c7d41d1ad4acfa0ffa23b44a0765d

![image-20200730151958370](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200730151958370.png)



> docker里面创建Jenkins容器总是退出

原因是挂载的文件夹没有权限

```bash
去对应的路径 执行下面的语句即可
[root@localhost data]# chown -R 1000:1000 jenkins_home 
```

docker logs -f jenkins 可以找到初始密码, description=How to install Jenkins on Mac Systems, createTime=2020-07-25, updateTime=2021-02-25, category=Category{id=1, name='Jenkins'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0)], isHasContent=true, first=false, last=true, isHasNext=false, isHasPrevious=true))
2021-03-25 18:05:09.712  INFO 36287 --- [http-nio-8080-exec-7] com.banjo.blogvue.aspect.LogAspect       : Request: RequestLog{url='http://localhost:8080/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.banjo.blogvue.controller.admin.BlogController.list', args=[0, 4]}
2021-03-25 18:05:09.726  INFO 36287 --- [http-nio-8080-exec-7] com.banjo.blogvue.aspect.LogAspect       : Result: Result(code=0, message=, data=Page4Navigator(pageFromJPA=Page 1 of 2 containing com.banjo.blogvue.pojo.Blog instances, navigatePages=0, navigatePageNums=null, totalPages=2, number=0, totalElements=7, size=4, numberOfElements=4, content=[Blog(id=23, title=AWS Cloud, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Translation, views=11, content=#### 卸载自带jdk

```bash
# 先使用以下命令 查看当前的jdk
rpm -qa|grep jdk
java-1.7.0-openjdk-1.7.0.261-2.6.22.1.83.amzn1.x86_64
copy-jdk-configs-3.3-10.3.amzn1.noarch

# 然后根据对应版本的jdk 直接用下面的命令删除
sudo rpm -e --nodeps java-1.7.0-openjdk-1.7.0.261-2.6.22.1.83.amzn1.x86_64

# 然后使用yum下载jdk，使用下面的命令查看java可选版本
$ yum -y list java*

# 然后根据版本号，直接下载
sudo yum install -y java-1.8.0-openjdk-devel.x86_64
```



#### FileZilla 连接 AWS

1. 打开 FileZilla 的 "Edit" -> "Settings" 对话框，在左边的“选择页面” 选择“SFTP”， 右边点击 “添加密钥文件...” 按钮，导入Amazon给的密钥文件 

   ![image-20200713163800225](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/7gZEBIRuMvdbPli.png)

2. 打开File选择Site Manager

   Protocol中选择SFTP

   Host选择 公有DNS![image-20200713163956246](https://i.loli.net/2020/07/17/9fIEBSrGNMzgoLu.png)

![image-20200713163918562](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/OQzkdvYoGqKLs5B.png)

然后选择Interactive的方式登录，用户是ec2-user

或者选择key的方式都可以

然后就能连接成功

> 连接成功之后需要将一个用于接收上传文件的文件夹进行权限修改

如下：

![image-20200713170334089](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/TNozpkPF8OgeJyM.png)



#### 安装docker

```bash
# 先查看版本 
yum -y list docker*
# 然后根据版本来下载
sudo yum install -y docker.x86_64

# 下载之后需要启动Docker服务
sudo service docker start

# 然后将ec2-user添加到docker组，否则不能执行Docker命令
sudo usermod -a -G docker ec2-user

# 然后重启AWS实例，就可以开启docker服务了
```



#### Docker vim命令

```bash
首先进入容器，然后执行
 apt-get update
 
 然后执行
 apt-get install vim
```

#### AWS 安全组

```bash
# 1. 如果tomcat开启的端口是8080，那么就需要在AWS的安全组里面放行对8080端口的访问，同时还要对9001端口进行开放

docker run -d -p 9001:8080 tomcat

其他的服务如果需要使用其他的端口，那么也用相同的方法进行放行

下面以MySQL的连接为例，3310和3306都需要在安全组里面进行放行。

 mysql          "docker-entrypoint.s…"   17 hours ago        Up 17 hours         33060/tcp, 0.0.0.0:3310->3306/tcp   mysql01
```



![image-20200714180816580](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/ysLFVnza2wGp9E6.png)



#### IDEA 连接 AWS 上的docker

1. 首先修改docker需要监听的IP和端口

```bash
   1. 首先关闭docker服务
   sudo service docker stop
   2. 然后修改docker 服务端监听的端口和ip
   sudo dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375
   3. 然后启动docker服务
   sudo service docker start
   4. 然后修改客户端的
   docker -H tcp://0.0.0.0:2375 ps
   没有输出就表示成功。
   
   
   
   ```

2. 然后再aws里面的安全组里将2375端口进行放行

3. 然后再利用IDEA对docker进行远程连接即可

> 以systemd的方式连接

```bash
1. 先找到这个文件
/lib/systemd/system/docker.service

然后注释掉下面的
ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock $OPTIONS $DOCKER_STORAGE_OPTIONS $DOCKER_ADD_RUNTIMES

然后再添加
ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock
这样远程就能通过2375端口访问到了
```

#### AWS ec2 安装MySQL

```bash
# 先查看是否有旧版本MySQL
rpm -qa | grep -i mysql

# 如果有的话，使用下面的命令将其全部删除
sudo rpm -ev 加mysql的文件名


# 下载并进入到下载好的文件夹
 wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.17-linux-glibc2.12-x86_64.tar.xz
 # 解压下载的压缩包
 tar xvf mysql-8.0.17-linux-glibc2.12-x86_64.tar.xz
 
 # 将解压好的复制到/usr/local目录下并且重命名为mysql
 sudo mv mysql-8.0.17-linux-glibc2.12-x86_64 /usr/local/mysql
 
 # 进入到mysql目录，然后创建一个data文件夹，用于存放数据
 mkdir data
 
 # 创建mysql用户组和mysql用户
 sudo groupadd mysql
 sudo useradd -g mysql mysql
 
 # 改变mysql目录权限 注意后面都有一个点
 sudo chown -R mysql .
 sudo chgrp -R mysql .
 
 # 创建mysql_install_db安装文件，并且修改权限
sudo mkdir mysql_install_db
sudo chmod 777 ./mysql_install_db

# 初始化
sudo bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data
# 一定要记住临时密码
A temporary password is generated for root@localhost: 

# mysql配置，将support-files下的移动到init.d目录下，并且重命名，两个都要
sudo cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld
sudo cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql
# 修改或者创建my.cnf文件，并且加入下面的命令

[mysqld]
    basedir = /usr/local/mysql
    datadir = /usr/local/mysql/data
    socket = /usr/local/mysql/mysql.sock
    character-set-server=utf8
    port = 3306
   sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
 [client]
   socket = /usr/local/mysql/mysql.sock
   default-character-set=utf8
   
# 建立MySQL服务
sudo chmod +x /etc/init.d/mysqld
sudo chmod +x /etc/init.d/mysql
# 添加到系统服务
sudo chkconfig --add mysqld
sudo chkconfig --add mysql
#配置全局环境变量

先设置 /etc/profile文件的权限，可以读写
sudo /etc/profile chmod 777
然后再在里面添加以下配置
export PATH=$PATH:/usr/local/mysql/bin:/usr/local/mysql/lib
export PATH

# 设置环境变量立即生效
source /etc/profile

# 启动MySQL服务

sudo service mysql start

# 登录MySQL
mysql -u root -p 回车
输入上面的临时密码即可

# 修改初始密码
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY'自己的密码';

# 设置远程可登录
进入mysql
1. use mysql
2. update user set host='%' where user='root' limit 1;
3. flush privileges; # 刷新权限

然后就可以进行远程登录
```

, description=Learn how to set up a clear AWS cloud, createTime=2021-02-17, updateTime=2021-02-25, category=Category{id=17, name='AWS Cloud'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=21, title=Docker Notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=14, content=#### Linux 安装 docker

```bash
# 1. 首先用下面的命令卸载旧版本，如果有的话
sudo yum remove docker \ 
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
                  
# 2. 安装依赖包
sudo yum install -y yum-utils        

# 3. 设置镜像仓库
sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo

# 4. 安装docker引擎
sudo yum install docker-ce docker-ce-cli containerd.io

# 5. 启动docker 和重启
sudo systemctl start docker
sudo systemctl restart docker

# 6. 测试是否启动成功
sudo docker run hello-world

# 7. 卸载依赖和删除资源
sudo yum remove docker-ce docker-ce-cli containerd.io
sudo rm -rf /var/lib/docker
```



docker run hello-world的流程图

1. docker会在本地仓库寻找hello-world的镜像，找到就运行。
2. 没找到，docker client就会跟 docker daemon联系，然后下载hello-world镜像到本地
3. 下载到本地之后，再运行该镜像。

 ![image-20200710230333325](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200710230333325.png)![image-20200710230221724](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200710230221724.png)



#### Docker 常用命令

##### 帮助命令

```shell
docker version # 查看docker信息
docker info		 # 查看docker系统信息，包括有多少镜像和容器
docker --help  # 帮助命令
```



##### 镜像命令

> 查看镜像

```bash
docker images  # 查看当前主机上的所有镜像
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              bf756fb1ae65        6 months ago        13.3kB

# docker images 命令的可选性
-a, --all 	# 列出所有的镜像跟默认的docker images一样
-q, --quit	# 只显示镜像的id,-q 和 --quit一样

[root@localhost ~]# docker images --quiet
bf756fb1ae65

[root@localhost ~]# docker images -q
bf756fb1ae65

docker search mysql 搜索mysql的镜像 #镜像的搜索
```

> 搜索镜像

```bash
docker search mysql 搜索mysql的镜像 #镜像的搜索
# 只需要添加想要的镜像的名称，就可以进行搜索。
[root@localhost ~]# docker search mysql
NAME                              DESCRIPTION                                     STARS               
mysql                             MySQL is a widely used, open-source relation…   9718
```

> 下载镜像

```bash
docker pull mysql  # 下载mysql

[root@localhost ~]# docker pull mysql
Using default tag: latest #如果不指定tag，就默认下载最新版本
latest: Pulling from library/mysql
8559a31e96f4: Pull complete	# 分层下载， docker images的核心 联合文件系统
d51ce1c2e575: Pull complete	# 好处：举例--如果要更新到更新版本的MySQL，那么下次执行pull的
c2344adc4858: Pull complete	# 时候只需要下载被更新的部分，其余没更新的不会被重复下载
fcf3ceff18fc: Pull complete
16da0c38dc5b: Pull complete
b905d1797e97: Pull complete
4b50d1c6b05c: Pull complete
c75914a65ca2: Pull complete
1ae8042bdd09: Pull complete
453ac13c00a3: Pull complete
9e680cd72f08: Pull complete
a6b5dc864b6c: Pull complete
Digest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest # 这里是真实的mysql的地址

docker pull mysql 等价于  docker pull docker.io/library/mysql:lastest
```



> 删除镜像

```bash
docker rmi -f 加上(镜像的id) 

[root@localhost ~]# docker rmi -f bf756fb1ae65
Untagged: hello-world:latest
Untagged: hello-world@sha256:d58e752213a51785838f9eed2b7a498ffa1cb3aa7f946dda11af39286c3db9a9
Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b

##或者 docker rmi -f 加上(镜像的repository名称) 
docker rmi -f hello-world

[root@localhost ~]# docker rmi -f hello-world
Untagged: hello-world:latest
Untagged: hello-world@sha256:d58e752213a51785838f9eed2b7a498ffa1cb3aa7f946dda11af39286c3db9a9
Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b

```



##### 容器命令

> 先有镜像，才能创建容器。以下用docker下载centos来进行举例学习

> 新建容器并启动

```bash
# -it 表示使用交互方式运行，进入容器查看内容
[root@localhost ~]# docker run -it centos /bin/bash  
									# docker run -d centos   表示后台启动容器
[root@f72fb12d27fc /]# ls  这里表示已经进入到了centos这个容器当中
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

[root@f72fb12d27fc /]# exit  退出并且停止容器
exit
[root@localhost ~]#

删除所有容器
docker rm $(docker ps -aq)
```

> 查看运行和曾经运行过的容器

```bash
[root@localhost ~]# docker ps -a 表示查看当前在运行的和曾经运行过的容器
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
f72fb12d27fc        centos              "/bin/bash"         3 minutes ago       Exited (0) 2 minutes ago                       hopeful_mcnulty
3af87bce0732        bf756fb1ae65        "/hello"            12 hours ago        Exited (0) 12 hours ago                        lucid_sammet
b22be932b11a        bf756fb1ae65        "/hello"            12 hours ago        Exited (0) 12 hours ago                        vigorous_chaplygin
[root@localhost ~]# docker ps  表示查看正在运行的容器
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
[root@localhost ~]#

```

> 启动，停止，重启容器

```shell
docker start 容器id
docker restart 容器id
docker stop 容器id
docker kill 容器id #强制停止当前容器
```

> 退出容器

```bash
exit 表示退出且停止容器运行

Ctrl + P + Q #不停止容器运行，只退出容器

[root@f4b87ffb286b /]# [root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
f4b87ffb286b        centos              "/bin/bash"         13 seconds ago      Up 11 seconds                           laughing_darwin
[root@localhost ~]#

```



> 进入在运行的指定容器

```shell
docker exec -it 容器名 /bin/bash

[root@localhost ~]# docker exec -it 0f45f1d47525 /bin/bash
[root@0f45f1d47525 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

docker attach 容器名

[root@localhost ~]# docker attach 0f45f1d47525
[root@0f45f1d47525 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

###区别
docker exec			# 进入容器后开启一个新的终端，可以在里面操作(这个是常用的)。
docker attach		# 进入容器正在执行的终端，不会启动新的进程。

```



> 删除容器

```bash
docker rm 容器id
```

> 列出所有容器

```bash
docker container ls
```



> 日志打印

```bash
docker logs --tail 10 0f45f1d47525  
--tail 表示以字符串的形式打印，10是--tail的参数，打印10行。最后跟的是容器的id
```

> 查看容器进程信息

```bash
docker top 容器id
[root@localhost ~]# docker top 0f45f1d47525
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                13539               13521               0                   18:08               pts/0               00:00:00            /bin/bash
```

> 查看容器元数据(所有数据)

```bash
[root@localhost ~]# docker inspect 0f45f1d47525（容器id）
```



> 从容器中复制文件到主机

```bash
[root@6ad773845eab /]# cd home  开启容器 进入到home目录
[root@6ad773845eab home]# touch test.java	在home目录创建test.java文件
[root@6ad773845eab home]# ls
test.java
[root@6ad773845eab home]# exit 退出即可
exit
[root@localhost ~]# ls 当前文件夹下是没有test.java文件
anaconda-ks.cfg  Desktop  Documents  Downloads  Music  original-ks.cfg  Pictures  Public  study.txt  Templates  Videos  

# 将6ad773845eab:/home/test.java  将这个容器的home目录中的test.java文件复制到
# ~目录。
[root@localhost ~]# docker cp 6ad773845eab:/home/test.java ~
[root@localhost ~]# ls
anaconda-ks.cfg  Desktop  Documents  Downloads  Music  original-ks.cfg  Pictures  Public  study.txt  Templates  test.java  Videos
[root@localhost ~]#
```



#### Docker Nginx

##### 启动并验证Nginx

```bash
-d 表示后台运行
--name nginx01表示它的名字
-p 8082:80 #8082表示客户端访问的请求的端口，80表示本地与之对应的端口。
就是客户端访问8082端口会拿到本地80端口的数据

[root@localhost ~]# docker run -d --name nginx01 -p 8082:80 nginx
f0a1f169564a7c8faacb1aa73cae06449267e5b39493a05196086823b69f8972
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
f0a1f169564a        nginx               "/docker-entrypoint.…"   4 seconds ago       Up 3 seconds        0.0.0.0:8082->80/tcp   nginx01
6ad773845eab        centos              "/bin/bash"              56 minutes ago      Up 51 minutes                              elastic_mestorf
[root@localhost ~]# curl localhost:8082  验证是否能够访问成功
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
Nginx在docker里面的配置文件在 /etc/nginx路径下面
```



#### Docker Tomcat

```bash
# tomcat 的启动跟Nginx相似
也是要设置端口的映射。才能进行访问
[root@localhost ~]# docker run -d -p 9001:8080 tomcat
4126cf694a054e44dfa27a059da130ff8201d427b0e1aeeafb57a986f8fa8667
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
4126cf694a05        tomcat              "catalina.sh run"        4 seconds ago       Up 3 seconds        0.0.0.0:9001->8080/tcp   loving_bell
f0a1f169564a        nginx               "/docker-entrypoint.…"   27 minutes ago      Up 27 minutes       0.0.0.0:8082->80/tcp     nginx01
6ad773845eab        centos              "/bin/bash"              About an hour ago   Up About an hour                             elastic_mestorf

## 返回404 表示能够访问，但是当前的Tomcat里面还缺少可用于访问的文件
[root@localhost ~]# curl localhost:9001
<!doctype html><html lang="en"><head><title>HTTP Status 404 – Not Found</title><style type="text/css">body {font-family:Tahoma,Arial,sans-serif;} h1, h2, h3, b {color:white;background-color:#525D76;} h1 {font-size:22px;} h2 {font-size:16px;} h3 {font-size:14px;} p {font-size:12px;} a {color:black;} .line {height:1px;background-color:#525D76;border:none;}</style></head><body><h1>HTTP Status 404 – Not Found</h1><hr class="line" /><p><b>Type</b> Status Report</p><p><b>Description</b> The origin server did not find a current representation for the target resource or is [root@lo[root@localhost ~]#

# 解决办法

[root@localhost ~]# docker exec -it 4126cf694a05 /bin/bash 先重新进入Tomcat运行的容器
root@4126cf694a05:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work

## 将webapps.dist 文件夹的内容全部复制的 webapps即可

root@4126cf694a05:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work
root@4126cf694a05:/usr/local/tomcat# cd webapps.dist
root@4126cf694a05:/usr/local/tomcat/webapps.dist# ls
ROOT  docs  examples  host-manager  manager
root@4126cf694a05:/usr/local/tomcat/webapps.dist# cd examples
root@4126cf694a05:/usr/local/tomcat/webapps.dist/examples# ls
WEB-INF  index.html  jsp  servlets  websocket
root@4126cf694a05:/usr/local/tomcat/webapps.dist/examples# cd ..
root@4126cf694a05:/usr/local/tomcat/webapps.dist# cd ..
root@4126cf694a05:/usr/local/tomcat# cp -r webapps.dist/* webapps
root@4126cf694a05:/usr/local/tomcat#

#然后就能成功访问到index页面
```





#### Docker ElasticSearch

```bash
# 先下载ElasticSearch
# docker pull docker.elastic.co/elasticsearch/elasticsearch:7.8.0

# 官方推荐的开启单节点集群
# docker run -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" docker.elastic.co/elasticsearch/elasticsearch:7.8.0
但是上面的方式会暴露一个问题，那就是ES占内存非常大，而我们的虚拟机内存很小。所以不建议这样开启

# 其中 -e ES_JAVA_OPTS="-Xms64m -Xmx512m" 表示最小占用64M内存 最大占用512M
# docker run -d -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.8.0

然后去访问 即可验证
[root@localhost ~]# curl localhost:9200
{
  "name" : "88e49838ff71",
  "cluster_name" : "docker-cluster",
  "cluster_uuid" : "T6BQKfqySz63NlT_Tp9NYQ",
  "version" : {
    "number" : "7.8.0",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "757314695644ea9a1dc2fecd26d1a43856725e65",
    "build_date" : "2020-06-14T19:35:50.234439Z",
    "build_snapshot" : false,
    "lucene_version" : "8.5.1",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}
```



#### Docker 提交镜像

==提交了之后，只是在本地存在。还需要push到网络上，才能实现下载使用的功能==

```bash
举例：下载的Tomcat镜像中，webapps文件夹是没有东西的，所以我们在webapps文件夹下面创建一些文件。然后通过下面的命令将修改后的镜像commit
-m 用于添加描述信息，跟Git类似。-a 是作者名字。加上需要修改的容器id，然后 tomcat01是repository名

[root@localhost ~]# docker commit -m="docker with changes in webapps" -a="banjo" 6c9c1265f18e tomcat01
sha256:b1c6475b6b76c51fa3cb08edcb82ec37725c93643eca9274e12301e44594f781
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
6c9c1265f18e        tomcat              "catalina.sh run"   3 minutes ago       Up 3 minutes        0.0.0.0:9001->8080/tcp   recursing_thompson
[root@localhost ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
tomcat01            latest              b1c6475b6b76        9 seconds ago       652MB
nginx               latest              0901fa9da894        11 hours ago        132MB
tomcat              latest              6055d4d564e1        4 days ago          647MB
centos              latest              831691599b88        3 weeks ago         215MB
elasticsearch       7.8.0               121454ddad72        3 weeks ago         810MB
mysql               latest              be0dbf01a0f3        4 weeks ago         541MB
```

![image-20200711174623196](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711192711325.png)



#### Docker 容器数据卷

容器数据卷可以帮助容器的持久化和同步操作，容器间的数据也可以共享

就是容器中的一个路径映射到本地主机上的一个路径，只要容器中的这个路径里面进行了操作，比如添加文件，删除文件，修改文件，那么在主机上的映射的这个目录也会有相同的操作。

==我的理解：以后可以在本地的/home 目录下面创建，centos，Tomcat，ES，redis，Nginx这些目录，然后将这些目录分别的映射到对应的容器中去，就可以保证容器中的重要数据不会丢失==

> 直接使用命令的方式进行挂载

```bash
举例: -v 是用来挂载的 : 有的时候在容器路径下 ### eg. /home:ro 或者 /home:rw 这表示read only或者read & write 表示在容器中这个路径下的文件是只读或者读写均可

将本地主机/home/centos 路径 与 容器centos的 /home路径进行绑定
[root@localhost ~]# docker run -it -v /home/centos:/home centos /bin/bash

然后使用 docker inspect 容器id就可以查看到以下信息，如果没有出现，则代表没有挂载成功。

测试方法，在容器的/home路径下面创建文件，然后再在本地主机的/home/centos下查看是否有相同的文件

同样的去本地主机创建文件，然后去容器中去查看也可以验证
```

![image-20200711192711325](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711174623196.png)



##### 匿名挂载

```bash
# 1. 匿名挂载
-d	后台运行
-P	大写的P表示随机的端口
这里没有指定本机的路径，所以就是匿名挂载
[root@localhost /]# docker run -d -P --name nginx01 -v /etc/nginx nginx
326008beb69c229e1a424d6127aba2dd409989092108b90a60aaff11fa3abb93

[root@localhost /]# docker volume ls 通过这个命令可以拿到匿名挂载的名称
DRIVER              VOLUME NAME
local               626a093ff31bcf34ef1741f5eab3e3077a7bf445a1280fd2f2cb3fd6f448a004
local               6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70

[root@localhost /]# docker volume inspect 6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70 然后通过这个命令查看当前的匿名挂载是映射到本机的什么位置，可以看到是在/var/lib/docker/volumes下面
[
    {
        "CreatedAt": "2020-07-11T05:50:36-07:00",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70/_data",
        "Name": "6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70",
        "Options": null,
        "Scope": "local"
    }
]

```

![image-20200711225525788](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712112330604.png)

##### 具名挂载

```bash
# 2. 具名挂载
test-nginx 就是这个挂载的名字
[root@localhost /]# docker run -d -P --name nginx02 -v test-nginx:/etc/nginx nginx
```

![image-20200711225848468](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711225848468.png)



##### Dockerfile方式挂载

```bash
# 先在主机的一个路径里面生成一个叫做dockerfile的文件
[root@localhost ~]# mkdir /home/docker-test-volume 创建这个目录
[root@localhost ~]# cd /home/docker-test-volume 进入这个目录
[root@localhost docker-test-volume]# ls
[root@localhost docker-test-volume]# vim dockerfile1  创建dockerfile1 文件并写下下面的内容
[root@localhost docker-test-volume]# cat dockerfile1
FROM centos ##以镜像centos为基础

VOLUME ["volume01", "volume02"]  ## 挂载两个卷

CMD echo "-----success------"   ## 成功后的输出
CMD /bin/bash		## 然后会进入该路径

# build 用于创建dockerfile
# -f 		哪一个file文件
# -t		生成的对象
# .			生成在当前目录下

[root@localhost docker-test-volume]# docker build -f /home/docker-test-volume/dockerfile1 -t test/centos .

Sending build context to Docker daemon  2.048kB
Step 1/4 : FROM centos
 ---> 831691599b88
Step 2/4 : VOLUME ["volume01", "volume02"]
 ---> Running in 0c80409788d3
Removing intermediate container 0c80409788d3
 ---> 4e7fe085c688
Step 3/4 : CMD echo "-----success------"
 ---> Running in 3a6eebcf35a9
Removing intermediate container 3a6eebcf35a9
 ---> ec43d897d893
Step 4/4 : CMD /bin/bash
 ---> Running in 7f1029e69632
Removing intermediate container 7f1029e69632
 ---> efd4071b1ad0
Successfully built efd4071b1ad0
Successfully tagged test/centos:latest
## 镜像生成成功
test/centos         latest              efd4071b1ad0        2 minutes ago       215MB
```

当我们利用这个镜像创建容器的时候，就可以看到挂载的卷。

![image-20200712112330604](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712112754635.png)

![image-20200712112754635](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712174322428.png)



##### 数据卷容器

> **--volumes-from** 顾名思义，就是从另一个容器当中挂载容器中已经创建好的数据卷。

以上面的为例，先创建centos01 里面有已经创建好的volume01和volume02的数据卷

然后创建centos02 从centos01中挂载已经创建好的这两个数据卷。

挂载好之后，无论在哪一个容器中修改数据卷中的内容，两个容器都会同步。即使将centos01容器删除，centos02容器中数据卷中的数据也不会丢失

```bash
# 使用以下命令进行挂载
# 而且可以有多个容器对centos01进行挂载，比如centos03
--volumes-from 表示centos02 从 centos01中挂载已经创建好的volume01和volume02数据卷

# docker run -it --name centos02 --volumes-from centos01 test/centos

```





#### Docker MySQL 

```shell
# 需要在Linux中将MySQL的端口在防火墙中开放。
firewall-cmd --add-port=3306/tcp --permanent
firewall-cmd --add-port=3310/tcp --permanent

-d	后台运行
-p	端口映射
-v	卷挂载，可以多个
--name	容器的名字
-e	环境配置
# MYSQL_ROOT_PASSWORD 初始化root的密码
docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123123 --name mysql01 mysql

# 1 先开启MySQL容器
# docker run -it tomcat /bin/bash  
# 然后在MySQL里面 执行以下操作
root@3eeba4e8cfee:/# mysql -u root -p 
查看 root的加密方式
mysql> select host,user,plugin,authentication_string from mysql.user;
+-----------+------------------+-----------------------+
| host      | user             | plugin                | 
+-----------+------------------+-----------------------+
| %         | root             | caching_sha2_password | 
| localhost | mysql.infoschema | caching_sha2_password | 
| localhost | mysql.session    | caching_sha2_password |
| localhost | mysql.sys        | caching_sha2_password |
| localhost | root             | caching_sha2_password | 
如果root的plugin显示是caching_sha2_password 那么就需要作如下的更改，'123123是代表MySQL的密码'
mysql> ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123123';
mysql> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123123';
然后远程就可以连接到本地的MySQL服务了
```

![image-20200711222503711](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/j7mgN8FfSoMXzqI.png)

3310是与MySQL端口号3306对应的

##### 多个MySQL实现数据共享

```bash
# 1. 先创建mysql01，然后将mysql01里面的conf.d和mysql设置成容器数据卷。

docker run -it -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123123 --name mysql01 

# 2. 然后创建mysql02，使用--volumes-from挂载到mysql01的容器数据卷，这样两个mysql之间就可以进行数据共享了
docker run -it -p 3311:3306 -e MYSQL_ROOT_PASSWORD=123123 --name mysql02 --volumes-from mysql01 mysql
```



#### DockerFile

> 以构建tomcat镜像为例

```bash
FROM centos # 以centos为基础

MAINTAINER banjo<mr.singledog@gmail.com> # 表明作者是谁

ADD jdk-8u251-linux-x64.tar.gz /usr/local 
ADD apache-tomcat-9.0.37.tar.gz /usr/local

RUN yum -y install vim # 镜像构建的时候需要运行的命令
RUN yum -y install net-tools

ENV MYPATH /usr/local # 构建镜像的时候设置环境变量

### VOLUME 表示挂载的目录

WORKDIR $MYPATH # 镜像的工作目录

ENV JAVA_HOME /usr/local/jdk1.8.0_251
ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.37
ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.37
ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin

EXPOSE 8080 # 需要开放的端口

CMD /usr/local/apache-tomcat-9.0.37/bin/startup.sh  # 指定容器启动的时候需要运行的命令

ENTRYPOINT #也是指定运行的命令
```

首先这些文件要在同一目录下，并且这个目录最好只有这些文件![image-20200712174104663](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712174104663.png)



然后进行构建，因为Dockerfile名是官方指定的，所以会直接找到

![image-20200712174153322](https://i.loli.net/2020/07/17/NRQxWZsT2e7Ir96.png)



现在就可以看到diytomcat镜像了![image-20200712174322428](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712221352651.png)



#### Docker 打包部署SpringBoot项目

> 在羡慕里的Maven，将项目打包

![image-20200712170007269](https://i.loli.net/2020/07/17/1FUXAt8pMcqGgvo.png)

> 如果打包成功，会在下图位置找到打包好了的jar包

![image-20200712170127230](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712170127230.png)

> 注意，MySQL的配置需要使用docker里面的MySQL配置。

![image-20200712221352651](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712221446247.png)



> 同时还需要一个Dockerfile文件，如下配置

![image-20200712221446247](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200713113733838.png)



然后将他们传输到远程服务器，并且使用docker进行build

```bash
-t 目标对象 叫blog
. 表示在当前目录
docker build -t blog .
```



#### IDEA 集成Docker

```bash
# 首先更改docker的service文件，开放端口。其中2375可以是其他的没被占用的端口

# vim /lib/systemd/system/docker.service
```

![image-20200713113733838](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711225525788.png)

```bash
# 重启docker服务
systemctl daemon-reload

# 然后重新加载配置文件 
systemctl restart docker.service

# 接着在Linux防火墙中开放2375端口
firewall-cmd --add-port=2375/tcp --permanent
firewall-cmd --reload

# 然后使用netstat -nlpt 查看2375是否开放
# 用下面的进行验证
curl http://localhost:2375/info
可以打印出来数据，表示成功
```

然后就可以在IDEA中进行连接

其中的URL是远程服务器的地址，端口是docker的端口

![image-20200713114258061](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200713114258061.png)



然后在service里面点击，就可以看到当前docker里面的容器和镜像

![image-20200713120710743](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200713120710743.png)

, description=The notes of docker , createTime=2020-08-05, updateTime=2021-02-25, category=Category{id=7, name='Docker'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=19, title=Linux Notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=23, content=#### 1. Mac连接虚拟机Linux

##### a. Mac terminal 下操作

在Linux的终端中输入ifconfig来查看ip，然后再在Mac的终端中如下操作

![image-20200708112812503](https://i.loli.net/2020/07/17/V7vLXODN2ipJ6bx.png)



会要求输入Linux的密码



##### b. 从Mac传输文件到Linux

使用FileZilla，通过连接。然后直接将Mac上的文件拖放到虚拟机的Linux上面即可![image-20200708114129842](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200708114129842.png)



==Linux一般没有输出就代表操作成功==



#### Linux 基本命令：

```bash
#可以使用 man + 命令  来查看相关的选项和参数

sync # 将数据由内存同步到硬盘中

shutdown # 关机指令

### 注意在关机前，先执行sync命令将数据保存到硬盘中

reboot # 重启

shutdown -r now # 系统立马重启

######文件操作命令########

ls：列出目录
ls -a：列出全部的文件
ls -l：列出文件，并且显示文件的属性和操作权限 
ls -al: Linux的命令可以合并使用，就是上面的功能的合并

cd + 路径：切换到指定路径
cd ..：切换到上一级
cd /：回到根目录

pwd：显示当前目录

mkdir + 目录名称：创建一个新的目录 
mkdir + 参数(-m 或 -p)：
# -m: 配置文件的权限！直接配置，不需要看默认权限
# -p: 帮助你直接将所需要的目录(包含上一级目录)递归创建起来！

#例子 -p
# mkdir test1/test2/ 如果没有test1的话，那么就会显示No such file or directory  
# 所以需要加上 mkdir -p test1/test2 这样的话，如果没有test1 那么就会创建test1，接着再创建test2.

#例子 -m
# mkdir -m 711 test2 为test2 创建权限

rmdir + 目录名称：删除指定的目录

cp：复制文件或者是目录
# 用法：cp source to destination
# 例子：cp test.txt  /home 将test.txt 文件复制到home路径

rm：删除文件或者目录 ##一定要谨慎使用
# 选项与参数：
# -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；
# -i ：互动模式，在删除前会询问使用者是否动作
# -r ：递归删除！最常用在目录的删除了！这是非常危险的选项！！！


mv：移动文件或者目录
#用法与cp复制文件类似
```

#### Linux 重要的文件目录

```bash
/bin：这个目录是存放着最常用的命令

/boot：存放的是启动Linux时使用的核心文件 ###不要动

/etc：用来存放所有的系统管理需要的配置文件和子目录

/home：用户的主目录

/lib：## 不要动

/lost+found：## 一般存在于云服务器

/opt： 给服务器安装额外的软件的目录，比如说安装的数据库就可以放在这个目录

/root：根目录

/sbin：存放着系统管理员使用的系统管理程序 ##不要动

/usr：##非常重要 用户的很多应用程序和文件都放在该目录下
 
```

#### Linux 文件的属性和权限

![image-20200708142059786](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/3JoYV8kn4pdgWOB.png)

>##### 通过==10个字符==来表示文件的种类和文件的权限

第一个字符：

- 当为[ **d** ]则是目录
- 当为[ **-** ]则是文件；
- 若是[ **l** ]则表示为链接文档 ( link file )；
- 若是[ **b** ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；
- 若是[ **c** ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。

后面9个字符，是每三个为一组，分别表示如下图

其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。

![image-20200708142437235](https://i.loli.net/2020/07/17/XozlwuD6ZILpKfC.png)



如果用=="-"==字符表示没有该权限；比如上图的第三格，表示有读和执行的权限，没有写的权限

#### 修改文件权限

> Linux文件属性有两种设置方法，一种是数字，一种是符号。

每种权限对应一个分数，如下

==read: 4  write: 2 execute:1==  缩写 ==r: 4 w:2 x:1==

> Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。

用对test.txt的权限操作举例：

- owner = rwx = 4+2+1 = 7
- group = rwx = 4+2+1 = 7
- others= --- = 0+0+0 = 0

chmod 770 test.txt 表示除了others组的用户，其余的都可以对该文件进行 读，写和执行的操作

#### 查看文件内容

>Linux 系统中使用以下命令来查看文件的内容

- cat 由第一行开始显示文件内容
- tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！
- nl  显示的时候，顺道输出行号！
- more 一页一页的显示文件内容
- less 与 more 类似，但是比 more 更好的是，他可以往前翻页！
- head 只看头几行
- tail 只看尾巴几行

####  vim基本操作

```bash
vim readme.txt // 第一次使用会创建这个readme.txt文件。第二次输入该命令，则是用于修改该文件

进入文件之后，按键盘 i 可以进行文字的输入。输入完毕之后 按键盘 ESC键进行退出 然后按键盘 : 就可以进入底部命令行模式。并且输入 wq就是保存并退出。

在输入模式下，按键盘 x 表示删除光标位置的字符

以上就是基本操作
```



, description=The basic knowledge of Linux, createTime=2020-07-10, updateTime=2021-02-25, category=Category{id=23, name='Linux'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=18, title=React notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=11, content=### React 基础学习

#### React的安装

1. Mac系统先安装node，直接官网下载安装。成功之后在命令行输入 node -v 或者 npm -v 出现版本号表示安装成功

2. 使用命令：npm install -g create-react-app 安装


出现上图问题，直接给该文件夹的permission进行放行即可: sudo chmod 777 /usr/local/lib/node_modules

```bash
需要进入到项目的文件夹
npm start 是用于开发环境
npm run start 也是用于开发环境
npm run build 是用于生成环境
```

#### 创建项目

create-react-app todolist. 通过这个 命令会在当前文件夹下面创建一个叫做todolist的React项目

> 项目名称不能包含大写字母，否则会报如下的错误

![image-20201012204028354](/Users/laughingli/Library/Application Support/typora-user-images/image-20201012204028354.png)

#### 工程目录介绍

<img src="/Users/laughingli/Library/Application Support/typora-user-images/image-20201012210605456.png" alt="image-20201012210605456" style="zoom:50%;" />

1. README.md：工程的说明文件，添加关于项目的一些说明
2. package.json：项目的介绍
3. .gitignore：将该文件中指定的文件或者目录不push到git 仓库
4. node_modules：是自动下载的第三方依赖
5. public目录里面的index.html：项目首页的模板
6. public目录里面的favicon.ico：项目的图标

src目录：是项目源代码存放的目录

1. index.js：是项目代码的入口文件。

   ```react
   import React from 'react';   // 文件中使用JSX语法，就必须需引入React
   import ReactDOM from 'react-dom';
   import App from './App';
   
   ReactDOM.render(
     <React.StrictMode>
       <App /> // 将App组件挂载到id为root的dom节点下
     </React.StrictMode>,
     document.getElementById('root')
   );
   
   
   ```

   

#### React中的组件

一个组件会有如下的特征：会extends Component

```react
import React, { Component } from 'react';

class App extends Component {
  render() {  // 一个组件就是页面的一部分内容，由render()这个方法进行渲染
    return( // return就是渲染的内容
      <div>
          hello World
      </div>
    )
  }
}
export default App;
```



#### JSX语法

```jsx
	class TodoList extends Component {
    render () {
        return (
          // 这种情况下，会报错。必须要有一个parent tag
            <div>
                <input /><button>点击</button>
            </div>
            <ul>
                <li>学音乐</li>
                <li>halo</li>
            </ul>
					// 要像下面一样，包裹一个parent tag才行
          <Fragment> // Fragment 需要单独引入，跟Component一样
          	<div>
                <input /><button>点击</button>
            </div>
            <ul>
                <li>学音乐</li>
                <li>halo</li>
            </ul>
          </Fragment>
        )
    }
}


```



#### React使用范例

> 父组件，与下面的子组件相结合理解

```react
import React, { Component, Fragment } from 'react';
import './style.css';
import TodoItem from './TodoItem';

class TodoList extends Component {

    // 构造函数：props是固定的
    constructor(props) {
        super(props); // 调用父类Component的构造函数
        this.state = { // this.state表示组件的状态，它可以用来存储各种数据
            inputValue: '', // inputValue用于接收输入信息
            list: []        // list用于存储输入信息
        }
        // 通过下面的方法，让各种方法指向TodoList
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleItemDelete = this.handleItemDelete.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
    }

    render() {
        return (
            <Fragment>
                <div>
                    {/* 将input与组件的inputValue进行绑定
                    这个input的值，由inputValue决定 */}
                    {/* onChange，当输入框发生变化的时候，
                    调用handleInputChange方法 */}
                    {/* bind(this),改变方法的this指向
                    让其指向组件 */}
                    <input
                        className='input'
                        value={this.state.inputValue}
                        onChange={this.handleInputChange}
                    />
                    {/* 用于当点击发生的时候，来调用对应的方法 */}
                    <button onClick={this.handleBtnClick}>点击</button>
                </div>
                <ul>
                    {
                        this.getTodoItem()
                    }
                </ul>
            </Fragment>

        )
    }

    // 用于显示TodoItem组件的处理结果
    getTodoItem() {
        // Each child in a list should have a unique "key" prop.
        // 需要return，处理之后的结果才能被调用显示
        return this.state.list.map((item, index) => {
            // 最好不要用index作为key值
            // 当点击对应的数据的时候，将其删除handleItemDelete
            // index 用于传递给delete方法对相应的index的数据进行处理
            return (
                <TodoItem
                    // 将input的值通过content传递给了子组件 TodoItem
                    // 将index的值通过index传递给了子组件 TodoItem
                    // 将handleItemDelete方法绑定到了子组件的deleteItem上，
                    // 这样当子组件调用deleteItem的时候，就是在调用父组件的handleItemDelete
                    key={index}
                    content={item}
                    index={index}
                    deleteItem={this.handleItemDelete}
                />
            )
        })
    }

    handleInputChange(e) {
        // 用this.setState的方式来修改里面的值
        this.setState({
            inputValue: e.target.value
        })
    }

    handleBtnClick(e) {
        this.setState({
            // ...this.state.list用于获取，本来该list中含有的数据
            list: [...this.state.list, this.state.inputValue],
            // 下面用于添加完成后，将input输入框清空
            inputValue: ''
        })
    }

    handleItemDelete(index) {
        //先复制一份list原来的值，因为不能对state的内容直接进行操作
        const list = [...this.state.list];
        // 删除下标是index的内容，删除1个
        list.splice(index, 1);
        this.setState({
            list: list
        })
    }


}

export default TodoList;
```

#### 如何引用CSS文件

```jsx
import './style.css'; // 首先在头部引用CSS文件

<input 
    className='input'  // 然后再在需要使用的地方引用具体的css，记住是className而不是class
    value={this.state.inputValue} 
    onChange={this.handleInputChange.bind(this)}
/>
```



#### 如何引入本地图片

```react
import lunbo from '../../../statics/lunbo.jpeg';

<img src={lunbo} alt=''/>
```



#### 组件之间的传值

> 子组件，与上面的父组件相结合来理解

```react
import React, { Component } from 'react';

class TodoItem extends Component {

    constructor(props) {
        super(props);
        // 让这个函数指向TodoItem
        this.handleClick = this.handleClick.bind(this);
    }

    render () {
        return (
            
        <div onClick={this.handleClick}>
            {/* 当点击子组件的每一项的时候，就会调用handleClick方法 */}
            {this.props.content}
        </div>
        )
    }

    handleClick() {
        // 调用deleteItem实际上是调用父组件的handleItemDelete方法
        // this.props.index，是指的对应要删除的每一项的下标
        this.props.deleteItem(this.props.index)
    }
}

export default TodoItem;
```



#### PropTypes和DefaultProps的应用

```react
// 为了做类型校验，需要引入PropTypes
import PropTypes from 'prop-types';

// 对TodoItem组件里的属性进行校验
TodoItem.propTypes = {
    // content的内容必须是string类型
    // 后面加上isRequired就表示必须要有输入值，否则会报错
    content: PropTypes.string.isRequired,

    // deleteItem传入的内容必须是一个函数
    deleteItem: PropTypes.func,

    // index传入的内容必须是number或者是string类型
    index: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
}
export default TodoItem;
```



#### Props，State与render函数

> 当组件的state或者是props发生改变的时候，render函数就会重新执行
>
> 当父组件的render函数被运行时，子组件的render函数也会重新执行



#### 生命周期函数

> 生命周期函数：指在某一个时刻组件会自动执行的函数
>
> 举例：React的render函数，当组件的state或者props发生改变的时候，render函数就会自动执行。这就是生命周期函数

```react
componentWillMount() { 
   //已经弃用。它的意思是在组件第一次挂载之前执行。 也就是组件第一次被渲染到页面的时候
        console.log('will mount')
    }

componentDidMount() { // 在组件第一次挂载之后会执行
        console.log('did mount')
    }

// 在组件的内容更新之前会自动被执行，会返回true或者false
// 无论返回true或者false，shouldComponentUpdate都会被执行
// 但是，如果是true则表示执行更新，如果是false则表示不执行更新。
shouldComponentUpdate() {
        console.log('should ?')
        return true
    }

// 在shouldComponentUpdate()返回了true之后才会被执行，它是在组件完成更新之前被执行
// Warning: componentWillUpdate has been renamed, and is not recommended for use. 弃用
componentWillUpdate() {
        console.log('componentWillUpdate')
    }

// 也是在shouldComponentUpdate()返回了true之后才会被执行。它是在组件完成更新之后被执行
componentDidUpdate() {
        console.log('componentDidUpdate')
    }

// Warning: componentWillReceiveProps has been renamed, 
// and is not recommended for use. 弃用
componentWillReceiveProps() {
        console.log('componentWillReceiveProps')
    }
```

####  生命周期函数使用场景

```react
// 举例，父组件中引用了子组件。如果父组件的render函数被执行了，那么子组件的render函数也会被执行。
// 这在有的时候就会带来性能上的损失，因为子组件不需要随时都被执行

// 在子组件的render函数之前添加该生命周期函数
shouldComponentUpdate(nextProps, nextState, nextContext) {
  			// 如果接下来的content内容不等于当前content的内容，那么子组件的render函数才会被执行
        return nextProps.content !== this.props.content;
    }
```

#### React使用ajax

```react
// 首先要安装对应的包，从命令行进入到工程项目 然后安装
npm install axios 
// 安装完成后
// 在需要使用到ajax的地方引入即可，下面是举例使用
import axios from "axios";

// ajax的使用，就是在componentDidMount这个生命周期函数之中：因为它只会执行一次
componentDidMount() {
        axios.get('/api/todolist')
            .then(() => {alert('success')})
            .catch(() => {alert('failed')})
    }

```



#### React Router

> router安装

```bash
npm install react-router-dom 进行安装
```



> router的使用

```react
import React, { Component } from 'react';
import Header from './common/header/header.js';
import { Provider } from 'react-redux';
import store from "./common/header/redux/store";

// 先将需要的页面编辑好，然后引入
import Home from './home/index';
import Detail from './Detail/index';
// 引入路由'BrowserRouter'和路由规则'Route'
import { BrowserRouter, Route } from 'react-router-dom';

function App() {
  return (
      <Provider store={store}>
          {/* BrowserRouter标签代表路由 */}
          <BrowserRouter>
              {/* Route代表路由规则，exact 表示路由必须完全相同才能够渲染
               路由完全相同的意思：http://localhost:3000/detail，因为这个URL里面也包含
               根目录，如果不加exact，那么下面的两个路由规则都会显示。加上exact的话，就只显示
               detail的
               */}
            	{/* 直接使用Component={} 来将其添加到路由 */}
              <Route path='/' exact Component={ Home }></Route>
              <Route path='/detail' Component={ Detail }></Route>
          </BrowserRouter>
          <Header />
      </Provider>
  );
}

export default App;
```



#### 安装Immutable.JS 

```bash
npm install immutable
```



### Redux 学习

#### Redux的工作流程

> 类比图书馆借书的过程

<img src="/Users/laughingli/Library/Application Support/typora-user-images/image-20201017094121868.png" alt="image-20201017094121868" style="zoom: 25%;" />

1. React Components 代表一个借书的用户
2. Action Creators 代表一个用户具体要借什么书这一个指令
3. Store 代表图书管的管理员。数据管理的仓库
4. Reducers 代表整个图书馆的数据库，记录了每一本书的基本信息和存放位置



#### Chrome 安装 Redux DevTools

1. 首先在Chrome的extensions商店搜索 Redux DevTools

2. ```react
   // 然后再在react的store文件里面添加如下一行代码
   // window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
   const store = createStore(reducer,
       window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
   ```

3. 然后就可以在Chrome里面点击Redux DevTools进行调试

####  安装Ant Design

```bash
// 首先在命令行中进入工程目录，然后执行下面的语句
npm install antd --save
```

#### 安装Redux

```bash
// 首先在命令行中进入工程目录，然后执行下面的语句
npm install redux
```

#### redux的使用范例

##### 第一步：创建reducer

```react
const defaultState = {
    inputValue: '123',
    list: ['1', '2']
}

// state 指的是整个store仓库里面存储的数据。这里给了一个初始化的数据 defaultState
export default (state = defaultState, action) => {
    // 根据action的type来进行判断，然后进行操作
    if (action.type === 'change input value') {
        // 先拷贝之前state里面原有的数据，因为react不推荐直接操作state
        const newState = JSON.parse(JSON.stringify(state));
        // 然后将action传递来的value复制到newState的inputValue
        newState.inputValue = action.value;
        // 会将newState返回给store，store会将newState替换掉老的state
        return newState;
    }

    if (action.type === 'add todo item') {
        // 先拷贝之前state里面原有的数据，因为react不推荐直接操作state
        const newState = JSON.parse(JSON.stringify(state));
        newState.list.push(newState.inputValue);
        newState.inputValue = '';
        return newState;
    }

    if (action.type === 'delete todo item') {
        // 先拷贝之前state里面原有的数据，因为react不推荐直接操作state
        const newState = JSON.parse(JSON.stringify(state));
        newState.list.splice(action.index, 1);
        return newState;
    }
    return state;
}
```

##### 第二步：创建store

```react
import { createStore } from 'redux';
// 将reducer引入store
import reducer from "./reducer";

// 根据reducer来创建store
const store = createStore(reducer,
                         window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());

export default store;
```

##### 第三步：将store引入到需要用到的Component组件当中

```react
import React, { Component, Fragment } from "react";
import 'antd/dist/antd.css';
import { Input, List } from 'antd';
// 将store引入到组件
import store from "./store";

class TodoList extends Component {

    constructor(props) {
        super(props);

        // 将数据仓库里的数据赋值给该组件的state，第一次挂载的时候
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        // 让store订阅handleStoreChange方法，只有这个方法发生变动，那么
        // store就会产生相应的变化
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return(
            <Fragment>
                {/* 上下左右有10px的边距 */}
                <div style={{margin: '10px 10px'}}>
                    <Input value={this.state.inputValue}
                           placeholder='todo list'
                           style={{width: '300px', marginRight: '5px'}}
                           onChange={this.handleInputChange}
                    />
                    <button onClick={this.handleBtnClick}>提交</button>

                    {/* 在渲染的时候会有一个index来表示该item的下标 */}
                    {/* 将index传递给handleDelete方法 */}
                    <List style={{width: '300px'}}
                          size="large"
                          bordered
                          dataSource={this.state.list}

                          renderItem={(item, index) => <List.Item onClick={this.handleDelete.bind(this, index)}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }

    handleInputChange(e) {
        const action = {
            // 创建一个action，其中的type是固定的，用于描述该动作
            type: 'change input value',
            value: e.target.value
        }
        // 通过dispatch将action传递给store
        store.dispatch(action);
    }

    // 将store的state替换掉TodoList这个组件的state，这样就可以随时渲染更新
    handleStoreChange() {
        this.setState(store.getState());
    }

    // 当点击按钮的时候，会触发的方法
    handleBtnClick() {
        const action = {
            type: 'add todo item',
        }
        store.dispatch(action);
    }

    // 这个方法接收一个index参数，index是对应item的下标
    handleDelete(index) {
        const action = {
            type: 'delete todo item',
            index
        }
        store.dispatch(action);
    }
}

export default TodoList;
```

##### 

#### UI组件和容器组件

> 是将渲染页面的语句和逻辑语句拆分开

##### 初始组件

```react
import React, { Component, Fragment } from "react";
import 'antd/dist/antd.css';
import { Input, List } from 'antd';
// 将store引入到组件
import store from "./store";

class TodoList extends Component {

    constructor(props) {
        super(props);

        // 将数据仓库里的数据赋值给该组件的state，第一次挂载的时候
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        // 让store订阅handleStoreChange方法，只有这个方法发生变动，那么
        // store就会产生相应的变化
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return(
            <Fragment>
                {/* 上下左右有10px的边距 */}
                <div style={{margin: '10px 10px'}}>
                    <Input value={this.state.inputValue}
                           placeholder='todo list'
                           style={{width: '300px', marginRight: '5px'}}
                           onChange={this.handleInputChange}
                    />
                    <button onClick={this.handleBtnClick}>提交</button>

                    {/* 在渲染的时候会有一个index来表示该item的下标 */}
                    {/* 将index传递给handleDelete方法 */}
                    <List style={{width: '300px'}}
                          size="large"
                          bordered
                          dataSource={this.state.list}

                          renderItem={(item, index) => <List.Item onClick={this.handleDelete.bind(this, index)}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }

    handleInputChange(e) {
        const action = {
            // 创建一个action，其中的type是固定的，用于描述该动作
            type: 'change input value',
            value: e.target.value
        }
        // 通过dispatch将action传递给store
        store.dispatch(action);
    }

    // 将store的state替换掉TodoList这个组件的state，这样就可以随时渲染更新
    handleStoreChange() {
        this.setState(store.getState());
    }

    // 当点击按钮的时候，会触发的方法
    handleBtnClick() {
        const action = {
            type: 'add todo item',
        }
        store.dispatch(action);
    }

    // 这个方法接收一个index参数，index是对应item的下标
    handleDelete(index) {
        const action = {
            type: 'delete todo item',
            index
        }
        store.dispatch(action);
    }
}

export default TodoList;

```



##### 拆分后的UI组件

```react
import React, { Component, Fragment } from "react";
import {Input, List} from "antd";

class TodoListUI extends Component {
    render() {
        return (
            <Fragment>
                <div style={{margin: '10px 10px'}}>
                    <Input
                        value={this.props.inputValue}
                        placeholder="Hello World"
                        style={{width: '300px', marginRight: '5px'}}
                        onChange={this.props.handleInputChange}
                    />
                    <button onClick={this.props.handleBtnClick}>点击</button>
                    <List
                        style={{width: '300px', marginTop: '10px'}}
                        size="small"
                        bordered
                        dataSource={this.props.list}
                        renderItem={(item, index) => <List.Item onClick={() => {this.props.deleteItem(index)}}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }
}

export default TodoListUI;
```



##### 拆分后的容器组件

```react
import React, { Component, Fragment } from "react";
import "antd/dist/antd.css"
import store from "./store";
import TodoListUI from './TodoListUI';

// 将所有的action抽取出来，放到一个叫做actionTypes的文件中
import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM } from "./actionTypes";

class TodoList extends Component {

    constructor(props) {
        super(props);
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.deleteItem = this.deleteItem.bind(this)
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return <TodoListUI
        // 将组件的各种状态传递给子组件        
        inputValue = {this.state.inputValue}
        list = {this.state.list}
        handleInputChange = {this.handleInputChange}
        handleBtnClick = {this.handleBtnClick}
        deleteItem = {this.deleteItem}
        handStoreChange = {this.handleStoreChange}
        />
    }

    handleInputChange(e) {
        const action = {
            type: CHANGE_INPUT_VALUE,
            value: e.target.value
        }
        store.dispatch(action);
    }

    handleBtnClick() {
        const action = {
            type: ADD_TODO_ITEM,
        }
        store.dispatch(action);
    }

    handleStoreChange() {
        this.setState(store.getState());
    }

    deleteItem(index) {
        const action = {
            type: DELETE_TODO_ITEM,
            index
        }
        store.dispatch(action);
    }
}

export default TodoList;
```

### Redux 中间件

#### redux-thunk

> redux-thunk的安装
>
> 它可以将异步操作从组建中移除，然后发到action文件当中去

```bash
npm install redux-thunk
```

> redux-thunk中间件的使用
>
> 它主要是在创建store的时候被引用

```react
// thunk和saga它们都是中间件，如果要使用，首先需要引入applyMiddleware
import {createStore, applyMiddleware, compose} from "redux";
// 然后再引入对应的中间件，这里是thunk
import thunk from "redux-thunk";
import reducer from "./reducer";

// 如果要同时使用redux的devtools和其他的中间件，那么就需要像下面一样来写。
// 因为redux devtools也是一个中间件
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
    //    compose需要从redux中引入
    }) : compose;

const enhancer = composeEnhancers(applyMiddleware(thunk))

const store = createStore(reducer, enhancer)

export default store;
```

> actionCreators 文件

```react
// 这里是返回的一个对象
export const getDeleteItemAction = (index) => ({
    type: DELETE_TODO_ITEM,
    index
})

export const getInitItemAction = (data) => ({
    type: INIT_LIST_ITEM,
    data
});

// 这里是返回的一个函数，运用到了react-thunk。如果没有它，那么久不能返回一个函数
export const getTodoList = () => {
    return (dispatch) => {
        axios.get('https://run.mocky.io/v3/06315b0b-6c7f-49c3-9e51-94e3a35da33b')
            .then((res) => {
                const data =res.data;
                dispatch(getInitItemAction(data));
            })
            .catch(() => {console.log('failed')})
    }
}
```





### react-redux 学习

> 安装react-redux

```bash
进入到工程目录
npm install react-redux
```

#### react-redux 使用范例

##### index.js 

```react
import React from 'react';
import ReactDOM from 'react-dom';
import TodoList from "./TodoList";
import store from "./store";
// react-redux 提供的核心API
import { Provider } from 'react-redux';

const App = (
    // Provider组件，由react-redux提供。
    // Provider的store属性的值，就是整个store数据仓库的值。
    // 这样，只要是在Provider下面的组件，例如TodoList组件
    // 都可以获取到store里面的内容
    <Provider store={store}>
        <TodoList />
    </Provider>
);

ReactDOM.render(
  <React.StrictMode>
    {/* 然后将App组件传给ReactDOM.render进行渲染 */}
      {App}
  </React.StrictMode>,
  document.getElementById('root')
);
```



##### store.js 和 reducer.js 页面不需要作改变

##### TodoList.js 组件

```react
import React, { Component, Fragment } from "react";
// react-redux 提供的核心API
import { connect } from 'react-redux';
import 'antd/dist/antd.css';
import { Input, List } from 'antd';

class TodoList extends Component {

    render() {
        return(
            <Fragment>
                <div style={{margin: '10px 10px'}}>
                    <Input
                        style={{width: '300px'}}
                        placeholder='todo list'
                        value={this.props.inputValue}
                        onChange={this.props.changeInputValue}
                    />
                    <button
                        style={{marginLeft: '5px'}}
                        onClick={this.props.handleBtnClick}
                    >提交</button>

                    <List style={{width: '300px', marginTop: '10px'}}
                          size="large"
                          bordered
                          dataSource={this.props.list}
                          renderItem={(item, index) => <List.Item onClick={this.props.deleteItem.bind(this, index)}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }
}

// 这个函数是用来将store里面的state传递给子组件的props
// 这里是传递给TodoList
const mapStateToProps = (state) => {
    return {
        // 让子组件的inputValue和store里面的inputValue产生关联
        inputValue: state.inputValue,
        // 让子组件的list和store里面的list产生关联
        list: state.list
    }
}

// 将store的 dispatch方法挂载到 props上
// 这个函数是用来，将修改后的子组件state中的数据返回给store
// 让store来更改修改过后的数据
const mapDispatchToProps = (dispatch) => {
    return {
        changeInputValue(e) {
            const action = {
                type: 'change input value',
                value: e.target.value
            }
            dispatch(action);
        },
        handleBtnClick() {
            const action = {
                type: 'add todo item'
            }
            dispatch(action);
        },
        deleteItem(index) {
            const action = {
                type: 'delete todo item',
                index
            }
            dispatch(action);
        }
    }
}

// 这里的意思是，让TodoList组件与store进行连接
export default connect(mapStateToProps, mapDispatchToProps)(TodoList);
```



### react 使用styled-components

> 运用styled-components来对react项目的css文件进行管理

将css放入一个叫style.js的文件中。

```react
import { createGlobalStyle } from 'styled-components';

export const GlobalStyle = createGlobalStyle`
  body{
    marigin: 0;
    padding: 0;
    background: green;
  }
`
```

然后再将其引入到需要使用这个css的组件当中

```react
import React from 'react';
// 引入css
import { GlobalStyle } from "./style";

function App() {
  return (
    <p style={{margin: "10px 10px"}}>
      // 使用css
      <GlobalStyle/>
      Hello World
    </p>
  );
}

export default App;

```

### React 过程中的坑

> 当运用了combineReducers这个组件之后，遇到的问题

整合的reducer文件

```react
import { combineReducers } from "redux";
import reducerHeader from "../header/redux/reducer";

export default combineReducers({
    header: reducerHeader
})
```



对应的组件当中就必须如下写。因为是拆分的，所以要带上其对应的header。以此类推

```react
const mapStateToProps = (state) => {
    return {
        // 将store里面存储的信息传递给子组件，也就是这里的Header组件
        focused: state.header.get('focused'),
        hotList: state.header.get('hotList'),
        totalPage: state.header.get('totalPage'),
        page: state.header.get('page'),
        mouseIn: state.header.get('mouseIn')
    }
}
```

### Component 和 PureComponent

Component：只要项目store里面的数据发生了变化，那么每一个组件就会被重新的渲染。这样就会造成性能的降低。为了避免这样的情况，可以在组件中使用shouldComponentUpdate()这个生命周期函数。通过这个函数来判断，store里面的数据更改是否和当下的组件相关。如果不相关的话，就不重新渲染



PureComponent：react底层帮助实现了上面的功能。但是需要配合immutable.js使用，否则会出现不可预测的问题



### 异步组件/withRouter路由使用

, description=React Study, createTime=2020-07-02, updateTime=2021-02-25, category=Category{id=25, name='React'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0)], isHasContent=true, first=true, last=false, isHasNext=true, isHasPrevious=false))
2021-03-25 18:07:08.799  INFO 36287 --- [http-nio-8080-exec-2] com.banjo.blogvue.aspect.LogAspect       : Request: RequestLog{url='http://localhost:8080/blog', ip='0:0:0:0:0:0:0:1', classMethod='com.banjo.blogvue.controller.admin.AdminPageController.listBlogs', args=[]}
2021-03-25 18:07:08.799  INFO 36287 --- [http-nio-8080-exec-2] com.banjo.blogvue.aspect.LogAspect       : Result: admin/listBlogs
2021-03-25 18:07:09.375  INFO 36287 --- [http-nio-8080-exec-2] com.banjo.blogvue.aspect.LogAspect       : Request: RequestLog{url='http://localhost:8080/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.banjo.blogvue.controller.admin.BlogController.list', args=[0, 4]}
2021-03-25 18:07:09.393  INFO 36287 --- [http-nio-8080-exec-2] com.banjo.blogvue.aspect.LogAspect       : Result: Result(code=0, message=, data=Page4Navigator(pageFromJPA=Page 1 of 2 containing com.banjo.blogvue.pojo.Blog instances, navigatePages=0, navigatePageNums=null, totalPages=2, number=0, totalElements=7, size=4, numberOfElements=4, content=[Blog(id=23, title=AWS Cloud, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Translation, views=11, content=#### 卸载自带jdk

```bash
# 先使用以下命令 查看当前的jdk
rpm -qa|grep jdk
java-1.7.0-openjdk-1.7.0.261-2.6.22.1.83.amzn1.x86_64
copy-jdk-configs-3.3-10.3.amzn1.noarch

# 然后根据对应版本的jdk 直接用下面的命令删除
sudo rpm -e --nodeps java-1.7.0-openjdk-1.7.0.261-2.6.22.1.83.amzn1.x86_64

# 然后使用yum下载jdk，使用下面的命令查看java可选版本
$ yum -y list java*

# 然后根据版本号，直接下载
sudo yum install -y java-1.8.0-openjdk-devel.x86_64
```



#### FileZilla 连接 AWS

1. 打开 FileZilla 的 "Edit" -> "Settings" 对话框，在左边的“选择页面” 选择“SFTP”， 右边点击 “添加密钥文件...” 按钮，导入Amazon给的密钥文件 

   ![image-20200713163800225](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/7gZEBIRuMvdbPli.png)

2. 打开File选择Site Manager

   Protocol中选择SFTP

   Host选择 公有DNS![image-20200713163956246](https://i.loli.net/2020/07/17/9fIEBSrGNMzgoLu.png)

![image-20200713163918562](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/OQzkdvYoGqKLs5B.png)

然后选择Interactive的方式登录，用户是ec2-user

或者选择key的方式都可以

然后就能连接成功

> 连接成功之后需要将一个用于接收上传文件的文件夹进行权限修改

如下：

![image-20200713170334089](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/TNozpkPF8OgeJyM.png)



#### 安装docker

```bash
# 先查看版本 
yum -y list docker*
# 然后根据版本来下载
sudo yum install -y docker.x86_64

# 下载之后需要启动Docker服务
sudo service docker start

# 然后将ec2-user添加到docker组，否则不能执行Docker命令
sudo usermod -a -G docker ec2-user

# 然后重启AWS实例，就可以开启docker服务了
```



#### Docker vim命令

```bash
首先进入容器，然后执行
 apt-get update
 
 然后执行
 apt-get install vim
```

#### AWS 安全组

```bash
# 1. 如果tomcat开启的端口是8080，那么就需要在AWS的安全组里面放行对8080端口的访问，同时还要对9001端口进行开放

docker run -d -p 9001:8080 tomcat

其他的服务如果需要使用其他的端口，那么也用相同的方法进行放行

下面以MySQL的连接为例，3310和3306都需要在安全组里面进行放行。

 mysql          "docker-entrypoint.s…"   17 hours ago        Up 17 hours         33060/tcp, 0.0.0.0:3310->3306/tcp   mysql01
```



![image-20200714180816580](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/ysLFVnza2wGp9E6.png)



#### IDEA 连接 AWS 上的docker

1. 首先修改docker需要监听的IP和端口

```bash
   1. 首先关闭docker服务
   sudo service docker stop
   2. 然后修改docker 服务端监听的端口和ip
   sudo dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375
   3. 然后启动docker服务
   sudo service docker start
   4. 然后修改客户端的
   docker -H tcp://0.0.0.0:2375 ps
   没有输出就表示成功。
   
   
   
   ```

2. 然后再aws里面的安全组里将2375端口进行放行

3. 然后再利用IDEA对docker进行远程连接即可

> 以systemd的方式连接

```bash
1. 先找到这个文件
/lib/systemd/system/docker.service

然后注释掉下面的
ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock $OPTIONS $DOCKER_STORAGE_OPTIONS $DOCKER_ADD_RUNTIMES

然后再添加
ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock
这样远程就能通过2375端口访问到了
```

#### AWS ec2 安装MySQL

```bash
# 先查看是否有旧版本MySQL
rpm -qa | grep -i mysql

# 如果有的话，使用下面的命令将其全部删除
sudo rpm -ev 加mysql的文件名


# 下载并进入到下载好的文件夹
 wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.17-linux-glibc2.12-x86_64.tar.xz
 # 解压下载的压缩包
 tar xvf mysql-8.0.17-linux-glibc2.12-x86_64.tar.xz
 
 # 将解压好的复制到/usr/local目录下并且重命名为mysql
 sudo mv mysql-8.0.17-linux-glibc2.12-x86_64 /usr/local/mysql
 
 # 进入到mysql目录，然后创建一个data文件夹，用于存放数据
 mkdir data
 
 # 创建mysql用户组和mysql用户
 sudo groupadd mysql
 sudo useradd -g mysql mysql
 
 # 改变mysql目录权限 注意后面都有一个点
 sudo chown -R mysql .
 sudo chgrp -R mysql .
 
 # 创建mysql_install_db安装文件，并且修改权限
sudo mkdir mysql_install_db
sudo chmod 777 ./mysql_install_db

# 初始化
sudo bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data
# 一定要记住临时密码
A temporary password is generated for root@localhost: 

# mysql配置，将support-files下的移动到init.d目录下，并且重命名，两个都要
sudo cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld
sudo cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql
# 修改或者创建my.cnf文件，并且加入下面的命令

[mysqld]
    basedir = /usr/local/mysql
    datadir = /usr/local/mysql/data
    socket = /usr/local/mysql/mysql.sock
    character-set-server=utf8
    port = 3306
   sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
 [client]
   socket = /usr/local/mysql/mysql.sock
   default-character-set=utf8
   
# 建立MySQL服务
sudo chmod +x /etc/init.d/mysqld
sudo chmod +x /etc/init.d/mysql
# 添加到系统服务
sudo chkconfig --add mysqld
sudo chkconfig --add mysql
#配置全局环境变量

先设置 /etc/profile文件的权限，可以读写
sudo /etc/profile chmod 777
然后再在里面添加以下配置
export PATH=$PATH:/usr/local/mysql/bin:/usr/local/mysql/lib
export PATH

# 设置环境变量立即生效
source /etc/profile

# 启动MySQL服务

sudo service mysql start

# 登录MySQL
mysql -u root -p 回车
输入上面的临时密码即可

# 修改初始密码
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY'自己的密码';

# 设置远程可登录
进入mysql
1. use mysql
2. update user set host='%' where user='root' limit 1;
3. flush privileges; # 刷新权限

然后就可以进行远程登录
```

, description=Learn how to set up a clear AWS cloud, createTime=2021-02-17, updateTime=2021-02-25, category=Category{id=17, name='AWS Cloud'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=21, title=Docker Notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=14, content=#### Linux 安装 docker

```bash
# 1. 首先用下面的命令卸载旧版本，如果有的话
sudo yum remove docker \ 
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
                  
# 2. 安装依赖包
sudo yum install -y yum-utils        

# 3. 设置镜像仓库
sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo

# 4. 安装docker引擎
sudo yum install docker-ce docker-ce-cli containerd.io

# 5. 启动docker 和重启
sudo systemctl start docker
sudo systemctl restart docker

# 6. 测试是否启动成功
sudo docker run hello-world

# 7. 卸载依赖和删除资源
sudo yum remove docker-ce docker-ce-cli containerd.io
sudo rm -rf /var/lib/docker
```



docker run hello-world的流程图

1. docker会在本地仓库寻找hello-world的镜像，找到就运行。
2. 没找到，docker client就会跟 docker daemon联系，然后下载hello-world镜像到本地
3. 下载到本地之后，再运行该镜像。

 ![image-20200710230333325](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200710230333325.png)![image-20200710230221724](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200710230221724.png)



#### Docker 常用命令

##### 帮助命令

```shell
docker version # 查看docker信息
docker info		 # 查看docker系统信息，包括有多少镜像和容器
docker --help  # 帮助命令
```



##### 镜像命令

> 查看镜像

```bash
docker images  # 查看当前主机上的所有镜像
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              bf756fb1ae65        6 months ago        13.3kB

# docker images 命令的可选性
-a, --all 	# 列出所有的镜像跟默认的docker images一样
-q, --quit	# 只显示镜像的id,-q 和 --quit一样

[root@localhost ~]# docker images --quiet
bf756fb1ae65

[root@localhost ~]# docker images -q
bf756fb1ae65

docker search mysql 搜索mysql的镜像 #镜像的搜索
```

> 搜索镜像

```bash
docker search mysql 搜索mysql的镜像 #镜像的搜索
# 只需要添加想要的镜像的名称，就可以进行搜索。
[root@localhost ~]# docker search mysql
NAME                              DESCRIPTION                                     STARS               
mysql                             MySQL is a widely used, open-source relation…   9718
```

> 下载镜像

```bash
docker pull mysql  # 下载mysql

[root@localhost ~]# docker pull mysql
Using default tag: latest #如果不指定tag，就默认下载最新版本
latest: Pulling from library/mysql
8559a31e96f4: Pull complete	# 分层下载， docker images的核心 联合文件系统
d51ce1c2e575: Pull complete	# 好处：举例--如果要更新到更新版本的MySQL，那么下次执行pull的
c2344adc4858: Pull complete	# 时候只需要下载被更新的部分，其余没更新的不会被重复下载
fcf3ceff18fc: Pull complete
16da0c38dc5b: Pull complete
b905d1797e97: Pull complete
4b50d1c6b05c: Pull complete
c75914a65ca2: Pull complete
1ae8042bdd09: Pull complete
453ac13c00a3: Pull complete
9e680cd72f08: Pull complete
a6b5dc864b6c: Pull complete
Digest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest # 这里是真实的mysql的地址

docker pull mysql 等价于  docker pull docker.io/library/mysql:lastest
```



> 删除镜像

```bash
docker rmi -f 加上(镜像的id) 

[root@localhost ~]# docker rmi -f bf756fb1ae65
Untagged: hello-world:latest
Untagged: hello-world@sha256:d58e752213a51785838f9eed2b7a498ffa1cb3aa7f946dda11af39286c3db9a9
Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b

##或者 docker rmi -f 加上(镜像的repository名称) 
docker rmi -f hello-world

[root@localhost ~]# docker rmi -f hello-world
Untagged: hello-world:latest
Untagged: hello-world@sha256:d58e752213a51785838f9eed2b7a498ffa1cb3aa7f946dda11af39286c3db9a9
Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b

```



##### 容器命令

> 先有镜像，才能创建容器。以下用docker下载centos来进行举例学习

> 新建容器并启动

```bash
# -it 表示使用交互方式运行，进入容器查看内容
[root@localhost ~]# docker run -it centos /bin/bash  
									# docker run -d centos   表示后台启动容器
[root@f72fb12d27fc /]# ls  这里表示已经进入到了centos这个容器当中
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

[root@f72fb12d27fc /]# exit  退出并且停止容器
exit
[root@localhost ~]#

删除所有容器
docker rm $(docker ps -aq)
```

> 查看运行和曾经运行过的容器

```bash
[root@localhost ~]# docker ps -a 表示查看当前在运行的和曾经运行过的容器
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
f72fb12d27fc        centos              "/bin/bash"         3 minutes ago       Exited (0) 2 minutes ago                       hopeful_mcnulty
3af87bce0732        bf756fb1ae65        "/hello"            12 hours ago        Exited (0) 12 hours ago                        lucid_sammet
b22be932b11a        bf756fb1ae65        "/hello"            12 hours ago        Exited (0) 12 hours ago                        vigorous_chaplygin
[root@localhost ~]# docker ps  表示查看正在运行的容器
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
[root@localhost ~]#

```

> 启动，停止，重启容器

```shell
docker start 容器id
docker restart 容器id
docker stop 容器id
docker kill 容器id #强制停止当前容器
```

> 退出容器

```bash
exit 表示退出且停止容器运行

Ctrl + P + Q #不停止容器运行，只退出容器

[root@f4b87ffb286b /]# [root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
f4b87ffb286b        centos              "/bin/bash"         13 seconds ago      Up 11 seconds                           laughing_darwin
[root@localhost ~]#

```



> 进入在运行的指定容器

```shell
docker exec -it 容器名 /bin/bash

[root@localhost ~]# docker exec -it 0f45f1d47525 /bin/bash
[root@0f45f1d47525 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

docker attach 容器名

[root@localhost ~]# docker attach 0f45f1d47525
[root@0f45f1d47525 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

###区别
docker exec			# 进入容器后开启一个新的终端，可以在里面操作(这个是常用的)。
docker attach		# 进入容器正在执行的终端，不会启动新的进程。

```



> 删除容器

```bash
docker rm 容器id
```

> 列出所有容器

```bash
docker container ls
```



> 日志打印

```bash
docker logs --tail 10 0f45f1d47525  
--tail 表示以字符串的形式打印，10是--tail的参数，打印10行。最后跟的是容器的id
```

> 查看容器进程信息

```bash
docker top 容器id
[root@localhost ~]# docker top 0f45f1d47525
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                13539               13521               0                   18:08               pts/0               00:00:00            /bin/bash
```

> 查看容器元数据(所有数据)

```bash
[root@localhost ~]# docker inspect 0f45f1d47525（容器id）
```



> 从容器中复制文件到主机

```bash
[root@6ad773845eab /]# cd home  开启容器 进入到home目录
[root@6ad773845eab home]# touch test.java	在home目录创建test.java文件
[root@6ad773845eab home]# ls
test.java
[root@6ad773845eab home]# exit 退出即可
exit
[root@localhost ~]# ls 当前文件夹下是没有test.java文件
anaconda-ks.cfg  Desktop  Documents  Downloads  Music  original-ks.cfg  Pictures  Public  study.txt  Templates  Videos  

# 将6ad773845eab:/home/test.java  将这个容器的home目录中的test.java文件复制到
# ~目录。
[root@localhost ~]# docker cp 6ad773845eab:/home/test.java ~
[root@localhost ~]# ls
anaconda-ks.cfg  Desktop  Documents  Downloads  Music  original-ks.cfg  Pictures  Public  study.txt  Templates  test.java  Videos
[root@localhost ~]#
```



#### Docker Nginx

##### 启动并验证Nginx

```bash
-d 表示后台运行
--name nginx01表示它的名字
-p 8082:80 #8082表示客户端访问的请求的端口，80表示本地与之对应的端口。
就是客户端访问8082端口会拿到本地80端口的数据

[root@localhost ~]# docker run -d --name nginx01 -p 8082:80 nginx
f0a1f169564a7c8faacb1aa73cae06449267e5b39493a05196086823b69f8972
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
f0a1f169564a        nginx               "/docker-entrypoint.…"   4 seconds ago       Up 3 seconds        0.0.0.0:8082->80/tcp   nginx01
6ad773845eab        centos              "/bin/bash"              56 minutes ago      Up 51 minutes                              elastic_mestorf
[root@localhost ~]# curl localhost:8082  验证是否能够访问成功
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
Nginx在docker里面的配置文件在 /etc/nginx路径下面
```



#### Docker Tomcat

```bash
# tomcat 的启动跟Nginx相似
也是要设置端口的映射。才能进行访问
[root@localhost ~]# docker run -d -p 9001:8080 tomcat
4126cf694a054e44dfa27a059da130ff8201d427b0e1aeeafb57a986f8fa8667
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
4126cf694a05        tomcat              "catalina.sh run"        4 seconds ago       Up 3 seconds        0.0.0.0:9001->8080/tcp   loving_bell
f0a1f169564a        nginx               "/docker-entrypoint.…"   27 minutes ago      Up 27 minutes       0.0.0.0:8082->80/tcp     nginx01
6ad773845eab        centos              "/bin/bash"              About an hour ago   Up About an hour                             elastic_mestorf

## 返回404 表示能够访问，但是当前的Tomcat里面还缺少可用于访问的文件
[root@localhost ~]# curl localhost:9001
<!doctype html><html lang="en"><head><title>HTTP Status 404 – Not Found</title><style type="text/css">body {font-family:Tahoma,Arial,sans-serif;} h1, h2, h3, b {color:white;background-color:#525D76;} h1 {font-size:22px;} h2 {font-size:16px;} h3 {font-size:14px;} p {font-size:12px;} a {color:black;} .line {height:1px;background-color:#525D76;border:none;}</style></head><body><h1>HTTP Status 404 – Not Found</h1><hr class="line" /><p><b>Type</b> Status Report</p><p><b>Description</b> The origin server did not find a current representation for the target resource or is [root@lo[root@localhost ~]#

# 解决办法

[root@localhost ~]# docker exec -it 4126cf694a05 /bin/bash 先重新进入Tomcat运行的容器
root@4126cf694a05:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work

## 将webapps.dist 文件夹的内容全部复制的 webapps即可

root@4126cf694a05:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work
root@4126cf694a05:/usr/local/tomcat# cd webapps.dist
root@4126cf694a05:/usr/local/tomcat/webapps.dist# ls
ROOT  docs  examples  host-manager  manager
root@4126cf694a05:/usr/local/tomcat/webapps.dist# cd examples
root@4126cf694a05:/usr/local/tomcat/webapps.dist/examples# ls
WEB-INF  index.html  jsp  servlets  websocket
root@4126cf694a05:/usr/local/tomcat/webapps.dist/examples# cd ..
root@4126cf694a05:/usr/local/tomcat/webapps.dist# cd ..
root@4126cf694a05:/usr/local/tomcat# cp -r webapps.dist/* webapps
root@4126cf694a05:/usr/local/tomcat#

#然后就能成功访问到index页面
```





#### Docker ElasticSearch

```bash
# 先下载ElasticSearch
# docker pull docker.elastic.co/elasticsearch/elasticsearch:7.8.0

# 官方推荐的开启单节点集群
# docker run -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" docker.elastic.co/elasticsearch/elasticsearch:7.8.0
但是上面的方式会暴露一个问题，那就是ES占内存非常大，而我们的虚拟机内存很小。所以不建议这样开启

# 其中 -e ES_JAVA_OPTS="-Xms64m -Xmx512m" 表示最小占用64M内存 最大占用512M
# docker run -d -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.8.0

然后去访问 即可验证
[root@localhost ~]# curl localhost:9200
{
  "name" : "88e49838ff71",
  "cluster_name" : "docker-cluster",
  "cluster_uuid" : "T6BQKfqySz63NlT_Tp9NYQ",
  "version" : {
    "number" : "7.8.0",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "757314695644ea9a1dc2fecd26d1a43856725e65",
    "build_date" : "2020-06-14T19:35:50.234439Z",
    "build_snapshot" : false,
    "lucene_version" : "8.5.1",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}
```



#### Docker 提交镜像

==提交了之后，只是在本地存在。还需要push到网络上，才能实现下载使用的功能==

```bash
举例：下载的Tomcat镜像中，webapps文件夹是没有东西的，所以我们在webapps文件夹下面创建一些文件。然后通过下面的命令将修改后的镜像commit
-m 用于添加描述信息，跟Git类似。-a 是作者名字。加上需要修改的容器id，然后 tomcat01是repository名

[root@localhost ~]# docker commit -m="docker with changes in webapps" -a="banjo" 6c9c1265f18e tomcat01
sha256:b1c6475b6b76c51fa3cb08edcb82ec37725c93643eca9274e12301e44594f781
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
6c9c1265f18e        tomcat              "catalina.sh run"   3 minutes ago       Up 3 minutes        0.0.0.0:9001->8080/tcp   recursing_thompson
[root@localhost ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
tomcat01            latest              b1c6475b6b76        9 seconds ago       652MB
nginx               latest              0901fa9da894        11 hours ago        132MB
tomcat              latest              6055d4d564e1        4 days ago          647MB
centos              latest              831691599b88        3 weeks ago         215MB
elasticsearch       7.8.0               121454ddad72        3 weeks ago         810MB
mysql               latest              be0dbf01a0f3        4 weeks ago         541MB
```

![image-20200711174623196](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711192711325.png)



#### Docker 容器数据卷

容器数据卷可以帮助容器的持久化和同步操作，容器间的数据也可以共享

就是容器中的一个路径映射到本地主机上的一个路径，只要容器中的这个路径里面进行了操作，比如添加文件，删除文件，修改文件，那么在主机上的映射的这个目录也会有相同的操作。

==我的理解：以后可以在本地的/home 目录下面创建，centos，Tomcat，ES，redis，Nginx这些目录，然后将这些目录分别的映射到对应的容器中去，就可以保证容器中的重要数据不会丢失==

> 直接使用命令的方式进行挂载

```bash
举例: -v 是用来挂载的 : 有的时候在容器路径下 ### eg. /home:ro 或者 /home:rw 这表示read only或者read & write 表示在容器中这个路径下的文件是只读或者读写均可

将本地主机/home/centos 路径 与 容器centos的 /home路径进行绑定
[root@localhost ~]# docker run -it -v /home/centos:/home centos /bin/bash

然后使用 docker inspect 容器id就可以查看到以下信息，如果没有出现，则代表没有挂载成功。

测试方法，在容器的/home路径下面创建文件，然后再在本地主机的/home/centos下查看是否有相同的文件

同样的去本地主机创建文件，然后去容器中去查看也可以验证
```

![image-20200711192711325](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711174623196.png)



##### 匿名挂载

```bash
# 1. 匿名挂载
-d	后台运行
-P	大写的P表示随机的端口
这里没有指定本机的路径，所以就是匿名挂载
[root@localhost /]# docker run -d -P --name nginx01 -v /etc/nginx nginx
326008beb69c229e1a424d6127aba2dd409989092108b90a60aaff11fa3abb93

[root@localhost /]# docker volume ls 通过这个命令可以拿到匿名挂载的名称
DRIVER              VOLUME NAME
local               626a093ff31bcf34ef1741f5eab3e3077a7bf445a1280fd2f2cb3fd6f448a004
local               6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70

[root@localhost /]# docker volume inspect 6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70 然后通过这个命令查看当前的匿名挂载是映射到本机的什么位置，可以看到是在/var/lib/docker/volumes下面
[
    {
        "CreatedAt": "2020-07-11T05:50:36-07:00",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70/_data",
        "Name": "6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70",
        "Options": null,
        "Scope": "local"
    }
]

```

![image-20200711225525788](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712112330604.png)

##### 具名挂载

```bash
# 2. 具名挂载
test-nginx 就是这个挂载的名字
[root@localhost /]# docker run -d -P --name nginx02 -v test-nginx:/etc/nginx nginx
```

![image-20200711225848468](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711225848468.png)



##### Dockerfile方式挂载

```bash
# 先在主机的一个路径里面生成一个叫做dockerfile的文件
[root@localhost ~]# mkdir /home/docker-test-volume 创建这个目录
[root@localhost ~]# cd /home/docker-test-volume 进入这个目录
[root@localhost docker-test-volume]# ls
[root@localhost docker-test-volume]# vim dockerfile1  创建dockerfile1 文件并写下下面的内容
[root@localhost docker-test-volume]# cat dockerfile1
FROM centos ##以镜像centos为基础

VOLUME ["volume01", "volume02"]  ## 挂载两个卷

CMD echo "-----success------"   ## 成功后的输出
CMD /bin/bash		## 然后会进入该路径

# build 用于创建dockerfile
# -f 		哪一个file文件
# -t		生成的对象
# .			生成在当前目录下

[root@localhost docker-test-volume]# docker build -f /home/docker-test-volume/dockerfile1 -t test/centos .

Sending build context to Docker daemon  2.048kB
Step 1/4 : FROM centos
 ---> 831691599b88
Step 2/4 : VOLUME ["volume01", "volume02"]
 ---> Running in 0c80409788d3
Removing intermediate container 0c80409788d3
 ---> 4e7fe085c688
Step 3/4 : CMD echo "-----success------"
 ---> Running in 3a6eebcf35a9
Removing intermediate container 3a6eebcf35a9
 ---> ec43d897d893
Step 4/4 : CMD /bin/bash
 ---> Running in 7f1029e69632
Removing intermediate container 7f1029e69632
 ---> efd4071b1ad0
Successfully built efd4071b1ad0
Successfully tagged test/centos:latest
## 镜像生成成功
test/centos         latest              efd4071b1ad0        2 minutes ago       215MB
```

当我们利用这个镜像创建容器的时候，就可以看到挂载的卷。

![image-20200712112330604](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712112754635.png)

![image-20200712112754635](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712174322428.png)



##### 数据卷容器

> **--volumes-from** 顾名思义，就是从另一个容器当中挂载容器中已经创建好的数据卷。

以上面的为例，先创建centos01 里面有已经创建好的volume01和volume02的数据卷

然后创建centos02 从centos01中挂载已经创建好的这两个数据卷。

挂载好之后，无论在哪一个容器中修改数据卷中的内容，两个容器都会同步。即使将centos01容器删除，centos02容器中数据卷中的数据也不会丢失

```bash
# 使用以下命令进行挂载
# 而且可以有多个容器对centos01进行挂载，比如centos03
--volumes-from 表示centos02 从 centos01中挂载已经创建好的volume01和volume02数据卷

# docker run -it --name centos02 --volumes-from centos01 test/centos

```





#### Docker MySQL 

```shell
# 需要在Linux中将MySQL的端口在防火墙中开放。
firewall-cmd --add-port=3306/tcp --permanent
firewall-cmd --add-port=3310/tcp --permanent

-d	后台运行
-p	端口映射
-v	卷挂载，可以多个
--name	容器的名字
-e	环境配置
# MYSQL_ROOT_PASSWORD 初始化root的密码
docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123123 --name mysql01 mysql

# 1 先开启MySQL容器
# docker run -it tomcat /bin/bash  
# 然后在MySQL里面 执行以下操作
root@3eeba4e8cfee:/# mysql -u root -p 
查看 root的加密方式
mysql> select host,user,plugin,authentication_string from mysql.user;
+-----------+------------------+-----------------------+
| host      | user             | plugin                | 
+-----------+------------------+-----------------------+
| %         | root             | caching_sha2_password | 
| localhost | mysql.infoschema | caching_sha2_password | 
| localhost | mysql.session    | caching_sha2_password |
| localhost | mysql.sys        | caching_sha2_password |
| localhost | root             | caching_sha2_password | 
如果root的plugin显示是caching_sha2_password 那么就需要作如下的更改，'123123是代表MySQL的密码'
mysql> ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123123';
mysql> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123123';
然后远程就可以连接到本地的MySQL服务了
```

![image-20200711222503711](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/j7mgN8FfSoMXzqI.png)

3310是与MySQL端口号3306对应的

##### 多个MySQL实现数据共享

```bash
# 1. 先创建mysql01，然后将mysql01里面的conf.d和mysql设置成容器数据卷。

docker run -it -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123123 --name mysql01 

# 2. 然后创建mysql02，使用--volumes-from挂载到mysql01的容器数据卷，这样两个mysql之间就可以进行数据共享了
docker run -it -p 3311:3306 -e MYSQL_ROOT_PASSWORD=123123 --name mysql02 --volumes-from mysql01 mysql
```



#### DockerFile

> 以构建tomcat镜像为例

```bash
FROM centos # 以centos为基础

MAINTAINER banjo<mr.singledog@gmail.com> # 表明作者是谁

ADD jdk-8u251-linux-x64.tar.gz /usr/local 
ADD apache-tomcat-9.0.37.tar.gz /usr/local

RUN yum -y install vim # 镜像构建的时候需要运行的命令
RUN yum -y install net-tools

ENV MYPATH /usr/local # 构建镜像的时候设置环境变量

### VOLUME 表示挂载的目录

WORKDIR $MYPATH # 镜像的工作目录

ENV JAVA_HOME /usr/local/jdk1.8.0_251
ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.37
ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.37
ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin

EXPOSE 8080 # 需要开放的端口

CMD /usr/local/apache-tomcat-9.0.37/bin/startup.sh  # 指定容器启动的时候需要运行的命令

ENTRYPOINT #也是指定运行的命令
```

首先这些文件要在同一目录下，并且这个目录最好只有这些文件![image-20200712174104663](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712174104663.png)



然后进行构建，因为Dockerfile名是官方指定的，所以会直接找到

![image-20200712174153322](https://i.loli.net/2020/07/17/NRQxWZsT2e7Ir96.png)



现在就可以看到diytomcat镜像了![image-20200712174322428](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712221352651.png)



#### Docker 打包部署SpringBoot项目

> 在羡慕里的Maven，将项目打包

![image-20200712170007269](https://i.loli.net/2020/07/17/1FUXAt8pMcqGgvo.png)

> 如果打包成功，会在下图位置找到打包好了的jar包

![image-20200712170127230](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712170127230.png)

> 注意，MySQL的配置需要使用docker里面的MySQL配置。

![image-20200712221352651](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712221446247.png)



> 同时还需要一个Dockerfile文件，如下配置

![image-20200712221446247](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200713113733838.png)



然后将他们传输到远程服务器，并且使用docker进行build

```bash
-t 目标对象 叫blog
. 表示在当前目录
docker build -t blog .
```



#### IDEA 集成Docker

```bash
# 首先更改docker的service文件，开放端口。其中2375可以是其他的没被占用的端口

# vim /lib/systemd/system/docker.service
```

![image-20200713113733838](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711225525788.png)

```bash
# 重启docker服务
systemctl daemon-reload

# 然后重新加载配置文件 
systemctl restart docker.service

# 接着在Linux防火墙中开放2375端口
firewall-cmd --add-port=2375/tcp --permanent
firewall-cmd --reload

# 然后使用netstat -nlpt 查看2375是否开放
# 用下面的进行验证
curl http://localhost:2375/info
可以打印出来数据，表示成功
```

然后就可以在IDEA中进行连接

其中的URL是远程服务器的地址，端口是docker的端口

![image-20200713114258061](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200713114258061.png)



然后在service里面点击，就可以看到当前docker里面的容器和镜像

![image-20200713120710743](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200713120710743.png)

, description=The notes of docker , createTime=2020-08-05, updateTime=2021-02-25, category=Category{id=7, name='Docker'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=19, title=Linux Notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=23, content=#### 1. Mac连接虚拟机Linux

##### a. Mac terminal 下操作

在Linux的终端中输入ifconfig来查看ip，然后再在Mac的终端中如下操作

![image-20200708112812503](https://i.loli.net/2020/07/17/V7vLXODN2ipJ6bx.png)



会要求输入Linux的密码



##### b. 从Mac传输文件到Linux

使用FileZilla，通过连接。然后直接将Mac上的文件拖放到虚拟机的Linux上面即可![image-20200708114129842](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200708114129842.png)



==Linux一般没有输出就代表操作成功==



#### Linux 基本命令：

```bash
#可以使用 man + 命令  来查看相关的选项和参数

sync # 将数据由内存同步到硬盘中

shutdown # 关机指令

### 注意在关机前，先执行sync命令将数据保存到硬盘中

reboot # 重启

shutdown -r now # 系统立马重启

######文件操作命令########

ls：列出目录
ls -a：列出全部的文件
ls -l：列出文件，并且显示文件的属性和操作权限 
ls -al: Linux的命令可以合并使用，就是上面的功能的合并

cd + 路径：切换到指定路径
cd ..：切换到上一级
cd /：回到根目录

pwd：显示当前目录

mkdir + 目录名称：创建一个新的目录 
mkdir + 参数(-m 或 -p)：
# -m: 配置文件的权限！直接配置，不需要看默认权限
# -p: 帮助你直接将所需要的目录(包含上一级目录)递归创建起来！

#例子 -p
# mkdir test1/test2/ 如果没有test1的话，那么就会显示No such file or directory  
# 所以需要加上 mkdir -p test1/test2 这样的话，如果没有test1 那么就会创建test1，接着再创建test2.

#例子 -m
# mkdir -m 711 test2 为test2 创建权限

rmdir + 目录名称：删除指定的目录

cp：复制文件或者是目录
# 用法：cp source to destination
# 例子：cp test.txt  /home 将test.txt 文件复制到home路径

rm：删除文件或者目录 ##一定要谨慎使用
# 选项与参数：
# -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；
# -i ：互动模式，在删除前会询问使用者是否动作
# -r ：递归删除！最常用在目录的删除了！这是非常危险的选项！！！


mv：移动文件或者目录
#用法与cp复制文件类似
```

#### Linux 重要的文件目录

```bash
/bin：这个目录是存放着最常用的命令

/boot：存放的是启动Linux时使用的核心文件 ###不要动

/etc：用来存放所有的系统管理需要的配置文件和子目录

/home：用户的主目录

/lib：## 不要动

/lost+found：## 一般存在于云服务器

/opt： 给服务器安装额外的软件的目录，比如说安装的数据库就可以放在这个目录

/root：根目录

/sbin：存放着系统管理员使用的系统管理程序 ##不要动

/usr：##非常重要 用户的很多应用程序和文件都放在该目录下
 
```

#### Linux 文件的属性和权限

![image-20200708142059786](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/3JoYV8kn4pdgWOB.png)

>##### 通过==10个字符==来表示文件的种类和文件的权限

第一个字符：

- 当为[ **d** ]则是目录
- 当为[ **-** ]则是文件；
- 若是[ **l** ]则表示为链接文档 ( link file )；
- 若是[ **b** ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；
- 若是[ **c** ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。

后面9个字符，是每三个为一组，分别表示如下图

其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。

![image-20200708142437235](https://i.loli.net/2020/07/17/XozlwuD6ZILpKfC.png)



如果用=="-"==字符表示没有该权限；比如上图的第三格，表示有读和执行的权限，没有写的权限

#### 修改文件权限

> Linux文件属性有两种设置方法，一种是数字，一种是符号。

每种权限对应一个分数，如下

==read: 4  write: 2 execute:1==  缩写 ==r: 4 w:2 x:1==

> Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。

用对test.txt的权限操作举例：

- owner = rwx = 4+2+1 = 7
- group = rwx = 4+2+1 = 7
- others= --- = 0+0+0 = 0

chmod 770 test.txt 表示除了others组的用户，其余的都可以对该文件进行 读，写和执行的操作

#### 查看文件内容

>Linux 系统中使用以下命令来查看文件的内容

- cat 由第一行开始显示文件内容
- tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！
- nl  显示的时候，顺道输出行号！
- more 一页一页的显示文件内容
- less 与 more 类似，但是比 more 更好的是，他可以往前翻页！
- head 只看头几行
- tail 只看尾巴几行

####  vim基本操作

```bash
vim readme.txt // 第一次使用会创建这个readme.txt文件。第二次输入该命令，则是用于修改该文件

进入文件之后，按键盘 i 可以进行文字的输入。输入完毕之后 按键盘 ESC键进行退出 然后按键盘 : 就可以进入底部命令行模式。并且输入 wq就是保存并退出。

在输入模式下，按键盘 x 表示删除光标位置的字符

以上就是基本操作
```



, description=The basic knowledge of Linux, createTime=2020-07-10, updateTime=2021-02-25, category=Category{id=23, name='Linux'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=18, title=React notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=11, content=### React 基础学习

#### React的安装

1. Mac系统先安装node，直接官网下载安装。成功之后在命令行输入 node -v 或者 npm -v 出现版本号表示安装成功

2. 使用命令：npm install -g create-react-app 安装


出现上图问题，直接给该文件夹的permission进行放行即可: sudo chmod 777 /usr/local/lib/node_modules

```bash
需要进入到项目的文件夹
npm start 是用于开发环境
npm run start 也是用于开发环境
npm run build 是用于生成环境
```

#### 创建项目

create-react-app todolist. 通过这个 命令会在当前文件夹下面创建一个叫做todolist的React项目

> 项目名称不能包含大写字母，否则会报如下的错误

![image-20201012204028354](/Users/laughingli/Library/Application Support/typora-user-images/image-20201012204028354.png)

#### 工程目录介绍

<img src="/Users/laughingli/Library/Application Support/typora-user-images/image-20201012210605456.png" alt="image-20201012210605456" style="zoom:50%;" />

1. README.md：工程的说明文件，添加关于项目的一些说明
2. package.json：项目的介绍
3. .gitignore：将该文件中指定的文件或者目录不push到git 仓库
4. node_modules：是自动下载的第三方依赖
5. public目录里面的index.html：项目首页的模板
6. public目录里面的favicon.ico：项目的图标

src目录：是项目源代码存放的目录

1. index.js：是项目代码的入口文件。

   ```react
   import React from 'react';   // 文件中使用JSX语法，就必须需引入React
   import ReactDOM from 'react-dom';
   import App from './App';
   
   ReactDOM.render(
     <React.StrictMode>
       <App /> // 将App组件挂载到id为root的dom节点下
     </React.StrictMode>,
     document.getElementById('root')
   );
   
   
   ```

   

#### React中的组件

一个组件会有如下的特征：会extends Component

```react
import React, { Component } from 'react';

class App extends Component {
  render() {  // 一个组件就是页面的一部分内容，由render()这个方法进行渲染
    return( // return就是渲染的内容
      <div>
          hello World
      </div>
    )
  }
}
export default App;
```



#### JSX语法

```jsx
	class TodoList extends Component {
    render () {
        return (
          // 这种情况下，会报错。必须要有一个parent tag
            <div>
                <input /><button>点击</button>
            </div>
            <ul>
                <li>学音乐</li>
                <li>halo</li>
            </ul>
					// 要像下面一样，包裹一个parent tag才行
          <Fragment> // Fragment 需要单独引入，跟Component一样
          	<div>
                <input /><button>点击</button>
            </div>
            <ul>
                <li>学音乐</li>
                <li>halo</li>
            </ul>
          </Fragment>
        )
    }
}


```



#### React使用范例

> 父组件，与下面的子组件相结合理解

```react
import React, { Component, Fragment } from 'react';
import './style.css';
import TodoItem from './TodoItem';

class TodoList extends Component {

    // 构造函数：props是固定的
    constructor(props) {
        super(props); // 调用父类Component的构造函数
        this.state = { // this.state表示组件的状态，它可以用来存储各种数据
            inputValue: '', // inputValue用于接收输入信息
            list: []        // list用于存储输入信息
        }
        // 通过下面的方法，让各种方法指向TodoList
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleItemDelete = this.handleItemDelete.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
    }

    render() {
        return (
            <Fragment>
                <div>
                    {/* 将input与组件的inputValue进行绑定
                    这个input的值，由inputValue决定 */}
                    {/* onChange，当输入框发生变化的时候，
                    调用handleInputChange方法 */}
                    {/* bind(this),改变方法的this指向
                    让其指向组件 */}
                    <input
                        className='input'
                        value={this.state.inputValue}
                        onChange={this.handleInputChange}
                    />
                    {/* 用于当点击发生的时候，来调用对应的方法 */}
                    <button onClick={this.handleBtnClick}>点击</button>
                </div>
                <ul>
                    {
                        this.getTodoItem()
                    }
                </ul>
            </Fragment>

        )
    }

    // 用于显示TodoItem组件的处理结果
    getTodoItem() {
        // Each child in a list should have a unique "key" prop.
        // 需要return，处理之后的结果才能被调用显示
        return this.state.list.map((item, index) => {
            // 最好不要用index作为key值
            // 当点击对应的数据的时候，将其删除handleItemDelete
            // index 用于传递给delete方法对相应的index的数据进行处理
            return (
                <TodoItem
                    // 将input的值通过content传递给了子组件 TodoItem
                    // 将index的值通过index传递给了子组件 TodoItem
                    // 将handleItemDelete方法绑定到了子组件的deleteItem上，
                    // 这样当子组件调用deleteItem的时候，就是在调用父组件的handleItemDelete
                    key={index}
                    content={item}
                    index={index}
                    deleteItem={this.handleItemDelete}
                />
            )
        })
    }

    handleInputChange(e) {
        // 用this.setState的方式来修改里面的值
        this.setState({
            inputValue: e.target.value
        })
    }

    handleBtnClick(e) {
        this.setState({
            // ...this.state.list用于获取，本来该list中含有的数据
            list: [...this.state.list, this.state.inputValue],
            // 下面用于添加完成后，将input输入框清空
            inputValue: ''
        })
    }

    handleItemDelete(index) {
        //先复制一份list原来的值，因为不能对state的内容直接进行操作
        const list = [...this.state.list];
        // 删除下标是index的内容，删除1个
        list.splice(index, 1);
        this.setState({
            list: list
        })
    }


}

export default TodoList;
```

#### 如何引用CSS文件

```jsx
import './style.css'; // 首先在头部引用CSS文件

<input 
    className='input'  // 然后再在需要使用的地方引用具体的css，记住是className而不是class
    value={this.state.inputValue} 
    onChange={this.handleInputChange.bind(this)}
/>
```



#### 如何引入本地图片

```react
import lunbo from '../../../statics/lunbo.jpeg';

<img src={lunbo} alt=''/>
```



#### 组件之间的传值

> 子组件，与上面的父组件相结合来理解

```react
import React, { Component } from 'react';

class TodoItem extends Component {

    constructor(props) {
        super(props);
        // 让这个函数指向TodoItem
        this.handleClick = this.handleClick.bind(this);
    }

    render () {
        return (
            
        <div onClick={this.handleClick}>
            {/* 当点击子组件的每一项的时候，就会调用handleClick方法 */}
            {this.props.content}
        </div>
        )
    }

    handleClick() {
        // 调用deleteItem实际上是调用父组件的handleItemDelete方法
        // this.props.index，是指的对应要删除的每一项的下标
        this.props.deleteItem(this.props.index)
    }
}

export default TodoItem;
```



#### PropTypes和DefaultProps的应用

```react
// 为了做类型校验，需要引入PropTypes
import PropTypes from 'prop-types';

// 对TodoItem组件里的属性进行校验
TodoItem.propTypes = {
    // content的内容必须是string类型
    // 后面加上isRequired就表示必须要有输入值，否则会报错
    content: PropTypes.string.isRequired,

    // deleteItem传入的内容必须是一个函数
    deleteItem: PropTypes.func,

    // index传入的内容必须是number或者是string类型
    index: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
}
export default TodoItem;
```



#### Props，State与render函数

> 当组件的state或者是props发生改变的时候，render函数就会重新执行
>
> 当父组件的render函数被运行时，子组件的render函数也会重新执行



#### 生命周期函数

> 生命周期函数：指在某一个时刻组件会自动执行的函数
>
> 举例：React的render函数，当组件的state或者props发生改变的时候，render函数就会自动执行。这就是生命周期函数

```react
componentWillMount() { 
   //已经弃用。它的意思是在组件第一次挂载之前执行。 也就是组件第一次被渲染到页面的时候
        console.log('will mount')
    }

componentDidMount() { // 在组件第一次挂载之后会执行
        console.log('did mount')
    }

// 在组件的内容更新之前会自动被执行，会返回true或者false
// 无论返回true或者false，shouldComponentUpdate都会被执行
// 但是，如果是true则表示执行更新，如果是false则表示不执行更新。
shouldComponentUpdate() {
        console.log('should ?')
        return true
    }

// 在shouldComponentUpdate()返回了true之后才会被执行，它是在组件完成更新之前被执行
// Warning: componentWillUpdate has been renamed, and is not recommended for use. 弃用
componentWillUpdate() {
        console.log('componentWillUpdate')
    }

// 也是在shouldComponentUpdate()返回了true之后才会被执行。它是在组件完成更新之后被执行
componentDidUpdate() {
        console.log('componentDidUpdate')
    }

// Warning: componentWillReceiveProps has been renamed, 
// and is not recommended for use. 弃用
componentWillReceiveProps() {
        console.log('componentWillReceiveProps')
    }
```

####  生命周期函数使用场景

```react
// 举例，父组件中引用了子组件。如果父组件的render函数被执行了，那么子组件的render函数也会被执行。
// 这在有的时候就会带来性能上的损失，因为子组件不需要随时都被执行

// 在子组件的render函数之前添加该生命周期函数
shouldComponentUpdate(nextProps, nextState, nextContext) {
  			// 如果接下来的content内容不等于当前content的内容，那么子组件的render函数才会被执行
        return nextProps.content !== this.props.content;
    }
```

#### React使用ajax

```react
// 首先要安装对应的包，从命令行进入到工程项目 然后安装
npm install axios 
// 安装完成后
// 在需要使用到ajax的地方引入即可，下面是举例使用
import axios from "axios";

// ajax的使用，就是在componentDidMount这个生命周期函数之中：因为它只会执行一次
componentDidMount() {
        axios.get('/api/todolist')
            .then(() => {alert('success')})
            .catch(() => {alert('failed')})
    }

```



#### React Router

> router安装

```bash
npm install react-router-dom 进行安装
```



> router的使用

```react
import React, { Component } from 'react';
import Header from './common/header/header.js';
import { Provider } from 'react-redux';
import store from "./common/header/redux/store";

// 先将需要的页面编辑好，然后引入
import Home from './home/index';
import Detail from './Detail/index';
// 引入路由'BrowserRouter'和路由规则'Route'
import { BrowserRouter, Route } from 'react-router-dom';

function App() {
  return (
      <Provider store={store}>
          {/* BrowserRouter标签代表路由 */}
          <BrowserRouter>
              {/* Route代表路由规则，exact 表示路由必须完全相同才能够渲染
               路由完全相同的意思：http://localhost:3000/detail，因为这个URL里面也包含
               根目录，如果不加exact，那么下面的两个路由规则都会显示。加上exact的话，就只显示
               detail的
               */}
            	{/* 直接使用Component={} 来将其添加到路由 */}
              <Route path='/' exact Component={ Home }></Route>
              <Route path='/detail' Component={ Detail }></Route>
          </BrowserRouter>
          <Header />
      </Provider>
  );
}

export default App;
```



#### 安装Immutable.JS 

```bash
npm install immutable
```



### Redux 学习

#### Redux的工作流程

> 类比图书馆借书的过程

<img src="/Users/laughingli/Library/Application Support/typora-user-images/image-20201017094121868.png" alt="image-20201017094121868" style="zoom: 25%;" />

1. React Components 代表一个借书的用户
2. Action Creators 代表一个用户具体要借什么书这一个指令
3. Store 代表图书管的管理员。数据管理的仓库
4. Reducers 代表整个图书馆的数据库，记录了每一本书的基本信息和存放位置



#### Chrome 安装 Redux DevTools

1. 首先在Chrome的extensions商店搜索 Redux DevTools

2. ```react
   // 然后再在react的store文件里面添加如下一行代码
   // window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
   const store = createStore(reducer,
       window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
   ```

3. 然后就可以在Chrome里面点击Redux DevTools进行调试

####  安装Ant Design

```bash
// 首先在命令行中进入工程目录，然后执行下面的语句
npm install antd --save
```

#### 安装Redux

```bash
// 首先在命令行中进入工程目录，然后执行下面的语句
npm install redux
```

#### redux的使用范例

##### 第一步：创建reducer

```react
const defaultState = {
    inputValue: '123',
    list: ['1', '2']
}

// state 指的是整个store仓库里面存储的数据。这里给了一个初始化的数据 defaultState
export default (state = defaultState, action) => {
    // 根据action的type来进行判断，然后进行操作
    if (action.type === 'change input value') {
        // 先拷贝之前state里面原有的数据，因为react不推荐直接操作state
        const newState = JSON.parse(JSON.stringify(state));
        // 然后将action传递来的value复制到newState的inputValue
        newState.inputValue = action.value;
        // 会将newState返回给store，store会将newState替换掉老的state
        return newState;
    }

    if (action.type === 'add todo item') {
        // 先拷贝之前state里面原有的数据，因为react不推荐直接操作state
        const newState = JSON.parse(JSON.stringify(state));
        newState.list.push(newState.inputValue);
        newState.inputValue = '';
        return newState;
    }

    if (action.type === 'delete todo item') {
        // 先拷贝之前state里面原有的数据，因为react不推荐直接操作state
        const newState = JSON.parse(JSON.stringify(state));
        newState.list.splice(action.index, 1);
        return newState;
    }
    return state;
}
```

##### 第二步：创建store

```react
import { createStore } from 'redux';
// 将reducer引入store
import reducer from "./reducer";

// 根据reducer来创建store
const store = createStore(reducer,
                         window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());

export default store;
```

##### 第三步：将store引入到需要用到的Component组件当中

```react
import React, { Component, Fragment } from "react";
import 'antd/dist/antd.css';
import { Input, List } from 'antd';
// 将store引入到组件
import store from "./store";

class TodoList extends Component {

    constructor(props) {
        super(props);

        // 将数据仓库里的数据赋值给该组件的state，第一次挂载的时候
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        // 让store订阅handleStoreChange方法，只有这个方法发生变动，那么
        // store就会产生相应的变化
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return(
            <Fragment>
                {/* 上下左右有10px的边距 */}
                <div style={{margin: '10px 10px'}}>
                    <Input value={this.state.inputValue}
                           placeholder='todo list'
                           style={{width: '300px', marginRight: '5px'}}
                           onChange={this.handleInputChange}
                    />
                    <button onClick={this.handleBtnClick}>提交</button>

                    {/* 在渲染的时候会有一个index来表示该item的下标 */}
                    {/* 将index传递给handleDelete方法 */}
                    <List style={{width: '300px'}}
                          size="large"
                          bordered
                          dataSource={this.state.list}

                          renderItem={(item, index) => <List.Item onClick={this.handleDelete.bind(this, index)}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }

    handleInputChange(e) {
        const action = {
            // 创建一个action，其中的type是固定的，用于描述该动作
            type: 'change input value',
            value: e.target.value
        }
        // 通过dispatch将action传递给store
        store.dispatch(action);
    }

    // 将store的state替换掉TodoList这个组件的state，这样就可以随时渲染更新
    handleStoreChange() {
        this.setState(store.getState());
    }

    // 当点击按钮的时候，会触发的方法
    handleBtnClick() {
        const action = {
            type: 'add todo item',
        }
        store.dispatch(action);
    }

    // 这个方法接收一个index参数，index是对应item的下标
    handleDelete(index) {
        const action = {
            type: 'delete todo item',
            index
        }
        store.dispatch(action);
    }
}

export default TodoList;
```

##### 

#### UI组件和容器组件

> 是将渲染页面的语句和逻辑语句拆分开

##### 初始组件

```react
import React, { Component, Fragment } from "react";
import 'antd/dist/antd.css';
import { Input, List } from 'antd';
// 将store引入到组件
import store from "./store";

class TodoList extends Component {

    constructor(props) {
        super(props);

        // 将数据仓库里的数据赋值给该组件的state，第一次挂载的时候
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        // 让store订阅handleStoreChange方法，只有这个方法发生变动，那么
        // store就会产生相应的变化
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return(
            <Fragment>
                {/* 上下左右有10px的边距 */}
                <div style={{margin: '10px 10px'}}>
                    <Input value={this.state.inputValue}
                           placeholder='todo list'
                           style={{width: '300px', marginRight: '5px'}}
                           onChange={this.handleInputChange}
                    />
                    <button onClick={this.handleBtnClick}>提交</button>

                    {/* 在渲染的时候会有一个index来表示该item的下标 */}
                    {/* 将index传递给handleDelete方法 */}
                    <List style={{width: '300px'}}
                          size="large"
                          bordered
                          dataSource={this.state.list}

                          renderItem={(item, index) => <List.Item onClick={this.handleDelete.bind(this, index)}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }

    handleInputChange(e) {
        const action = {
            // 创建一个action，其中的type是固定的，用于描述该动作
            type: 'change input value',
            value: e.target.value
        }
        // 通过dispatch将action传递给store
        store.dispatch(action);
    }

    // 将store的state替换掉TodoList这个组件的state，这样就可以随时渲染更新
    handleStoreChange() {
        this.setState(store.getState());
    }

    // 当点击按钮的时候，会触发的方法
    handleBtnClick() {
        const action = {
            type: 'add todo item',
        }
        store.dispatch(action);
    }

    // 这个方法接收一个index参数，index是对应item的下标
    handleDelete(index) {
        const action = {
            type: 'delete todo item',
            index
        }
        store.dispatch(action);
    }
}

export default TodoList;

```



##### 拆分后的UI组件

```react
import React, { Component, Fragment } from "react";
import {Input, List} from "antd";

class TodoListUI extends Component {
    render() {
        return (
            <Fragment>
                <div style={{margin: '10px 10px'}}>
                    <Input
                        value={this.props.inputValue}
                        placeholder="Hello World"
                        style={{width: '300px', marginRight: '5px'}}
                        onChange={this.props.handleInputChange}
                    />
                    <button onClick={this.props.handleBtnClick}>点击</button>
                    <List
                        style={{width: '300px', marginTop: '10px'}}
                        size="small"
                        bordered
                        dataSource={this.props.list}
                        renderItem={(item, index) => <List.Item onClick={() => {this.props.deleteItem(index)}}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }
}

export default TodoListUI;
```



##### 拆分后的容器组件

```react
import React, { Component, Fragment } from "react";
import "antd/dist/antd.css"
import store from "./store";
import TodoListUI from './TodoListUI';

// 将所有的action抽取出来，放到一个叫做actionTypes的文件中
import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM } from "./actionTypes";

class TodoList extends Component {

    constructor(props) {
        super(props);
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.deleteItem = this.deleteItem.bind(this)
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return <TodoListUI
        // 将组件的各种状态传递给子组件        
        inputValue = {this.state.inputValue}
        list = {this.state.list}
        handleInputChange = {this.handleInputChange}
        handleBtnClick = {this.handleBtnClick}
        deleteItem = {this.deleteItem}
        handStoreChange = {this.handleStoreChange}
        />
    }

    handleInputChange(e) {
        const action = {
            type: CHANGE_INPUT_VALUE,
            value: e.target.value
        }
        store.dispatch(action);
    }

    handleBtnClick() {
        const action = {
            type: ADD_TODO_ITEM,
        }
        store.dispatch(action);
    }

    handleStoreChange() {
        this.setState(store.getState());
    }

    deleteItem(index) {
        const action = {
            type: DELETE_TODO_ITEM,
            index
        }
        store.dispatch(action);
    }
}

export default TodoList;
```

### Redux 中间件

#### redux-thunk

> redux-thunk的安装
>
> 它可以将异步操作从组建中移除，然后发到action文件当中去

```bash
npm install redux-thunk
```

> redux-thunk中间件的使用
>
> 它主要是在创建store的时候被引用

```react
// thunk和saga它们都是中间件，如果要使用，首先需要引入applyMiddleware
import {createStore, applyMiddleware, compose} from "redux";
// 然后再引入对应的中间件，这里是thunk
import thunk from "redux-thunk";
import reducer from "./reducer";

// 如果要同时使用redux的devtools和其他的中间件，那么就需要像下面一样来写。
// 因为redux devtools也是一个中间件
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
    //    compose需要从redux中引入
    }) : compose;

const enhancer = composeEnhancers(applyMiddleware(thunk))

const store = createStore(reducer, enhancer)

export default store;
```

> actionCreators 文件

```react
// 这里是返回的一个对象
export const getDeleteItemAction = (index) => ({
    type: DELETE_TODO_ITEM,
    index
})

export const getInitItemAction = (data) => ({
    type: INIT_LIST_ITEM,
    data
});

// 这里是返回的一个函数，运用到了react-thunk。如果没有它，那么久不能返回一个函数
export const getTodoList = () => {
    return (dispatch) => {
        axios.get('https://run.mocky.io/v3/06315b0b-6c7f-49c3-9e51-94e3a35da33b')
            .then((res) => {
                const data =res.data;
                dispatch(getInitItemAction(data));
            })
            .catch(() => {console.log('failed')})
    }
}
```





### react-redux 学习

> 安装react-redux

```bash
进入到工程目录
npm install react-redux
```

#### react-redux 使用范例

##### index.js 

```react
import React from 'react';
import ReactDOM from 'react-dom';
import TodoList from "./TodoList";
import store from "./store";
// react-redux 提供的核心API
import { Provider } from 'react-redux';

const App = (
    // Provider组件，由react-redux提供。
    // Provider的store属性的值，就是整个store数据仓库的值。
    // 这样，只要是在Provider下面的组件，例如TodoList组件
    // 都可以获取到store里面的内容
    <Provider store={store}>
        <TodoList />
    </Provider>
);

ReactDOM.render(
  <React.StrictMode>
    {/* 然后将App组件传给ReactDOM.render进行渲染 */}
      {App}
  </React.StrictMode>,
  document.getElementById('root')
);
```



##### store.js 和 reducer.js 页面不需要作改变

##### TodoList.js 组件

```react
import React, { Component, Fragment } from "react";
// react-redux 提供的核心API
import { connect } from 'react-redux';
import 'antd/dist/antd.css';
import { Input, List } from 'antd';

class TodoList extends Component {

    render() {
        return(
            <Fragment>
                <div style={{margin: '10px 10px'}}>
                    <Input
                        style={{width: '300px'}}
                        placeholder='todo list'
                        value={this.props.inputValue}
                        onChange={this.props.changeInputValue}
                    />
                    <button
                        style={{marginLeft: '5px'}}
                        onClick={this.props.handleBtnClick}
                    >提交</button>

                    <List style={{width: '300px', marginTop: '10px'}}
                          size="large"
                          bordered
                          dataSource={this.props.list}
                          renderItem={(item, index) => <List.Item onClick={this.props.deleteItem.bind(this, index)}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }
}

// 这个函数是用来将store里面的state传递给子组件的props
// 这里是传递给TodoList
const mapStateToProps = (state) => {
    return {
        // 让子组件的inputValue和store里面的inputValue产生关联
        inputValue: state.inputValue,
        // 让子组件的list和store里面的list产生关联
        list: state.list
    }
}

// 将store的 dispatch方法挂载到 props上
// 这个函数是用来，将修改后的子组件state中的数据返回给store
// 让store来更改修改过后的数据
const mapDispatchToProps = (dispatch) => {
    return {
        changeInputValue(e) {
            const action = {
                type: 'change input value',
                value: e.target.value
            }
            dispatch(action);
        },
        handleBtnClick() {
            const action = {
                type: 'add todo item'
            }
            dispatch(action);
        },
        deleteItem(index) {
            const action = {
                type: 'delete todo item',
                index
            }
            dispatch(action);
        }
    }
}

// 这里的意思是，让TodoList组件与store进行连接
export default connect(mapStateToProps, mapDispatchToProps)(TodoList);
```



### react 使用styled-components

> 运用styled-components来对react项目的css文件进行管理

将css放入一个叫style.js的文件中。

```react
import { createGlobalStyle } from 'styled-components';

export const GlobalStyle = createGlobalStyle`
  body{
    marigin: 0;
    padding: 0;
    background: green;
  }
`
```

然后再将其引入到需要使用这个css的组件当中

```react
import React from 'react';
// 引入css
import { GlobalStyle } from "./style";

function App() {
  return (
    <p style={{margin: "10px 10px"}}>
      // 使用css
      <GlobalStyle/>
      Hello World
    </p>
  );
}

export default App;

```

### React 过程中的坑

> 当运用了combineReducers这个组件之后，遇到的问题

整合的reducer文件

```react
import { combineReducers } from "redux";
import reducerHeader from "../header/redux/reducer";

export default combineReducers({
    header: reducerHeader
})
```



对应的组件当中就必须如下写。因为是拆分的，所以要带上其对应的header。以此类推

```react
const mapStateToProps = (state) => {
    return {
        // 将store里面存储的信息传递给子组件，也就是这里的Header组件
        focused: state.header.get('focused'),
        hotList: state.header.get('hotList'),
        totalPage: state.header.get('totalPage'),
        page: state.header.get('page'),
        mouseIn: state.header.get('mouseIn')
    }
}
```

### Component 和 PureComponent

Component：只要项目store里面的数据发生了变化，那么每一个组件就会被重新的渲染。这样就会造成性能的降低。为了避免这样的情况，可以在组件中使用shouldComponentUpdate()这个生命周期函数。通过这个函数来判断，store里面的数据更改是否和当下的组件相关。如果不相关的话，就不重新渲染



PureComponent：react底层帮助实现了上面的功能。但是需要配合immutable.js使用，否则会出现不可预测的问题



### 异步组件/withRouter路由使用

, description=React Study, createTime=2020-07-02, updateTime=2021-02-25, category=Category{id=25, name='React'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0)], isHasContent=true, first=true, last=false, isHasNext=true, isHasPrevious=false))
2021-03-25 18:16:33.745  INFO 36287 --- [http-nio-8080-exec-2] com.banjo.blogvue.aspect.LogAspect       : Request: RequestLog{url='http://localhost:8080/blog', ip='0:0:0:0:0:0:0:1', classMethod='com.banjo.blogvue.controller.admin.AdminPageController.listBlogs', args=[]}
2021-03-25 18:16:33.745  INFO 36287 --- [http-nio-8080-exec-2] com.banjo.blogvue.aspect.LogAspect       : Result: admin/listBlogs
2021-03-25 18:16:34.285  INFO 36287 --- [http-nio-8080-exec-2] com.banjo.blogvue.aspect.LogAspect       : Request: RequestLog{url='http://localhost:8080/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.banjo.blogvue.controller.admin.BlogController.list', args=[0, 4]}
2021-03-25 18:16:34.320  INFO 36287 --- [http-nio-8080-exec-2] com.banjo.blogvue.aspect.LogAspect       : Result: Result(code=0, message=, data=Page4Navigator(pageFromJPA=Page 1 of 2 containing com.banjo.blogvue.pojo.Blog instances, navigatePages=0, navigatePageNums=null, totalPages=2, number=0, totalElements=7, size=4, numberOfElements=4, content=[Blog(id=23, title=AWS Cloud, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Translation, views=11, content=#### 卸载自带jdk

```bash
# 先使用以下命令 查看当前的jdk
rpm -qa|grep jdk
java-1.7.0-openjdk-1.7.0.261-2.6.22.1.83.amzn1.x86_64
copy-jdk-configs-3.3-10.3.amzn1.noarch

# 然后根据对应版本的jdk 直接用下面的命令删除
sudo rpm -e --nodeps java-1.7.0-openjdk-1.7.0.261-2.6.22.1.83.amzn1.x86_64

# 然后使用yum下载jdk，使用下面的命令查看java可选版本
$ yum -y list java*

# 然后根据版本号，直接下载
sudo yum install -y java-1.8.0-openjdk-devel.x86_64
```



#### FileZilla 连接 AWS

1. 打开 FileZilla 的 "Edit" -> "Settings" 对话框，在左边的“选择页面” 选择“SFTP”， 右边点击 “添加密钥文件...” 按钮，导入Amazon给的密钥文件 

   ![image-20200713163800225](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/7gZEBIRuMvdbPli.png)

2. 打开File选择Site Manager

   Protocol中选择SFTP

   Host选择 公有DNS![image-20200713163956246](https://i.loli.net/2020/07/17/9fIEBSrGNMzgoLu.png)

![image-20200713163918562](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/OQzkdvYoGqKLs5B.png)

然后选择Interactive的方式登录，用户是ec2-user

或者选择key的方式都可以

然后就能连接成功

> 连接成功之后需要将一个用于接收上传文件的文件夹进行权限修改

如下：

![image-20200713170334089](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/TNozpkPF8OgeJyM.png)



#### 安装docker

```bash
# 先查看版本 
yum -y list docker*
# 然后根据版本来下载
sudo yum install -y docker.x86_64

# 下载之后需要启动Docker服务
sudo service docker start

# 然后将ec2-user添加到docker组，否则不能执行Docker命令
sudo usermod -a -G docker ec2-user

# 然后重启AWS实例，就可以开启docker服务了
```



#### Docker vim命令

```bash
首先进入容器，然后执行
 apt-get update
 
 然后执行
 apt-get install vim
```

#### AWS 安全组

```bash
# 1. 如果tomcat开启的端口是8080，那么就需要在AWS的安全组里面放行对8080端口的访问，同时还要对9001端口进行开放

docker run -d -p 9001:8080 tomcat

其他的服务如果需要使用其他的端口，那么也用相同的方法进行放行

下面以MySQL的连接为例，3310和3306都需要在安全组里面进行放行。

 mysql          "docker-entrypoint.s…"   17 hours ago        Up 17 hours         33060/tcp, 0.0.0.0:3310->3306/tcp   mysql01
```



![image-20200714180816580](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/ysLFVnza2wGp9E6.png)



#### IDEA 连接 AWS 上的docker

1. 首先修改docker需要监听的IP和端口

```bash
   1. 首先关闭docker服务
   sudo service docker stop
   2. 然后修改docker 服务端监听的端口和ip
   sudo dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375
   3. 然后启动docker服务
   sudo service docker start
   4. 然后修改客户端的
   docker -H tcp://0.0.0.0:2375 ps
   没有输出就表示成功。
   
   
   
   ```

2. 然后再aws里面的安全组里将2375端口进行放行

3. 然后再利用IDEA对docker进行远程连接即可

> 以systemd的方式连接

```bash
1. 先找到这个文件
/lib/systemd/system/docker.service

然后注释掉下面的
ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock $OPTIONS $DOCKER_STORAGE_OPTIONS $DOCKER_ADD_RUNTIMES

然后再添加
ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock
这样远程就能通过2375端口访问到了
```

#### AWS ec2 安装MySQL

```bash
# 先查看是否有旧版本MySQL
rpm -qa | grep -i mysql

# 如果有的话，使用下面的命令将其全部删除
sudo rpm -ev 加mysql的文件名


# 下载并进入到下载好的文件夹
 wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.17-linux-glibc2.12-x86_64.tar.xz
 # 解压下载的压缩包
 tar xvf mysql-8.0.17-linux-glibc2.12-x86_64.tar.xz
 
 # 将解压好的复制到/usr/local目录下并且重命名为mysql
 sudo mv mysql-8.0.17-linux-glibc2.12-x86_64 /usr/local/mysql
 
 # 进入到mysql目录，然后创建一个data文件夹，用于存放数据
 mkdir data
 
 # 创建mysql用户组和mysql用户
 sudo groupadd mysql
 sudo useradd -g mysql mysql
 
 # 改变mysql目录权限 注意后面都有一个点
 sudo chown -R mysql .
 sudo chgrp -R mysql .
 
 # 创建mysql_install_db安装文件，并且修改权限
sudo mkdir mysql_install_db
sudo chmod 777 ./mysql_install_db

# 初始化
sudo bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data
# 一定要记住临时密码
A temporary password is generated for root@localhost: 

# mysql配置，将support-files下的移动到init.d目录下，并且重命名，两个都要
sudo cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld
sudo cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql
# 修改或者创建my.cnf文件，并且加入下面的命令

[mysqld]
    basedir = /usr/local/mysql
    datadir = /usr/local/mysql/data
    socket = /usr/local/mysql/mysql.sock
    character-set-server=utf8
    port = 3306
   sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
 [client]
   socket = /usr/local/mysql/mysql.sock
   default-character-set=utf8
   
# 建立MySQL服务
sudo chmod +x /etc/init.d/mysqld
sudo chmod +x /etc/init.d/mysql
# 添加到系统服务
sudo chkconfig --add mysqld
sudo chkconfig --add mysql
#配置全局环境变量

先设置 /etc/profile文件的权限，可以读写
sudo /etc/profile chmod 777
然后再在里面添加以下配置
export PATH=$PATH:/usr/local/mysql/bin:/usr/local/mysql/lib
export PATH

# 设置环境变量立即生效
source /etc/profile

# 启动MySQL服务

sudo service mysql start

# 登录MySQL
mysql -u root -p 回车
输入上面的临时密码即可

# 修改初始密码
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY'自己的密码';

# 设置远程可登录
进入mysql
1. use mysql
2. update user set host='%' where user='root' limit 1;
3. flush privileges; # 刷新权限

然后就可以进行远程登录
```

, description=Learn how to set up a clear AWS cloud, createTime=2021-02-17, updateTime=2021-02-25, category=Category{id=17, name='AWS Cloud'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=21, title=Docker Notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=14, content=#### Linux 安装 docker

```bash
# 1. 首先用下面的命令卸载旧版本，如果有的话
sudo yum remove docker \ 
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
                  
# 2. 安装依赖包
sudo yum install -y yum-utils        

# 3. 设置镜像仓库
sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo

# 4. 安装docker引擎
sudo yum install docker-ce docker-ce-cli containerd.io

# 5. 启动docker 和重启
sudo systemctl start docker
sudo systemctl restart docker

# 6. 测试是否启动成功
sudo docker run hello-world

# 7. 卸载依赖和删除资源
sudo yum remove docker-ce docker-ce-cli containerd.io
sudo rm -rf /var/lib/docker
```



docker run hello-world的流程图

1. docker会在本地仓库寻找hello-world的镜像，找到就运行。
2. 没找到，docker client就会跟 docker daemon联系，然后下载hello-world镜像到本地
3. 下载到本地之后，再运行该镜像。

 ![image-20200710230333325](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200710230333325.png)![image-20200710230221724](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200710230221724.png)



#### Docker 常用命令

##### 帮助命令

```shell
docker version # 查看docker信息
docker info		 # 查看docker系统信息，包括有多少镜像和容器
docker --help  # 帮助命令
```



##### 镜像命令

> 查看镜像

```bash
docker images  # 查看当前主机上的所有镜像
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              bf756fb1ae65        6 months ago        13.3kB

# docker images 命令的可选性
-a, --all 	# 列出所有的镜像跟默认的docker images一样
-q, --quit	# 只显示镜像的id,-q 和 --quit一样

[root@localhost ~]# docker images --quiet
bf756fb1ae65

[root@localhost ~]# docker images -q
bf756fb1ae65

docker search mysql 搜索mysql的镜像 #镜像的搜索
```

> 搜索镜像

```bash
docker search mysql 搜索mysql的镜像 #镜像的搜索
# 只需要添加想要的镜像的名称，就可以进行搜索。
[root@localhost ~]# docker search mysql
NAME                              DESCRIPTION                                     STARS               
mysql                             MySQL is a widely used, open-source relation…   9718
```

> 下载镜像

```bash
docker pull mysql  # 下载mysql

[root@localhost ~]# docker pull mysql
Using default tag: latest #如果不指定tag，就默认下载最新版本
latest: Pulling from library/mysql
8559a31e96f4: Pull complete	# 分层下载， docker images的核心 联合文件系统
d51ce1c2e575: Pull complete	# 好处：举例--如果要更新到更新版本的MySQL，那么下次执行pull的
c2344adc4858: Pull complete	# 时候只需要下载被更新的部分，其余没更新的不会被重复下载
fcf3ceff18fc: Pull complete
16da0c38dc5b: Pull complete
b905d1797e97: Pull complete
4b50d1c6b05c: Pull complete
c75914a65ca2: Pull complete
1ae8042bdd09: Pull complete
453ac13c00a3: Pull complete
9e680cd72f08: Pull complete
a6b5dc864b6c: Pull complete
Digest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest # 这里是真实的mysql的地址

docker pull mysql 等价于  docker pull docker.io/library/mysql:lastest
```



> 删除镜像

```bash
docker rmi -f 加上(镜像的id) 

[root@localhost ~]# docker rmi -f bf756fb1ae65
Untagged: hello-world:latest
Untagged: hello-world@sha256:d58e752213a51785838f9eed2b7a498ffa1cb3aa7f946dda11af39286c3db9a9
Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b

##或者 docker rmi -f 加上(镜像的repository名称) 
docker rmi -f hello-world

[root@localhost ~]# docker rmi -f hello-world
Untagged: hello-world:latest
Untagged: hello-world@sha256:d58e752213a51785838f9eed2b7a498ffa1cb3aa7f946dda11af39286c3db9a9
Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b

```



##### 容器命令

> 先有镜像，才能创建容器。以下用docker下载centos来进行举例学习

> 新建容器并启动

```bash
# -it 表示使用交互方式运行，进入容器查看内容
[root@localhost ~]# docker run -it centos /bin/bash  
									# docker run -d centos   表示后台启动容器
[root@f72fb12d27fc /]# ls  这里表示已经进入到了centos这个容器当中
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

[root@f72fb12d27fc /]# exit  退出并且停止容器
exit
[root@localhost ~]#

删除所有容器
docker rm $(docker ps -aq)
```

> 查看运行和曾经运行过的容器

```bash
[root@localhost ~]# docker ps -a 表示查看当前在运行的和曾经运行过的容器
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
f72fb12d27fc        centos              "/bin/bash"         3 minutes ago       Exited (0) 2 minutes ago                       hopeful_mcnulty
3af87bce0732        bf756fb1ae65        "/hello"            12 hours ago        Exited (0) 12 hours ago                        lucid_sammet
b22be932b11a        bf756fb1ae65        "/hello"            12 hours ago        Exited (0) 12 hours ago                        vigorous_chaplygin
[root@localhost ~]# docker ps  表示查看正在运行的容器
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
[root@localhost ~]#

```

> 启动，停止，重启容器

```shell
docker start 容器id
docker restart 容器id
docker stop 容器id
docker kill 容器id #强制停止当前容器
```

> 退出容器

```bash
exit 表示退出且停止容器运行

Ctrl + P + Q #不停止容器运行，只退出容器

[root@f4b87ffb286b /]# [root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
f4b87ffb286b        centos              "/bin/bash"         13 seconds ago      Up 11 seconds                           laughing_darwin
[root@localhost ~]#

```



> 进入在运行的指定容器

```shell
docker exec -it 容器名 /bin/bash

[root@localhost ~]# docker exec -it 0f45f1d47525 /bin/bash
[root@0f45f1d47525 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

docker attach 容器名

[root@localhost ~]# docker attach 0f45f1d47525
[root@0f45f1d47525 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

###区别
docker exec			# 进入容器后开启一个新的终端，可以在里面操作(这个是常用的)。
docker attach		# 进入容器正在执行的终端，不会启动新的进程。

```



> 删除容器

```bash
docker rm 容器id
```

> 列出所有容器

```bash
docker container ls
```



> 日志打印

```bash
docker logs --tail 10 0f45f1d47525  
--tail 表示以字符串的形式打印，10是--tail的参数，打印10行。最后跟的是容器的id
```

> 查看容器进程信息

```bash
docker top 容器id
[root@localhost ~]# docker top 0f45f1d47525
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                13539               13521               0                   18:08               pts/0               00:00:00            /bin/bash
```

> 查看容器元数据(所有数据)

```bash
[root@localhost ~]# docker inspect 0f45f1d47525（容器id）
```



> 从容器中复制文件到主机

```bash
[root@6ad773845eab /]# cd home  开启容器 进入到home目录
[root@6ad773845eab home]# touch test.java	在home目录创建test.java文件
[root@6ad773845eab home]# ls
test.java
[root@6ad773845eab home]# exit 退出即可
exit
[root@localhost ~]# ls 当前文件夹下是没有test.java文件
anaconda-ks.cfg  Desktop  Documents  Downloads  Music  original-ks.cfg  Pictures  Public  study.txt  Templates  Videos  

# 将6ad773845eab:/home/test.java  将这个容器的home目录中的test.java文件复制到
# ~目录。
[root@localhost ~]# docker cp 6ad773845eab:/home/test.java ~
[root@localhost ~]# ls
anaconda-ks.cfg  Desktop  Documents  Downloads  Music  original-ks.cfg  Pictures  Public  study.txt  Templates  test.java  Videos
[root@localhost ~]#
```



#### Docker Nginx

##### 启动并验证Nginx

```bash
-d 表示后台运行
--name nginx01表示它的名字
-p 8082:80 #8082表示客户端访问的请求的端口，80表示本地与之对应的端口。
就是客户端访问8082端口会拿到本地80端口的数据

[root@localhost ~]# docker run -d --name nginx01 -p 8082:80 nginx
f0a1f169564a7c8faacb1aa73cae06449267e5b39493a05196086823b69f8972
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
f0a1f169564a        nginx               "/docker-entrypoint.…"   4 seconds ago       Up 3 seconds        0.0.0.0:8082->80/tcp   nginx01
6ad773845eab        centos              "/bin/bash"              56 minutes ago      Up 51 minutes                              elastic_mestorf
[root@localhost ~]# curl localhost:8082  验证是否能够访问成功
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
Nginx在docker里面的配置文件在 /etc/nginx路径下面
```



#### Docker Tomcat

```bash
# tomcat 的启动跟Nginx相似
也是要设置端口的映射。才能进行访问
[root@localhost ~]# docker run -d -p 9001:8080 tomcat
4126cf694a054e44dfa27a059da130ff8201d427b0e1aeeafb57a986f8fa8667
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
4126cf694a05        tomcat              "catalina.sh run"        4 seconds ago       Up 3 seconds        0.0.0.0:9001->8080/tcp   loving_bell
f0a1f169564a        nginx               "/docker-entrypoint.…"   27 minutes ago      Up 27 minutes       0.0.0.0:8082->80/tcp     nginx01
6ad773845eab        centos              "/bin/bash"              About an hour ago   Up About an hour                             elastic_mestorf

## 返回404 表示能够访问，但是当前的Tomcat里面还缺少可用于访问的文件
[root@localhost ~]# curl localhost:9001
<!doctype html><html lang="en"><head><title>HTTP Status 404 – Not Found</title><style type="text/css">body {font-family:Tahoma,Arial,sans-serif;} h1, h2, h3, b {color:white;background-color:#525D76;} h1 {font-size:22px;} h2 {font-size:16px;} h3 {font-size:14px;} p {font-size:12px;} a {color:black;} .line {height:1px;background-color:#525D76;border:none;}</style></head><body><h1>HTTP Status 404 – Not Found</h1><hr class="line" /><p><b>Type</b> Status Report</p><p><b>Description</b> The origin server did not find a current representation for the target resource or is [root@lo[root@localhost ~]#

# 解决办法

[root@localhost ~]# docker exec -it 4126cf694a05 /bin/bash 先重新进入Tomcat运行的容器
root@4126cf694a05:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work

## 将webapps.dist 文件夹的内容全部复制的 webapps即可

root@4126cf694a05:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work
root@4126cf694a05:/usr/local/tomcat# cd webapps.dist
root@4126cf694a05:/usr/local/tomcat/webapps.dist# ls
ROOT  docs  examples  host-manager  manager
root@4126cf694a05:/usr/local/tomcat/webapps.dist# cd examples
root@4126cf694a05:/usr/local/tomcat/webapps.dist/examples# ls
WEB-INF  index.html  jsp  servlets  websocket
root@4126cf694a05:/usr/local/tomcat/webapps.dist/examples# cd ..
root@4126cf694a05:/usr/local/tomcat/webapps.dist# cd ..
root@4126cf694a05:/usr/local/tomcat# cp -r webapps.dist/* webapps
root@4126cf694a05:/usr/local/tomcat#

#然后就能成功访问到index页面
```





#### Docker ElasticSearch

```bash
# 先下载ElasticSearch
# docker pull docker.elastic.co/elasticsearch/elasticsearch:7.8.0

# 官方推荐的开启单节点集群
# docker run -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" docker.elastic.co/elasticsearch/elasticsearch:7.8.0
但是上面的方式会暴露一个问题，那就是ES占内存非常大，而我们的虚拟机内存很小。所以不建议这样开启

# 其中 -e ES_JAVA_OPTS="-Xms64m -Xmx512m" 表示最小占用64M内存 最大占用512M
# docker run -d -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.8.0

然后去访问 即可验证
[root@localhost ~]# curl localhost:9200
{
  "name" : "88e49838ff71",
  "cluster_name" : "docker-cluster",
  "cluster_uuid" : "T6BQKfqySz63NlT_Tp9NYQ",
  "version" : {
    "number" : "7.8.0",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "757314695644ea9a1dc2fecd26d1a43856725e65",
    "build_date" : "2020-06-14T19:35:50.234439Z",
    "build_snapshot" : false,
    "lucene_version" : "8.5.1",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}
```



#### Docker 提交镜像

==提交了之后，只是在本地存在。还需要push到网络上，才能实现下载使用的功能==

```bash
举例：下载的Tomcat镜像中，webapps文件夹是没有东西的，所以我们在webapps文件夹下面创建一些文件。然后通过下面的命令将修改后的镜像commit
-m 用于添加描述信息，跟Git类似。-a 是作者名字。加上需要修改的容器id，然后 tomcat01是repository名

[root@localhost ~]# docker commit -m="docker with changes in webapps" -a="banjo" 6c9c1265f18e tomcat01
sha256:b1c6475b6b76c51fa3cb08edcb82ec37725c93643eca9274e12301e44594f781
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
6c9c1265f18e        tomcat              "catalina.sh run"   3 minutes ago       Up 3 minutes        0.0.0.0:9001->8080/tcp   recursing_thompson
[root@localhost ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
tomcat01            latest              b1c6475b6b76        9 seconds ago       652MB
nginx               latest              0901fa9da894        11 hours ago        132MB
tomcat              latest              6055d4d564e1        4 days ago          647MB
centos              latest              831691599b88        3 weeks ago         215MB
elasticsearch       7.8.0               121454ddad72        3 weeks ago         810MB
mysql               latest              be0dbf01a0f3        4 weeks ago         541MB
```

![image-20200711174623196](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711192711325.png)



#### Docker 容器数据卷

容器数据卷可以帮助容器的持久化和同步操作，容器间的数据也可以共享

就是容器中的一个路径映射到本地主机上的一个路径，只要容器中的这个路径里面进行了操作，比如添加文件，删除文件，修改文件，那么在主机上的映射的这个目录也会有相同的操作。

==我的理解：以后可以在本地的/home 目录下面创建，centos，Tomcat，ES，redis，Nginx这些目录，然后将这些目录分别的映射到对应的容器中去，就可以保证容器中的重要数据不会丢失==

> 直接使用命令的方式进行挂载

```bash
举例: -v 是用来挂载的 : 有的时候在容器路径下 ### eg. /home:ro 或者 /home:rw 这表示read only或者read & write 表示在容器中这个路径下的文件是只读或者读写均可

将本地主机/home/centos 路径 与 容器centos的 /home路径进行绑定
[root@localhost ~]# docker run -it -v /home/centos:/home centos /bin/bash

然后使用 docker inspect 容器id就可以查看到以下信息，如果没有出现，则代表没有挂载成功。

测试方法，在容器的/home路径下面创建文件，然后再在本地主机的/home/centos下查看是否有相同的文件

同样的去本地主机创建文件，然后去容器中去查看也可以验证
```

![image-20200711192711325](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711174623196.png)



##### 匿名挂载

```bash
# 1. 匿名挂载
-d	后台运行
-P	大写的P表示随机的端口
这里没有指定本机的路径，所以就是匿名挂载
[root@localhost /]# docker run -d -P --name nginx01 -v /etc/nginx nginx
326008beb69c229e1a424d6127aba2dd409989092108b90a60aaff11fa3abb93

[root@localhost /]# docker volume ls 通过这个命令可以拿到匿名挂载的名称
DRIVER              VOLUME NAME
local               626a093ff31bcf34ef1741f5eab3e3077a7bf445a1280fd2f2cb3fd6f448a004
local               6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70

[root@localhost /]# docker volume inspect 6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70 然后通过这个命令查看当前的匿名挂载是映射到本机的什么位置，可以看到是在/var/lib/docker/volumes下面
[
    {
        "CreatedAt": "2020-07-11T05:50:36-07:00",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70/_data",
        "Name": "6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70",
        "Options": null,
        "Scope": "local"
    }
]

```

![image-20200711225525788](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712112330604.png)

##### 具名挂载

```bash
# 2. 具名挂载
test-nginx 就是这个挂载的名字
[root@localhost /]# docker run -d -P --name nginx02 -v test-nginx:/etc/nginx nginx
```

![image-20200711225848468](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711225848468.png)



##### Dockerfile方式挂载

```bash
# 先在主机的一个路径里面生成一个叫做dockerfile的文件
[root@localhost ~]# mkdir /home/docker-test-volume 创建这个目录
[root@localhost ~]# cd /home/docker-test-volume 进入这个目录
[root@localhost docker-test-volume]# ls
[root@localhost docker-test-volume]# vim dockerfile1  创建dockerfile1 文件并写下下面的内容
[root@localhost docker-test-volume]# cat dockerfile1
FROM centos ##以镜像centos为基础

VOLUME ["volume01", "volume02"]  ## 挂载两个卷

CMD echo "-----success------"   ## 成功后的输出
CMD /bin/bash		## 然后会进入该路径

# build 用于创建dockerfile
# -f 		哪一个file文件
# -t		生成的对象
# .			生成在当前目录下

[root@localhost docker-test-volume]# docker build -f /home/docker-test-volume/dockerfile1 -t test/centos .

Sending build context to Docker daemon  2.048kB
Step 1/4 : FROM centos
 ---> 831691599b88
Step 2/4 : VOLUME ["volume01", "volume02"]
 ---> Running in 0c80409788d3
Removing intermediate container 0c80409788d3
 ---> 4e7fe085c688
Step 3/4 : CMD echo "-----success------"
 ---> Running in 3a6eebcf35a9
Removing intermediate container 3a6eebcf35a9
 ---> ec43d897d893
Step 4/4 : CMD /bin/bash
 ---> Running in 7f1029e69632
Removing intermediate container 7f1029e69632
 ---> efd4071b1ad0
Successfully built efd4071b1ad0
Successfully tagged test/centos:latest
## 镜像生成成功
test/centos         latest              efd4071b1ad0        2 minutes ago       215MB
```

当我们利用这个镜像创建容器的时候，就可以看到挂载的卷。

![image-20200712112330604](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712112754635.png)

![image-20200712112754635](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712174322428.png)



##### 数据卷容器

> **--volumes-from** 顾名思义，就是从另一个容器当中挂载容器中已经创建好的数据卷。

以上面的为例，先创建centos01 里面有已经创建好的volume01和volume02的数据卷

然后创建centos02 从centos01中挂载已经创建好的这两个数据卷。

挂载好之后，无论在哪一个容器中修改数据卷中的内容，两个容器都会同步。即使将centos01容器删除，centos02容器中数据卷中的数据也不会丢失

```bash
# 使用以下命令进行挂载
# 而且可以有多个容器对centos01进行挂载，比如centos03
--volumes-from 表示centos02 从 centos01中挂载已经创建好的volume01和volume02数据卷

# docker run -it --name centos02 --volumes-from centos01 test/centos

```





#### Docker MySQL 

```shell
# 需要在Linux中将MySQL的端口在防火墙中开放。
firewall-cmd --add-port=3306/tcp --permanent
firewall-cmd --add-port=3310/tcp --permanent

-d	后台运行
-p	端口映射
-v	卷挂载，可以多个
--name	容器的名字
-e	环境配置
# MYSQL_ROOT_PASSWORD 初始化root的密码
docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123123 --name mysql01 mysql

# 1 先开启MySQL容器
# docker run -it tomcat /bin/bash  
# 然后在MySQL里面 执行以下操作
root@3eeba4e8cfee:/# mysql -u root -p 
查看 root的加密方式
mysql> select host,user,plugin,authentication_string from mysql.user;
+-----------+------------------+-----------------------+
| host      | user             | plugin                | 
+-----------+------------------+-----------------------+
| %         | root             | caching_sha2_password | 
| localhost | mysql.infoschema | caching_sha2_password | 
| localhost | mysql.session    | caching_sha2_password |
| localhost | mysql.sys        | caching_sha2_password |
| localhost | root             | caching_sha2_password | 
如果root的plugin显示是caching_sha2_password 那么就需要作如下的更改，'123123是代表MySQL的密码'
mysql> ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123123';
mysql> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123123';
然后远程就可以连接到本地的MySQL服务了
```

![image-20200711222503711](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/j7mgN8FfSoMXzqI.png)

3310是与MySQL端口号3306对应的

##### 多个MySQL实现数据共享

```bash
# 1. 先创建mysql01，然后将mysql01里面的conf.d和mysql设置成容器数据卷。

docker run -it -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123123 --name mysql01 

# 2. 然后创建mysql02，使用--volumes-from挂载到mysql01的容器数据卷，这样两个mysql之间就可以进行数据共享了
docker run -it -p 3311:3306 -e MYSQL_ROOT_PASSWORD=123123 --name mysql02 --volumes-from mysql01 mysql
```



#### DockerFile

> 以构建tomcat镜像为例

```bash
FROM centos # 以centos为基础

MAINTAINER banjo<mr.singledog@gmail.com> # 表明作者是谁

ADD jdk-8u251-linux-x64.tar.gz /usr/local 
ADD apache-tomcat-9.0.37.tar.gz /usr/local

RUN yum -y install vim # 镜像构建的时候需要运行的命令
RUN yum -y install net-tools

ENV MYPATH /usr/local # 构建镜像的时候设置环境变量

### VOLUME 表示挂载的目录

WORKDIR $MYPATH # 镜像的工作目录

ENV JAVA_HOME /usr/local/jdk1.8.0_251
ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.37
ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.37
ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin

EXPOSE 8080 # 需要开放的端口

CMD /usr/local/apache-tomcat-9.0.37/bin/startup.sh  # 指定容器启动的时候需要运行的命令

ENTRYPOINT #也是指定运行的命令
```

首先这些文件要在同一目录下，并且这个目录最好只有这些文件![image-20200712174104663](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712174104663.png)



然后进行构建，因为Dockerfile名是官方指定的，所以会直接找到

![image-20200712174153322](https://i.loli.net/2020/07/17/NRQxWZsT2e7Ir96.png)



现在就可以看到diytomcat镜像了![image-20200712174322428](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712221352651.png)



#### Docker 打包部署SpringBoot项目

> 在羡慕里的Maven，将项目打包

![image-20200712170007269](https://i.loli.net/2020/07/17/1FUXAt8pMcqGgvo.png)

> 如果打包成功，会在下图位置找到打包好了的jar包

![image-20200712170127230](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712170127230.png)

> 注意，MySQL的配置需要使用docker里面的MySQL配置。

![image-20200712221352651](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712221446247.png)



> 同时还需要一个Dockerfile文件，如下配置

![image-20200712221446247](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200713113733838.png)



然后将他们传输到远程服务器，并且使用docker进行build

```bash
-t 目标对象 叫blog
. 表示在当前目录
docker build -t blog .
```



#### IDEA 集成Docker

```bash
# 首先更改docker的service文件，开放端口。其中2375可以是其他的没被占用的端口

# vim /lib/systemd/system/docker.service
```

![image-20200713113733838](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711225525788.png)

```bash
# 重启docker服务
systemctl daemon-reload

# 然后重新加载配置文件 
systemctl restart docker.service

# 接着在Linux防火墙中开放2375端口
firewall-cmd --add-port=2375/tcp --permanent
firewall-cmd --reload

# 然后使用netstat -nlpt 查看2375是否开放
# 用下面的进行验证
curl http://localhost:2375/info
可以打印出来数据，表示成功
```

然后就可以在IDEA中进行连接

其中的URL是远程服务器的地址，端口是docker的端口

![image-20200713114258061](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200713114258061.png)



然后在service里面点击，就可以看到当前docker里面的容器和镜像

![image-20200713120710743](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200713120710743.png)

, description=The notes of docker , createTime=2020-08-05, updateTime=2021-02-25, category=Category{id=7, name='Docker'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=19, title=Linux Notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=23, content=#### 1. Mac连接虚拟机Linux

##### a. Mac terminal 下操作

在Linux的终端中输入ifconfig来查看ip，然后再在Mac的终端中如下操作

![image-20200708112812503](https://i.loli.net/2020/07/17/V7vLXODN2ipJ6bx.png)



会要求输入Linux的密码



##### b. 从Mac传输文件到Linux

使用FileZilla，通过连接。然后直接将Mac上的文件拖放到虚拟机的Linux上面即可![image-20200708114129842](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200708114129842.png)



==Linux一般没有输出就代表操作成功==



#### Linux 基本命令：

```bash
#可以使用 man + 命令  来查看相关的选项和参数

sync # 将数据由内存同步到硬盘中

shutdown # 关机指令

### 注意在关机前，先执行sync命令将数据保存到硬盘中

reboot # 重启

shutdown -r now # 系统立马重启

######文件操作命令########

ls：列出目录
ls -a：列出全部的文件
ls -l：列出文件，并且显示文件的属性和操作权限 
ls -al: Linux的命令可以合并使用，就是上面的功能的合并

cd + 路径：切换到指定路径
cd ..：切换到上一级
cd /：回到根目录

pwd：显示当前目录

mkdir + 目录名称：创建一个新的目录 
mkdir + 参数(-m 或 -p)：
# -m: 配置文件的权限！直接配置，不需要看默认权限
# -p: 帮助你直接将所需要的目录(包含上一级目录)递归创建起来！

#例子 -p
# mkdir test1/test2/ 如果没有test1的话，那么就会显示No such file or directory  
# 所以需要加上 mkdir -p test1/test2 这样的话，如果没有test1 那么就会创建test1，接着再创建test2.

#例子 -m
# mkdir -m 711 test2 为test2 创建权限

rmdir + 目录名称：删除指定的目录

cp：复制文件或者是目录
# 用法：cp source to destination
# 例子：cp test.txt  /home 将test.txt 文件复制到home路径

rm：删除文件或者目录 ##一定要谨慎使用
# 选项与参数：
# -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；
# -i ：互动模式，在删除前会询问使用者是否动作
# -r ：递归删除！最常用在目录的删除了！这是非常危险的选项！！！


mv：移动文件或者目录
#用法与cp复制文件类似
```

#### Linux 重要的文件目录

```bash
/bin：这个目录是存放着最常用的命令

/boot：存放的是启动Linux时使用的核心文件 ###不要动

/etc：用来存放所有的系统管理需要的配置文件和子目录

/home：用户的主目录

/lib：## 不要动

/lost+found：## 一般存在于云服务器

/opt： 给服务器安装额外的软件的目录，比如说安装的数据库就可以放在这个目录

/root：根目录

/sbin：存放着系统管理员使用的系统管理程序 ##不要动

/usr：##非常重要 用户的很多应用程序和文件都放在该目录下
 
```

#### Linux 文件的属性和权限

![image-20200708142059786](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/3JoYV8kn4pdgWOB.png)

>##### 通过==10个字符==来表示文件的种类和文件的权限

第一个字符：

- 当为[ **d** ]则是目录
- 当为[ **-** ]则是文件；
- 若是[ **l** ]则表示为链接文档 ( link file )；
- 若是[ **b** ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；
- 若是[ **c** ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。

后面9个字符，是每三个为一组，分别表示如下图

其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。

![image-20200708142437235](https://i.loli.net/2020/07/17/XozlwuD6ZILpKfC.png)



如果用=="-"==字符表示没有该权限；比如上图的第三格，表示有读和执行的权限，没有写的权限

#### 修改文件权限

> Linux文件属性有两种设置方法，一种是数字，一种是符号。

每种权限对应一个分数，如下

==read: 4  write: 2 execute:1==  缩写 ==r: 4 w:2 x:1==

> Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。

用对test.txt的权限操作举例：

- owner = rwx = 4+2+1 = 7
- group = rwx = 4+2+1 = 7
- others= --- = 0+0+0 = 0

chmod 770 test.txt 表示除了others组的用户，其余的都可以对该文件进行 读，写和执行的操作

#### 查看文件内容

>Linux 系统中使用以下命令来查看文件的内容

- cat 由第一行开始显示文件内容
- tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！
- nl  显示的时候，顺道输出行号！
- more 一页一页的显示文件内容
- less 与 more 类似，但是比 more 更好的是，他可以往前翻页！
- head 只看头几行
- tail 只看尾巴几行

####  vim基本操作

```bash
vim readme.txt // 第一次使用会创建这个readme.txt文件。第二次输入该命令，则是用于修改该文件

进入文件之后，按键盘 i 可以进行文字的输入。输入完毕之后 按键盘 ESC键进行退出 然后按键盘 : 就可以进入底部命令行模式。并且输入 wq就是保存并退出。

在输入模式下，按键盘 x 表示删除光标位置的字符

以上就是基本操作
```



, description=The basic knowledge of Linux, createTime=2020-07-10, updateTime=2021-02-25, category=Category{id=23, name='Linux'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=18, title=React notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=11, content=### React 基础学习

#### React的安装

1. Mac系统先安装node，直接官网下载安装。成功之后在命令行输入 node -v 或者 npm -v 出现版本号表示安装成功

2. 使用命令：npm install -g create-react-app 安装


出现上图问题，直接给该文件夹的permission进行放行即可: sudo chmod 777 /usr/local/lib/node_modules

```bash
需要进入到项目的文件夹
npm start 是用于开发环境
npm run start 也是用于开发环境
npm run build 是用于生成环境
```

#### 创建项目

create-react-app todolist. 通过这个 命令会在当前文件夹下面创建一个叫做todolist的React项目

> 项目名称不能包含大写字母，否则会报如下的错误

![image-20201012204028354](/Users/laughingli/Library/Application Support/typora-user-images/image-20201012204028354.png)

#### 工程目录介绍

<img src="/Users/laughingli/Library/Application Support/typora-user-images/image-20201012210605456.png" alt="image-20201012210605456" style="zoom:50%;" />

1. README.md：工程的说明文件，添加关于项目的一些说明
2. package.json：项目的介绍
3. .gitignore：将该文件中指定的文件或者目录不push到git 仓库
4. node_modules：是自动下载的第三方依赖
5. public目录里面的index.html：项目首页的模板
6. public目录里面的favicon.ico：项目的图标

src目录：是项目源代码存放的目录

1. index.js：是项目代码的入口文件。

   ```react
   import React from 'react';   // 文件中使用JSX语法，就必须需引入React
   import ReactDOM from 'react-dom';
   import App from './App';
   
   ReactDOM.render(
     <React.StrictMode>
       <App /> // 将App组件挂载到id为root的dom节点下
     </React.StrictMode>,
     document.getElementById('root')
   );
   
   
   ```

   

#### React中的组件

一个组件会有如下的特征：会extends Component

```react
import React, { Component } from 'react';

class App extends Component {
  render() {  // 一个组件就是页面的一部分内容，由render()这个方法进行渲染
    return( // return就是渲染的内容
      <div>
          hello World
      </div>
    )
  }
}
export default App;
```



#### JSX语法

```jsx
	class TodoList extends Component {
    render () {
        return (
          // 这种情况下，会报错。必须要有一个parent tag
            <div>
                <input /><button>点击</button>
            </div>
            <ul>
                <li>学音乐</li>
                <li>halo</li>
            </ul>
					// 要像下面一样，包裹一个parent tag才行
          <Fragment> // Fragment 需要单独引入，跟Component一样
          	<div>
                <input /><button>点击</button>
            </div>
            <ul>
                <li>学音乐</li>
                <li>halo</li>
            </ul>
          </Fragment>
        )
    }
}


```



#### React使用范例

> 父组件，与下面的子组件相结合理解

```react
import React, { Component, Fragment } from 'react';
import './style.css';
import TodoItem from './TodoItem';

class TodoList extends Component {

    // 构造函数：props是固定的
    constructor(props) {
        super(props); // 调用父类Component的构造函数
        this.state = { // this.state表示组件的状态，它可以用来存储各种数据
            inputValue: '', // inputValue用于接收输入信息
            list: []        // list用于存储输入信息
        }
        // 通过下面的方法，让各种方法指向TodoList
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleItemDelete = this.handleItemDelete.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
    }

    render() {
        return (
            <Fragment>
                <div>
                    {/* 将input与组件的inputValue进行绑定
                    这个input的值，由inputValue决定 */}
                    {/* onChange，当输入框发生变化的时候，
                    调用handleInputChange方法 */}
                    {/* bind(this),改变方法的this指向
                    让其指向组件 */}
                    <input
                        className='input'
                        value={this.state.inputValue}
                        onChange={this.handleInputChange}
                    />
                    {/* 用于当点击发生的时候，来调用对应的方法 */}
                    <button onClick={this.handleBtnClick}>点击</button>
                </div>
                <ul>
                    {
                        this.getTodoItem()
                    }
                </ul>
            </Fragment>

        )
    }

    // 用于显示TodoItem组件的处理结果
    getTodoItem() {
        // Each child in a list should have a unique "key" prop.
        // 需要return，处理之后的结果才能被调用显示
        return this.state.list.map((item, index) => {
            // 最好不要用index作为key值
            // 当点击对应的数据的时候，将其删除handleItemDelete
            // index 用于传递给delete方法对相应的index的数据进行处理
            return (
                <TodoItem
                    // 将input的值通过content传递给了子组件 TodoItem
                    // 将index的值通过index传递给了子组件 TodoItem
                    // 将handleItemDelete方法绑定到了子组件的deleteItem上，
                    // 这样当子组件调用deleteItem的时候，就是在调用父组件的handleItemDelete
                    key={index}
                    content={item}
                    index={index}
                    deleteItem={this.handleItemDelete}
                />
            )
        })
    }

    handleInputChange(e) {
        // 用this.setState的方式来修改里面的值
        this.setState({
            inputValue: e.target.value
        })
    }

    handleBtnClick(e) {
        this.setState({
            // ...this.state.list用于获取，本来该list中含有的数据
            list: [...this.state.list, this.state.inputValue],
            // 下面用于添加完成后，将input输入框清空
            inputValue: ''
        })
    }

    handleItemDelete(index) {
        //先复制一份list原来的值，因为不能对state的内容直接进行操作
        const list = [...this.state.list];
        // 删除下标是index的内容，删除1个
        list.splice(index, 1);
        this.setState({
            list: list
        })
    }


}

export default TodoList;
```

#### 如何引用CSS文件

```jsx
import './style.css'; // 首先在头部引用CSS文件

<input 
    className='input'  // 然后再在需要使用的地方引用具体的css，记住是className而不是class
    value={this.state.inputValue} 
    onChange={this.handleInputChange.bind(this)}
/>
```



#### 如何引入本地图片

```react
import lunbo from '../../../statics/lunbo.jpeg';

<img src={lunbo} alt=''/>
```



#### 组件之间的传值

> 子组件，与上面的父组件相结合来理解

```react
import React, { Component } from 'react';

class TodoItem extends Component {

    constructor(props) {
        super(props);
        // 让这个函数指向TodoItem
        this.handleClick = this.handleClick.bind(this);
    }

    render () {
        return (
            
        <div onClick={this.handleClick}>
            {/* 当点击子组件的每一项的时候，就会调用handleClick方法 */}
            {this.props.content}
        </div>
        )
    }

    handleClick() {
        // 调用deleteItem实际上是调用父组件的handleItemDelete方法
        // this.props.index，是指的对应要删除的每一项的下标
        this.props.deleteItem(this.props.index)
    }
}

export default TodoItem;
```



#### PropTypes和DefaultProps的应用

```react
// 为了做类型校验，需要引入PropTypes
import PropTypes from 'prop-types';

// 对TodoItem组件里的属性进行校验
TodoItem.propTypes = {
    // content的内容必须是string类型
    // 后面加上isRequired就表示必须要有输入值，否则会报错
    content: PropTypes.string.isRequired,

    // deleteItem传入的内容必须是一个函数
    deleteItem: PropTypes.func,

    // index传入的内容必须是number或者是string类型
    index: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
}
export default TodoItem;
```



#### Props，State与render函数

> 当组件的state或者是props发生改变的时候，render函数就会重新执行
>
> 当父组件的render函数被运行时，子组件的render函数也会重新执行



#### 生命周期函数

> 生命周期函数：指在某一个时刻组件会自动执行的函数
>
> 举例：React的render函数，当组件的state或者props发生改变的时候，render函数就会自动执行。这就是生命周期函数

```react
componentWillMount() { 
   //已经弃用。它的意思是在组件第一次挂载之前执行。 也就是组件第一次被渲染到页面的时候
        console.log('will mount')
    }

componentDidMount() { // 在组件第一次挂载之后会执行
        console.log('did mount')
    }

// 在组件的内容更新之前会自动被执行，会返回true或者false
// 无论返回true或者false，shouldComponentUpdate都会被执行
// 但是，如果是true则表示执行更新，如果是false则表示不执行更新。
shouldComponentUpdate() {
        console.log('should ?')
        return true
    }

// 在shouldComponentUpdate()返回了true之后才会被执行，它是在组件完成更新之前被执行
// Warning: componentWillUpdate has been renamed, and is not recommended for use. 弃用
componentWillUpdate() {
        console.log('componentWillUpdate')
    }

// 也是在shouldComponentUpdate()返回了true之后才会被执行。它是在组件完成更新之后被执行
componentDidUpdate() {
        console.log('componentDidUpdate')
    }

// Warning: componentWillReceiveProps has been renamed, 
// and is not recommended for use. 弃用
componentWillReceiveProps() {
        console.log('componentWillReceiveProps')
    }
```

####  生命周期函数使用场景

```react
// 举例，父组件中引用了子组件。如果父组件的render函数被执行了，那么子组件的render函数也会被执行。
// 这在有的时候就会带来性能上的损失，因为子组件不需要随时都被执行

// 在子组件的render函数之前添加该生命周期函数
shouldComponentUpdate(nextProps, nextState, nextContext) {
  			// 如果接下来的content内容不等于当前content的内容，那么子组件的render函数才会被执行
        return nextProps.content !== this.props.content;
    }
```

#### React使用ajax

```react
// 首先要安装对应的包，从命令行进入到工程项目 然后安装
npm install axios 
// 安装完成后
// 在需要使用到ajax的地方引入即可，下面是举例使用
import axios from "axios";

// ajax的使用，就是在componentDidMount这个生命周期函数之中：因为它只会执行一次
componentDidMount() {
        axios.get('/api/todolist')
            .then(() => {alert('success')})
            .catch(() => {alert('failed')})
    }

```



#### React Router

> router安装

```bash
npm install react-router-dom 进行安装
```



> router的使用

```react
import React, { Component } from 'react';
import Header from './common/header/header.js';
import { Provider } from 'react-redux';
import store from "./common/header/redux/store";

// 先将需要的页面编辑好，然后引入
import Home from './home/index';
import Detail from './Detail/index';
// 引入路由'BrowserRouter'和路由规则'Route'
import { BrowserRouter, Route } from 'react-router-dom';

function App() {
  return (
      <Provider store={store}>
          {/* BrowserRouter标签代表路由 */}
          <BrowserRouter>
              {/* Route代表路由规则，exact 表示路由必须完全相同才能够渲染
               路由完全相同的意思：http://localhost:3000/detail，因为这个URL里面也包含
               根目录，如果不加exact，那么下面的两个路由规则都会显示。加上exact的话，就只显示
               detail的
               */}
            	{/* 直接使用Component={} 来将其添加到路由 */}
              <Route path='/' exact Component={ Home }></Route>
              <Route path='/detail' Component={ Detail }></Route>
          </BrowserRouter>
          <Header />
      </Provider>
  );
}

export default App;
```



#### 安装Immutable.JS 

```bash
npm install immutable
```



### Redux 学习

#### Redux的工作流程

> 类比图书馆借书的过程

<img src="/Users/laughingli/Library/Application Support/typora-user-images/image-20201017094121868.png" alt="image-20201017094121868" style="zoom: 25%;" />

1. React Components 代表一个借书的用户
2. Action Creators 代表一个用户具体要借什么书这一个指令
3. Store 代表图书管的管理员。数据管理的仓库
4. Reducers 代表整个图书馆的数据库，记录了每一本书的基本信息和存放位置



#### Chrome 安装 Redux DevTools

1. 首先在Chrome的extensions商店搜索 Redux DevTools

2. ```react
   // 然后再在react的store文件里面添加如下一行代码
   // window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
   const store = createStore(reducer,
       window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
   ```

3. 然后就可以在Chrome里面点击Redux DevTools进行调试

####  安装Ant Design

```bash
// 首先在命令行中进入工程目录，然后执行下面的语句
npm install antd --save
```

#### 安装Redux

```bash
// 首先在命令行中进入工程目录，然后执行下面的语句
npm install redux
```

#### redux的使用范例

##### 第一步：创建reducer

```react
const defaultState = {
    inputValue: '123',
    list: ['1', '2']
}

// state 指的是整个store仓库里面存储的数据。这里给了一个初始化的数据 defaultState
export default (state = defaultState, action) => {
    // 根据action的type来进行判断，然后进行操作
    if (action.type === 'change input value') {
        // 先拷贝之前state里面原有的数据，因为react不推荐直接操作state
        const newState = JSON.parse(JSON.stringify(state));
        // 然后将action传递来的value复制到newState的inputValue
        newState.inputValue = action.value;
        // 会将newState返回给store，store会将newState替换掉老的state
        return newState;
    }

    if (action.type === 'add todo item') {
        // 先拷贝之前state里面原有的数据，因为react不推荐直接操作state
        const newState = JSON.parse(JSON.stringify(state));
        newState.list.push(newState.inputValue);
        newState.inputValue = '';
        return newState;
    }

    if (action.type === 'delete todo item') {
        // 先拷贝之前state里面原有的数据，因为react不推荐直接操作state
        const newState = JSON.parse(JSON.stringify(state));
        newState.list.splice(action.index, 1);
        return newState;
    }
    return state;
}
```

##### 第二步：创建store

```react
import { createStore } from 'redux';
// 将reducer引入store
import reducer from "./reducer";

// 根据reducer来创建store
const store = createStore(reducer,
                         window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());

export default store;
```

##### 第三步：将store引入到需要用到的Component组件当中

```react
import React, { Component, Fragment } from "react";
import 'antd/dist/antd.css';
import { Input, List } from 'antd';
// 将store引入到组件
import store from "./store";

class TodoList extends Component {

    constructor(props) {
        super(props);

        // 将数据仓库里的数据赋值给该组件的state，第一次挂载的时候
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        // 让store订阅handleStoreChange方法，只有这个方法发生变动，那么
        // store就会产生相应的变化
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return(
            <Fragment>
                {/* 上下左右有10px的边距 */}
                <div style={{margin: '10px 10px'}}>
                    <Input value={this.state.inputValue}
                           placeholder='todo list'
                           style={{width: '300px', marginRight: '5px'}}
                           onChange={this.handleInputChange}
                    />
                    <button onClick={this.handleBtnClick}>提交</button>

                    {/* 在渲染的时候会有一个index来表示该item的下标 */}
                    {/* 将index传递给handleDelete方法 */}
                    <List style={{width: '300px'}}
                          size="large"
                          bordered
                          dataSource={this.state.list}

                          renderItem={(item, index) => <List.Item onClick={this.handleDelete.bind(this, index)}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }

    handleInputChange(e) {
        const action = {
            // 创建一个action，其中的type是固定的，用于描述该动作
            type: 'change input value',
            value: e.target.value
        }
        // 通过dispatch将action传递给store
        store.dispatch(action);
    }

    // 将store的state替换掉TodoList这个组件的state，这样就可以随时渲染更新
    handleStoreChange() {
        this.setState(store.getState());
    }

    // 当点击按钮的时候，会触发的方法
    handleBtnClick() {
        const action = {
            type: 'add todo item',
        }
        store.dispatch(action);
    }

    // 这个方法接收一个index参数，index是对应item的下标
    handleDelete(index) {
        const action = {
            type: 'delete todo item',
            index
        }
        store.dispatch(action);
    }
}

export default TodoList;
```

##### 

#### UI组件和容器组件

> 是将渲染页面的语句和逻辑语句拆分开

##### 初始组件

```react
import React, { Component, Fragment } from "react";
import 'antd/dist/antd.css';
import { Input, List } from 'antd';
// 将store引入到组件
import store from "./store";

class TodoList extends Component {

    constructor(props) {
        super(props);

        // 将数据仓库里的数据赋值给该组件的state，第一次挂载的时候
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        // 让store订阅handleStoreChange方法，只有这个方法发生变动，那么
        // store就会产生相应的变化
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return(
            <Fragment>
                {/* 上下左右有10px的边距 */}
                <div style={{margin: '10px 10px'}}>
                    <Input value={this.state.inputValue}
                           placeholder='todo list'
                           style={{width: '300px', marginRight: '5px'}}
                           onChange={this.handleInputChange}
                    />
                    <button onClick={this.handleBtnClick}>提交</button>

                    {/* 在渲染的时候会有一个index来表示该item的下标 */}
                    {/* 将index传递给handleDelete方法 */}
                    <List style={{width: '300px'}}
                          size="large"
                          bordered
                          dataSource={this.state.list}

                          renderItem={(item, index) => <List.Item onClick={this.handleDelete.bind(this, index)}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }

    handleInputChange(e) {
        const action = {
            // 创建一个action，其中的type是固定的，用于描述该动作
            type: 'change input value',
            value: e.target.value
        }
        // 通过dispatch将action传递给store
        store.dispatch(action);
    }

    // 将store的state替换掉TodoList这个组件的state，这样就可以随时渲染更新
    handleStoreChange() {
        this.setState(store.getState());
    }

    // 当点击按钮的时候，会触发的方法
    handleBtnClick() {
        const action = {
            type: 'add todo item',
        }
        store.dispatch(action);
    }

    // 这个方法接收一个index参数，index是对应item的下标
    handleDelete(index) {
        const action = {
            type: 'delete todo item',
            index
        }
        store.dispatch(action);
    }
}

export default TodoList;

```



##### 拆分后的UI组件

```react
import React, { Component, Fragment } from "react";
import {Input, List} from "antd";

class TodoListUI extends Component {
    render() {
        return (
            <Fragment>
                <div style={{margin: '10px 10px'}}>
                    <Input
                        value={this.props.inputValue}
                        placeholder="Hello World"
                        style={{width: '300px', marginRight: '5px'}}
                        onChange={this.props.handleInputChange}
                    />
                    <button onClick={this.props.handleBtnClick}>点击</button>
                    <List
                        style={{width: '300px', marginTop: '10px'}}
                        size="small"
                        bordered
                        dataSource={this.props.list}
                        renderItem={(item, index) => <List.Item onClick={() => {this.props.deleteItem(index)}}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }
}

export default TodoListUI;
```



##### 拆分后的容器组件

```react
import React, { Component, Fragment } from "react";
import "antd/dist/antd.css"
import store from "./store";
import TodoListUI from './TodoListUI';

// 将所有的action抽取出来，放到一个叫做actionTypes的文件中
import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM } from "./actionTypes";

class TodoList extends Component {

    constructor(props) {
        super(props);
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.deleteItem = this.deleteItem.bind(this)
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return <TodoListUI
        // 将组件的各种状态传递给子组件        
        inputValue = {this.state.inputValue}
        list = {this.state.list}
        handleInputChange = {this.handleInputChange}
        handleBtnClick = {this.handleBtnClick}
        deleteItem = {this.deleteItem}
        handStoreChange = {this.handleStoreChange}
        />
    }

    handleInputChange(e) {
        const action = {
            type: CHANGE_INPUT_VALUE,
            value: e.target.value
        }
        store.dispatch(action);
    }

    handleBtnClick() {
        const action = {
            type: ADD_TODO_ITEM,
        }
        store.dispatch(action);
    }

    handleStoreChange() {
        this.setState(store.getState());
    }

    deleteItem(index) {
        const action = {
            type: DELETE_TODO_ITEM,
            index
        }
        store.dispatch(action);
    }
}

export default TodoList;
```

### Redux 中间件

#### redux-thunk

> redux-thunk的安装
>
> 它可以将异步操作从组建中移除，然后发到action文件当中去

```bash
npm install redux-thunk
```

> redux-thunk中间件的使用
>
> 它主要是在创建store的时候被引用

```react
// thunk和saga它们都是中间件，如果要使用，首先需要引入applyMiddleware
import {createStore, applyMiddleware, compose} from "redux";
// 然后再引入对应的中间件，这里是thunk
import thunk from "redux-thunk";
import reducer from "./reducer";

// 如果要同时使用redux的devtools和其他的中间件，那么就需要像下面一样来写。
// 因为redux devtools也是一个中间件
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
    //    compose需要从redux中引入
    }) : compose;

const enhancer = composeEnhancers(applyMiddleware(thunk))

const store = createStore(reducer, enhancer)

export default store;
```

> actionCreators 文件

```react
// 这里是返回的一个对象
export const getDeleteItemAction = (index) => ({
    type: DELETE_TODO_ITEM,
    index
})

export const getInitItemAction = (data) => ({
    type: INIT_LIST_ITEM,
    data
});

// 这里是返回的一个函数，运用到了react-thunk。如果没有它，那么久不能返回一个函数
export const getTodoList = () => {
    return (dispatch) => {
        axios.get('https://run.mocky.io/v3/06315b0b-6c7f-49c3-9e51-94e3a35da33b')
            .then((res) => {
                const data =res.data;
                dispatch(getInitItemAction(data));
            })
            .catch(() => {console.log('failed')})
    }
}
```





### react-redux 学习

> 安装react-redux

```bash
进入到工程目录
npm install react-redux
```

#### react-redux 使用范例

##### index.js 

```react
import React from 'react';
import ReactDOM from 'react-dom';
import TodoList from "./TodoList";
import store from "./store";
// react-redux 提供的核心API
import { Provider } from 'react-redux';

const App = (
    // Provider组件，由react-redux提供。
    // Provider的store属性的值，就是整个store数据仓库的值。
    // 这样，只要是在Provider下面的组件，例如TodoList组件
    // 都可以获取到store里面的内容
    <Provider store={store}>
        <TodoList />
    </Provider>
);

ReactDOM.render(
  <React.StrictMode>
    {/* 然后将App组件传给ReactDOM.render进行渲染 */}
      {App}
  </React.StrictMode>,
  document.getElementById('root')
);
```



##### store.js 和 reducer.js 页面不需要作改变

##### TodoList.js 组件

```react
import React, { Component, Fragment } from "react";
// react-redux 提供的核心API
import { connect } from 'react-redux';
import 'antd/dist/antd.css';
import { Input, List } from 'antd';

class TodoList extends Component {

    render() {
        return(
            <Fragment>
                <div style={{margin: '10px 10px'}}>
                    <Input
                        style={{width: '300px'}}
                        placeholder='todo list'
                        value={this.props.inputValue}
                        onChange={this.props.changeInputValue}
                    />
                    <button
                        style={{marginLeft: '5px'}}
                        onClick={this.props.handleBtnClick}
                    >提交</button>

                    <List style={{width: '300px', marginTop: '10px'}}
                          size="large"
                          bordered
                          dataSource={this.props.list}
                          renderItem={(item, index) => <List.Item onClick={this.props.deleteItem.bind(this, index)}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }
}

// 这个函数是用来将store里面的state传递给子组件的props
// 这里是传递给TodoList
const mapStateToProps = (state) => {
    return {
        // 让子组件的inputValue和store里面的inputValue产生关联
        inputValue: state.inputValue,
        // 让子组件的list和store里面的list产生关联
        list: state.list
    }
}

// 将store的 dispatch方法挂载到 props上
// 这个函数是用来，将修改后的子组件state中的数据返回给store
// 让store来更改修改过后的数据
const mapDispatchToProps = (dispatch) => {
    return {
        changeInputValue(e) {
            const action = {
                type: 'change input value',
                value: e.target.value
            }
            dispatch(action);
        },
        handleBtnClick() {
            const action = {
                type: 'add todo item'
            }
            dispatch(action);
        },
        deleteItem(index) {
            const action = {
                type: 'delete todo item',
                index
            }
            dispatch(action);
        }
    }
}

// 这里的意思是，让TodoList组件与store进行连接
export default connect(mapStateToProps, mapDispatchToProps)(TodoList);
```



### react 使用styled-components

> 运用styled-components来对react项目的css文件进行管理

将css放入一个叫style.js的文件中。

```react
import { createGlobalStyle } from 'styled-components';

export const GlobalStyle = createGlobalStyle`
  body{
    marigin: 0;
    padding: 0;
    background: green;
  }
`
```

然后再将其引入到需要使用这个css的组件当中

```react
import React from 'react';
// 引入css
import { GlobalStyle } from "./style";

function App() {
  return (
    <p style={{margin: "10px 10px"}}>
      // 使用css
      <GlobalStyle/>
      Hello World
    </p>
  );
}

export default App;

```

### React 过程中的坑

> 当运用了combineReducers这个组件之后，遇到的问题

整合的reducer文件

```react
import { combineReducers } from "redux";
import reducerHeader from "../header/redux/reducer";

export default combineReducers({
    header: reducerHeader
})
```



对应的组件当中就必须如下写。因为是拆分的，所以要带上其对应的header。以此类推

```react
const mapStateToProps = (state) => {
    return {
        // 将store里面存储的信息传递给子组件，也就是这里的Header组件
        focused: state.header.get('focused'),
        hotList: state.header.get('hotList'),
        totalPage: state.header.get('totalPage'),
        page: state.header.get('page'),
        mouseIn: state.header.get('mouseIn')
    }
}
```

### Component 和 PureComponent

Component：只要项目store里面的数据发生了变化，那么每一个组件就会被重新的渲染。这样就会造成性能的降低。为了避免这样的情况，可以在组件中使用shouldComponentUpdate()这个生命周期函数。通过这个函数来判断，store里面的数据更改是否和当下的组件相关。如果不相关的话，就不重新渲染



PureComponent：react底层帮助实现了上面的功能。但是需要配合immutable.js使用，否则会出现不可预测的问题



### 异步组件/withRouter路由使用

, description=React Study, createTime=2020-07-02, updateTime=2021-02-25, category=Category{id=25, name='React'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0)], isHasContent=true, first=true, last=false, isHasNext=true, isHasPrevious=false))
2021-03-25 18:17:33.135  INFO 36287 --- [Thread-10] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'
2021-03-25 18:17:33.136  INFO 36287 --- [Thread-10] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'
2021-03-25 18:17:33.147  INFO 36287 --- [Thread-10] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...
2021-03-25 18:17:33.153  INFO 36287 --- [Thread-10] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.
2021-03-25 18:17:33.654  INFO 36287 --- [restartedMain] com.banjo.blogvue.BlogVueApplication     : Starting BlogVueApplication using Java 1.8.0_251 on Laughings-MacBook-Pro.local with PID 36287 (/Users/laughingli/Documents/Java/blog-vue/target/classes started by laughingli in /Users/laughingli/Documents/Java/blog-vue)
2021-03-25 18:17:33.654 DEBUG 36287 --- [restartedMain] com.banjo.blogvue.BlogVueApplication     : Running with Spring Boot v2.4.2, Spring v5.3.3
2021-03-25 18:17:33.654  INFO 36287 --- [restartedMain] com.banjo.blogvue.BlogVueApplication     : The following profiles are active: dev
2021-03-25 18:17:33.959  INFO 36287 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2021-03-25 18:17:33.977  INFO 36287 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 17 ms. Found 2 JPA repository interfaces.
2021-03-25 18:17:34.159  INFO 36287 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
2021-03-25 18:17:34.160  INFO 36287 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2021-03-25 18:17:34.160  INFO 36287 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.41]
2021-03-25 18:17:34.172  INFO 36287 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2021-03-25 18:17:34.172  INFO 36287 --- [restartedMain] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 514 ms
2021-03-25 18:17:34.253  INFO 36287 --- [restartedMain] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2021-03-25 18:17:34.259  INFO 36287 --- [restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Starting...
2021-03-25 18:17:34.273  INFO 36287 --- [restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Start completed.
2021-03-25 18:17:34.273  INFO 36287 --- [restartedMain] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL8Dialect
2021-03-25 18:17:34.411  INFO 36287 --- [restartedMain] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
2021-03-25 18:17:34.412  INFO 36287 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2021-03-25 18:17:34.443  INFO 36287 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2021-03-25 18:17:34.656  WARN 36287 --- [restartedMain] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2021-03-25 18:17:34.762  INFO 36287 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2021-03-25 18:17:34.965  INFO 36287 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2021-03-25 18:17:34.970  INFO 36287 --- [restartedMain] com.banjo.blogvue.BlogVueApplication     : Started BlogVueApplication in 1.354 seconds (JVM running for 335688.071)
2021-03-25 18:17:34.972  INFO 36287 --- [restartedMain] .ConditionEvaluationDeltaLoggingListener : Condition evaluation unchanged
2021-03-25 18:17:36.439  INFO 36287 --- [Thread-20] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'
2021-03-25 18:17:36.439  INFO 36287 --- [Thread-20] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'
2021-03-25 18:17:36.440  INFO 36287 --- [Thread-20] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Shutdown initiated...
2021-03-25 18:17:36.445  INFO 36287 --- [Thread-20] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Shutdown completed.
2021-03-25 18:17:36.625  INFO 36287 --- [restartedMain] com.banjo.blogvue.BlogVueApplication     : Starting BlogVueApplication using Java 1.8.0_251 on Laughings-MacBook-Pro.local with PID 36287 (/Users/laughingli/Documents/Java/blog-vue/target/classes started by laughingli in /Users/laughingli/Documents/Java/blog-vue)
2021-03-25 18:17:36.625 DEBUG 36287 --- [restartedMain] com.banjo.blogvue.BlogVueApplication     : Running with Spring Boot v2.4.2, Spring v5.3.3
2021-03-25 18:17:36.625  INFO 36287 --- [restartedMain] com.banjo.blogvue.BlogVueApplication     : The following profiles are active: dev
2021-03-25 18:17:36.753  INFO 36287 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2021-03-25 18:17:36.763  INFO 36287 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 9 ms. Found 2 JPA repository interfaces.
2021-03-25 18:17:37.017  INFO 36287 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
2021-03-25 18:17:37.018  INFO 36287 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2021-03-25 18:17:37.018  INFO 36287 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.41]
2021-03-25 18:17:37.024  INFO 36287 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2021-03-25 18:17:37.025  INFO 36287 --- [restartedMain] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 398 ms
2021-03-25 18:17:37.102  INFO 36287 --- [restartedMain] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2021-03-25 18:17:37.107  INFO 36287 --- [restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-3 - Starting...
2021-03-25 18:17:37.120  INFO 36287 --- [restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-3 - Start completed.
2021-03-25 18:17:37.120  INFO 36287 --- [restartedMain] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL8Dialect
2021-03-25 18:17:37.242  INFO 36287 --- [restartedMain] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
2021-03-25 18:17:37.242  INFO 36287 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2021-03-25 18:17:37.269  INFO 36287 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2021-03-25 18:17:37.452  WARN 36287 --- [restartedMain] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2021-03-25 18:17:37.548  INFO 36287 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2021-03-25 18:17:37.699  INFO 36287 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2021-03-25 18:17:37.702  INFO 36287 --- [restartedMain] com.banjo.blogvue.BlogVueApplication     : Started BlogVueApplication in 1.098 seconds (JVM running for 335690.803)
2021-03-25 18:17:37.704  INFO 36287 --- [restartedMain] .ConditionEvaluationDeltaLoggingListener : Condition evaluation unchanged
2021-03-25 18:17:37.844  INFO 36287 --- [http-nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2021-03-25 18:17:37.845  INFO 36287 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2021-03-25 18:17:37.846  INFO 36287 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms
2021-03-25 18:17:37.850  INFO 36287 --- [http-nio-8080-exec-1] com.banjo.blogvue.aspect.LogAspect       : Request: RequestLog{url='http://localhost:8080/blog', ip='0:0:0:0:0:0:0:1', classMethod='com.banjo.blogvue.controller.admin.AdminPageController.listBlogs', args=[]}
2021-03-25 18:17:37.855  INFO 36287 --- [http-nio-8080-exec-1] com.banjo.blogvue.aspect.LogAspect       : Result: admin/listBlogs
2021-03-25 18:17:38.514  INFO 36287 --- [http-nio-8080-exec-1] com.banjo.blogvue.aspect.LogAspect       : Request: RequestLog{url='http://localhost:8080/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.banjo.blogvue.controller.admin.BlogController.list', args=[0, 4]}
2021-03-25 18:17:38.552  INFO 36287 --- [http-nio-8080-exec-1] com.banjo.blogvue.aspect.LogAspect       : Result: Result(code=0, message=, data=Page4Navigator(pageFromJPA=Page 1 of 2 containing com.banjo.blogvue.pojo.Blog instances, navigatePages=0, navigatePageNums=null, totalPages=2, number=0, totalElements=7, size=4, numberOfElements=4, content=[Blog(id=23, title=AWS Cloud, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Translation, views=11, content=#### 卸载自带jdk

```bash
# 先使用以下命令 查看当前的jdk
rpm -qa|grep jdk
java-1.7.0-openjdk-1.7.0.261-2.6.22.1.83.amzn1.x86_64
copy-jdk-configs-3.3-10.3.amzn1.noarch

# 然后根据对应版本的jdk 直接用下面的命令删除
sudo rpm -e --nodeps java-1.7.0-openjdk-1.7.0.261-2.6.22.1.83.amzn1.x86_64

# 然后使用yum下载jdk，使用下面的命令查看java可选版本
$ yum -y list java*

# 然后根据版本号，直接下载
sudo yum install -y java-1.8.0-openjdk-devel.x86_64
```



#### FileZilla 连接 AWS

1. 打开 FileZilla 的 "Edit" -> "Settings" 对话框，在左边的“选择页面” 选择“SFTP”， 右边点击 “添加密钥文件...” 按钮，导入Amazon给的密钥文件 

   ![image-20200713163800225](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/7gZEBIRuMvdbPli.png)

2. 打开File选择Site Manager

   Protocol中选择SFTP

   Host选择 公有DNS![image-20200713163956246](https://i.loli.net/2020/07/17/9fIEBSrGNMzgoLu.png)

![image-20200713163918562](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/OQzkdvYoGqKLs5B.png)

然后选择Interactive的方式登录，用户是ec2-user

或者选择key的方式都可以

然后就能连接成功

> 连接成功之后需要将一个用于接收上传文件的文件夹进行权限修改

如下：

![image-20200713170334089](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/TNozpkPF8OgeJyM.png)



#### 安装docker

```bash
# 先查看版本 
yum -y list docker*
# 然后根据版本来下载
sudo yum install -y docker.x86_64

# 下载之后需要启动Docker服务
sudo service docker start

# 然后将ec2-user添加到docker组，否则不能执行Docker命令
sudo usermod -a -G docker ec2-user

# 然后重启AWS实例，就可以开启docker服务了
```



#### Docker vim命令

```bash
首先进入容器，然后执行
 apt-get update
 
 然后执行
 apt-get install vim
```

#### AWS 安全组

```bash
# 1. 如果tomcat开启的端口是8080，那么就需要在AWS的安全组里面放行对8080端口的访问，同时还要对9001端口进行开放

docker run -d -p 9001:8080 tomcat

其他的服务如果需要使用其他的端口，那么也用相同的方法进行放行

下面以MySQL的连接为例，3310和3306都需要在安全组里面进行放行。

 mysql          "docker-entrypoint.s…"   17 hours ago        Up 17 hours         33060/tcp, 0.0.0.0:3310->3306/tcp   mysql01
```



![image-20200714180816580](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/ysLFVnza2wGp9E6.png)



#### IDEA 连接 AWS 上的docker

1. 首先修改docker需要监听的IP和端口

```bash
   1. 首先关闭docker服务
   sudo service docker stop
   2. 然后修改docker 服务端监听的端口和ip
   sudo dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375
   3. 然后启动docker服务
   sudo service docker start
   4. 然后修改客户端的
   docker -H tcp://0.0.0.0:2375 ps
   没有输出就表示成功。
   
   
   
   ```

2. 然后再aws里面的安全组里将2375端口进行放行

3. 然后再利用IDEA对docker进行远程连接即可

> 以systemd的方式连接

```bash
1. 先找到这个文件
/lib/systemd/system/docker.service

然后注释掉下面的
ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock $OPTIONS $DOCKER_STORAGE_OPTIONS $DOCKER_ADD_RUNTIMES

然后再添加
ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock
这样远程就能通过2375端口访问到了
```

#### AWS ec2 安装MySQL

```bash
# 先查看是否有旧版本MySQL
rpm -qa | grep -i mysql

# 如果有的话，使用下面的命令将其全部删除
sudo rpm -ev 加mysql的文件名


# 下载并进入到下载好的文件夹
 wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.17-linux-glibc2.12-x86_64.tar.xz
 # 解压下载的压缩包
 tar xvf mysql-8.0.17-linux-glibc2.12-x86_64.tar.xz
 
 # 将解压好的复制到/usr/local目录下并且重命名为mysql
 sudo mv mysql-8.0.17-linux-glibc2.12-x86_64 /usr/local/mysql
 
 # 进入到mysql目录，然后创建一个data文件夹，用于存放数据
 mkdir data
 
 # 创建mysql用户组和mysql用户
 sudo groupadd mysql
 sudo useradd -g mysql mysql
 
 # 改变mysql目录权限 注意后面都有一个点
 sudo chown -R mysql .
 sudo chgrp -R mysql .
 
 # 创建mysql_install_db安装文件，并且修改权限
sudo mkdir mysql_install_db
sudo chmod 777 ./mysql_install_db

# 初始化
sudo bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data
# 一定要记住临时密码
A temporary password is generated for root@localhost: 

# mysql配置，将support-files下的移动到init.d目录下，并且重命名，两个都要
sudo cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld
sudo cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql
# 修改或者创建my.cnf文件，并且加入下面的命令

[mysqld]
    basedir = /usr/local/mysql
    datadir = /usr/local/mysql/data
    socket = /usr/local/mysql/mysql.sock
    character-set-server=utf8
    port = 3306
   sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
 [client]
   socket = /usr/local/mysql/mysql.sock
   default-character-set=utf8
   
# 建立MySQL服务
sudo chmod +x /etc/init.d/mysqld
sudo chmod +x /etc/init.d/mysql
# 添加到系统服务
sudo chkconfig --add mysqld
sudo chkconfig --add mysql
#配置全局环境变量

先设置 /etc/profile文件的权限，可以读写
sudo /etc/profile chmod 777
然后再在里面添加以下配置
export PATH=$PATH:/usr/local/mysql/bin:/usr/local/mysql/lib
export PATH

# 设置环境变量立即生效
source /etc/profile

# 启动MySQL服务

sudo service mysql start

# 登录MySQL
mysql -u root -p 回车
输入上面的临时密码即可

# 修改初始密码
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY'自己的密码';

# 设置远程可登录
进入mysql
1. use mysql
2. update user set host='%' where user='root' limit 1;
3. flush privileges; # 刷新权限

然后就可以进行远程登录
```

, description=Learn how to set up a clear AWS cloud, createTime=2021-02-17, updateTime=2021-02-25, category=Category{id=17, name='AWS Cloud'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=21, title=Docker Notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=14, content=#### Linux 安装 docker

```bash
# 1. 首先用下面的命令卸载旧版本，如果有的话
sudo yum remove docker \ 
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
                  
# 2. 安装依赖包
sudo yum install -y yum-utils        

# 3. 设置镜像仓库
sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo

# 4. 安装docker引擎
sudo yum install docker-ce docker-ce-cli containerd.io

# 5. 启动docker 和重启
sudo systemctl start docker
sudo systemctl restart docker

# 6. 测试是否启动成功
sudo docker run hello-world

# 7. 卸载依赖和删除资源
sudo yum remove docker-ce docker-ce-cli containerd.io
sudo rm -rf /var/lib/docker
```



docker run hello-world的流程图

1. docker会在本地仓库寻找hello-world的镜像，找到就运行。
2. 没找到，docker client就会跟 docker daemon联系，然后下载hello-world镜像到本地
3. 下载到本地之后，再运行该镜像。

 ![image-20200710230333325](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200710230333325.png)![image-20200710230221724](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200710230221724.png)



#### Docker 常用命令

##### 帮助命令

```shell
docker version # 查看docker信息
docker info		 # 查看docker系统信息，包括有多少镜像和容器
docker --help  # 帮助命令
```



##### 镜像命令

> 查看镜像

```bash
docker images  # 查看当前主机上的所有镜像
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              bf756fb1ae65        6 months ago        13.3kB

# docker images 命令的可选性
-a, --all 	# 列出所有的镜像跟默认的docker images一样
-q, --quit	# 只显示镜像的id,-q 和 --quit一样

[root@localhost ~]# docker images --quiet
bf756fb1ae65

[root@localhost ~]# docker images -q
bf756fb1ae65

docker search mysql 搜索mysql的镜像 #镜像的搜索
```

> 搜索镜像

```bash
docker search mysql 搜索mysql的镜像 #镜像的搜索
# 只需要添加想要的镜像的名称，就可以进行搜索。
[root@localhost ~]# docker search mysql
NAME                              DESCRIPTION                                     STARS               
mysql                             MySQL is a widely used, open-source relation…   9718
```

> 下载镜像

```bash
docker pull mysql  # 下载mysql

[root@localhost ~]# docker pull mysql
Using default tag: latest #如果不指定tag，就默认下载最新版本
latest: Pulling from library/mysql
8559a31e96f4: Pull complete	# 分层下载， docker images的核心 联合文件系统
d51ce1c2e575: Pull complete	# 好处：举例--如果要更新到更新版本的MySQL，那么下次执行pull的
c2344adc4858: Pull complete	# 时候只需要下载被更新的部分，其余没更新的不会被重复下载
fcf3ceff18fc: Pull complete
16da0c38dc5b: Pull complete
b905d1797e97: Pull complete
4b50d1c6b05c: Pull complete
c75914a65ca2: Pull complete
1ae8042bdd09: Pull complete
453ac13c00a3: Pull complete
9e680cd72f08: Pull complete
a6b5dc864b6c: Pull complete
Digest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest # 这里是真实的mysql的地址

docker pull mysql 等价于  docker pull docker.io/library/mysql:lastest
```



> 删除镜像

```bash
docker rmi -f 加上(镜像的id) 

[root@localhost ~]# docker rmi -f bf756fb1ae65
Untagged: hello-world:latest
Untagged: hello-world@sha256:d58e752213a51785838f9eed2b7a498ffa1cb3aa7f946dda11af39286c3db9a9
Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b

##或者 docker rmi -f 加上(镜像的repository名称) 
docker rmi -f hello-world

[root@localhost ~]# docker rmi -f hello-world
Untagged: hello-world:latest
Untagged: hello-world@sha256:d58e752213a51785838f9eed2b7a498ffa1cb3aa7f946dda11af39286c3db9a9
Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b

```



##### 容器命令

> 先有镜像，才能创建容器。以下用docker下载centos来进行举例学习

> 新建容器并启动

```bash
# -it 表示使用交互方式运行，进入容器查看内容
[root@localhost ~]# docker run -it centos /bin/bash  
									# docker run -d centos   表示后台启动容器
[root@f72fb12d27fc /]# ls  这里表示已经进入到了centos这个容器当中
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

[root@f72fb12d27fc /]# exit  退出并且停止容器
exit
[root@localhost ~]#

删除所有容器
docker rm $(docker ps -aq)
```

> 查看运行和曾经运行过的容器

```bash
[root@localhost ~]# docker ps -a 表示查看当前在运行的和曾经运行过的容器
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
f72fb12d27fc        centos              "/bin/bash"         3 minutes ago       Exited (0) 2 minutes ago                       hopeful_mcnulty
3af87bce0732        bf756fb1ae65        "/hello"            12 hours ago        Exited (0) 12 hours ago                        lucid_sammet
b22be932b11a        bf756fb1ae65        "/hello"            12 hours ago        Exited (0) 12 hours ago                        vigorous_chaplygin
[root@localhost ~]# docker ps  表示查看正在运行的容器
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
[root@localhost ~]#

```

> 启动，停止，重启容器

```shell
docker start 容器id
docker restart 容器id
docker stop 容器id
docker kill 容器id #强制停止当前容器
```

> 退出容器

```bash
exit 表示退出且停止容器运行

Ctrl + P + Q #不停止容器运行，只退出容器

[root@f4b87ffb286b /]# [root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
f4b87ffb286b        centos              "/bin/bash"         13 seconds ago      Up 11 seconds                           laughing_darwin
[root@localhost ~]#

```



> 进入在运行的指定容器

```shell
docker exec -it 容器名 /bin/bash

[root@localhost ~]# docker exec -it 0f45f1d47525 /bin/bash
[root@0f45f1d47525 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

docker attach 容器名

[root@localhost ~]# docker attach 0f45f1d47525
[root@0f45f1d47525 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

###区别
docker exec			# 进入容器后开启一个新的终端，可以在里面操作(这个是常用的)。
docker attach		# 进入容器正在执行的终端，不会启动新的进程。

```



> 删除容器

```bash
docker rm 容器id
```

> 列出所有容器

```bash
docker container ls
```



> 日志打印

```bash
docker logs --tail 10 0f45f1d47525  
--tail 表示以字符串的形式打印，10是--tail的参数，打印10行。最后跟的是容器的id
```

> 查看容器进程信息

```bash
docker top 容器id
[root@localhost ~]# docker top 0f45f1d47525
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                13539               13521               0                   18:08               pts/0               00:00:00            /bin/bash
```

> 查看容器元数据(所有数据)

```bash
[root@localhost ~]# docker inspect 0f45f1d47525（容器id）
```



> 从容器中复制文件到主机

```bash
[root@6ad773845eab /]# cd home  开启容器 进入到home目录
[root@6ad773845eab home]# touch test.java	在home目录创建test.java文件
[root@6ad773845eab home]# ls
test.java
[root@6ad773845eab home]# exit 退出即可
exit
[root@localhost ~]# ls 当前文件夹下是没有test.java文件
anaconda-ks.cfg  Desktop  Documents  Downloads  Music  original-ks.cfg  Pictures  Public  study.txt  Templates  Videos  

# 将6ad773845eab:/home/test.java  将这个容器的home目录中的test.java文件复制到
# ~目录。
[root@localhost ~]# docker cp 6ad773845eab:/home/test.java ~
[root@localhost ~]# ls
anaconda-ks.cfg  Desktop  Documents  Downloads  Music  original-ks.cfg  Pictures  Public  study.txt  Templates  test.java  Videos
[root@localhost ~]#
```



#### Docker Nginx

##### 启动并验证Nginx

```bash
-d 表示后台运行
--name nginx01表示它的名字
-p 8082:80 #8082表示客户端访问的请求的端口，80表示本地与之对应的端口。
就是客户端访问8082端口会拿到本地80端口的数据

[root@localhost ~]# docker run -d --name nginx01 -p 8082:80 nginx
f0a1f169564a7c8faacb1aa73cae06449267e5b39493a05196086823b69f8972
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
f0a1f169564a        nginx               "/docker-entrypoint.…"   4 seconds ago       Up 3 seconds        0.0.0.0:8082->80/tcp   nginx01
6ad773845eab        centos              "/bin/bash"              56 minutes ago      Up 51 minutes                              elastic_mestorf
[root@localhost ~]# curl localhost:8082  验证是否能够访问成功
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
Nginx在docker里面的配置文件在 /etc/nginx路径下面
```



#### Docker Tomcat

```bash
# tomcat 的启动跟Nginx相似
也是要设置端口的映射。才能进行访问
[root@localhost ~]# docker run -d -p 9001:8080 tomcat
4126cf694a054e44dfa27a059da130ff8201d427b0e1aeeafb57a986f8fa8667
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
4126cf694a05        tomcat              "catalina.sh run"        4 seconds ago       Up 3 seconds        0.0.0.0:9001->8080/tcp   loving_bell
f0a1f169564a        nginx               "/docker-entrypoint.…"   27 minutes ago      Up 27 minutes       0.0.0.0:8082->80/tcp     nginx01
6ad773845eab        centos              "/bin/bash"              About an hour ago   Up About an hour                             elastic_mestorf

## 返回404 表示能够访问，但是当前的Tomcat里面还缺少可用于访问的文件
[root@localhost ~]# curl localhost:9001
<!doctype html><html lang="en"><head><title>HTTP Status 404 – Not Found</title><style type="text/css">body {font-family:Tahoma,Arial,sans-serif;} h1, h2, h3, b {color:white;background-color:#525D76;} h1 {font-size:22px;} h2 {font-size:16px;} h3 {font-size:14px;} p {font-size:12px;} a {color:black;} .line {height:1px;background-color:#525D76;border:none;}</style></head><body><h1>HTTP Status 404 – Not Found</h1><hr class="line" /><p><b>Type</b> Status Report</p><p><b>Description</b> The origin server did not find a current representation for the target resource or is [root@lo[root@localhost ~]#

# 解决办法

[root@localhost ~]# docker exec -it 4126cf694a05 /bin/bash 先重新进入Tomcat运行的容器
root@4126cf694a05:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work

## 将webapps.dist 文件夹的内容全部复制的 webapps即可

root@4126cf694a05:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work
root@4126cf694a05:/usr/local/tomcat# cd webapps.dist
root@4126cf694a05:/usr/local/tomcat/webapps.dist# ls
ROOT  docs  examples  host-manager  manager
root@4126cf694a05:/usr/local/tomcat/webapps.dist# cd examples
root@4126cf694a05:/usr/local/tomcat/webapps.dist/examples# ls
WEB-INF  index.html  jsp  servlets  websocket
root@4126cf694a05:/usr/local/tomcat/webapps.dist/examples# cd ..
root@4126cf694a05:/usr/local/tomcat/webapps.dist# cd ..
root@4126cf694a05:/usr/local/tomcat# cp -r webapps.dist/* webapps
root@4126cf694a05:/usr/local/tomcat#

#然后就能成功访问到index页面
```





#### Docker ElasticSearch

```bash
# 先下载ElasticSearch
# docker pull docker.elastic.co/elasticsearch/elasticsearch:7.8.0

# 官方推荐的开启单节点集群
# docker run -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" docker.elastic.co/elasticsearch/elasticsearch:7.8.0
但是上面的方式会暴露一个问题，那就是ES占内存非常大，而我们的虚拟机内存很小。所以不建议这样开启

# 其中 -e ES_JAVA_OPTS="-Xms64m -Xmx512m" 表示最小占用64M内存 最大占用512M
# docker run -d -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.8.0

然后去访问 即可验证
[root@localhost ~]# curl localhost:9200
{
  "name" : "88e49838ff71",
  "cluster_name" : "docker-cluster",
  "cluster_uuid" : "T6BQKfqySz63NlT_Tp9NYQ",
  "version" : {
    "number" : "7.8.0",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "757314695644ea9a1dc2fecd26d1a43856725e65",
    "build_date" : "2020-06-14T19:35:50.234439Z",
    "build_snapshot" : false,
    "lucene_version" : "8.5.1",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}
```



#### Docker 提交镜像

==提交了之后，只是在本地存在。还需要push到网络上，才能实现下载使用的功能==

```bash
举例：下载的Tomcat镜像中，webapps文件夹是没有东西的，所以我们在webapps文件夹下面创建一些文件。然后通过下面的命令将修改后的镜像commit
-m 用于添加描述信息，跟Git类似。-a 是作者名字。加上需要修改的容器id，然后 tomcat01是repository名

[root@localhost ~]# docker commit -m="docker with changes in webapps" -a="banjo" 6c9c1265f18e tomcat01
sha256:b1c6475b6b76c51fa3cb08edcb82ec37725c93643eca9274e12301e44594f781
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
6c9c1265f18e        tomcat              "catalina.sh run"   3 minutes ago       Up 3 minutes        0.0.0.0:9001->8080/tcp   recursing_thompson
[root@localhost ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
tomcat01            latest              b1c6475b6b76        9 seconds ago       652MB
nginx               latest              0901fa9da894        11 hours ago        132MB
tomcat              latest              6055d4d564e1        4 days ago          647MB
centos              latest              831691599b88        3 weeks ago         215MB
elasticsearch       7.8.0               121454ddad72        3 weeks ago         810MB
mysql               latest              be0dbf01a0f3        4 weeks ago         541MB
```

![image-20200711174623196](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711192711325.png)



#### Docker 容器数据卷

容器数据卷可以帮助容器的持久化和同步操作，容器间的数据也可以共享

就是容器中的一个路径映射到本地主机上的一个路径，只要容器中的这个路径里面进行了操作，比如添加文件，删除文件，修改文件，那么在主机上的映射的这个目录也会有相同的操作。

==我的理解：以后可以在本地的/home 目录下面创建，centos，Tomcat，ES，redis，Nginx这些目录，然后将这些目录分别的映射到对应的容器中去，就可以保证容器中的重要数据不会丢失==

> 直接使用命令的方式进行挂载

```bash
举例: -v 是用来挂载的 : 有的时候在容器路径下 ### eg. /home:ro 或者 /home:rw 这表示read only或者read & write 表示在容器中这个路径下的文件是只读或者读写均可

将本地主机/home/centos 路径 与 容器centos的 /home路径进行绑定
[root@localhost ~]# docker run -it -v /home/centos:/home centos /bin/bash

然后使用 docker inspect 容器id就可以查看到以下信息，如果没有出现，则代表没有挂载成功。

测试方法，在容器的/home路径下面创建文件，然后再在本地主机的/home/centos下查看是否有相同的文件

同样的去本地主机创建文件，然后去容器中去查看也可以验证
```

![image-20200711192711325](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711174623196.png)



##### 匿名挂载

```bash
# 1. 匿名挂载
-d	后台运行
-P	大写的P表示随机的端口
这里没有指定本机的路径，所以就是匿名挂载
[root@localhost /]# docker run -d -P --name nginx01 -v /etc/nginx nginx
326008beb69c229e1a424d6127aba2dd409989092108b90a60aaff11fa3abb93

[root@localhost /]# docker volume ls 通过这个命令可以拿到匿名挂载的名称
DRIVER              VOLUME NAME
local               626a093ff31bcf34ef1741f5eab3e3077a7bf445a1280fd2f2cb3fd6f448a004
local               6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70

[root@localhost /]# docker volume inspect 6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70 然后通过这个命令查看当前的匿名挂载是映射到本机的什么位置，可以看到是在/var/lib/docker/volumes下面
[
    {
        "CreatedAt": "2020-07-11T05:50:36-07:00",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70/_data",
        "Name": "6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70",
        "Options": null,
        "Scope": "local"
    }
]

```

![image-20200711225525788](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712112330604.png)

##### 具名挂载

```bash
# 2. 具名挂载
test-nginx 就是这个挂载的名字
[root@localhost /]# docker run -d -P --name nginx02 -v test-nginx:/etc/nginx nginx
```

![image-20200711225848468](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711225848468.png)



##### Dockerfile方式挂载

```bash
# 先在主机的一个路径里面生成一个叫做dockerfile的文件
[root@localhost ~]# mkdir /home/docker-test-volume 创建这个目录
[root@localhost ~]# cd /home/docker-test-volume 进入这个目录
[root@localhost docker-test-volume]# ls
[root@localhost docker-test-volume]# vim dockerfile1  创建dockerfile1 文件并写下下面的内容
[root@localhost docker-test-volume]# cat dockerfile1
FROM centos ##以镜像centos为基础

VOLUME ["volume01", "volume02"]  ## 挂载两个卷

CMD echo "-----success------"   ## 成功后的输出
CMD /bin/bash		## 然后会进入该路径

# build 用于创建dockerfile
# -f 		哪一个file文件
# -t		生成的对象
# .			生成在当前目录下

[root@localhost docker-test-volume]# docker build -f /home/docker-test-volume/dockerfile1 -t test/centos .

Sending build context to Docker daemon  2.048kB
Step 1/4 : FROM centos
 ---> 831691599b88
Step 2/4 : VOLUME ["volume01", "volume02"]
 ---> Running in 0c80409788d3
Removing intermediate container 0c80409788d3
 ---> 4e7fe085c688
Step 3/4 : CMD echo "-----success------"
 ---> Running in 3a6eebcf35a9
Removing intermediate container 3a6eebcf35a9
 ---> ec43d897d893
Step 4/4 : CMD /bin/bash
 ---> Running in 7f1029e69632
Removing intermediate container 7f1029e69632
 ---> efd4071b1ad0
Successfully built efd4071b1ad0
Successfully tagged test/centos:latest
## 镜像生成成功
test/centos         latest              efd4071b1ad0        2 minutes ago       215MB
```

当我们利用这个镜像创建容器的时候，就可以看到挂载的卷。

![image-20200712112330604](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712112754635.png)

![image-20200712112754635](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712174322428.png)



##### 数据卷容器

> **--volumes-from** 顾名思义，就是从另一个容器当中挂载容器中已经创建好的数据卷。

以上面的为例，先创建centos01 里面有已经创建好的volume01和volume02的数据卷

然后创建centos02 从centos01中挂载已经创建好的这两个数据卷。

挂载好之后，无论在哪一个容器中修改数据卷中的内容，两个容器都会同步。即使将centos01容器删除，centos02容器中数据卷中的数据也不会丢失

```bash
# 使用以下命令进行挂载
# 而且可以有多个容器对centos01进行挂载，比如centos03
--volumes-from 表示centos02 从 centos01中挂载已经创建好的volume01和volume02数据卷

# docker run -it --name centos02 --volumes-from centos01 test/centos

```





#### Docker MySQL 

```shell
# 需要在Linux中将MySQL的端口在防火墙中开放。
firewall-cmd --add-port=3306/tcp --permanent
firewall-cmd --add-port=3310/tcp --permanent

-d	后台运行
-p	端口映射
-v	卷挂载，可以多个
--name	容器的名字
-e	环境配置
# MYSQL_ROOT_PASSWORD 初始化root的密码
docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123123 --name mysql01 mysql

# 1 先开启MySQL容器
# docker run -it tomcat /bin/bash  
# 然后在MySQL里面 执行以下操作
root@3eeba4e8cfee:/# mysql -u root -p 
查看 root的加密方式
mysql> select host,user,plugin,authentication_string from mysql.user;
+-----------+------------------+-----------------------+
| host      | user             | plugin                | 
+-----------+------------------+-----------------------+
| %         | root             | caching_sha2_password | 
| localhost | mysql.infoschema | caching_sha2_password | 
| localhost | mysql.session    | caching_sha2_password |
| localhost | mysql.sys        | caching_sha2_password |
| localhost | root             | caching_sha2_password | 
如果root的plugin显示是caching_sha2_password 那么就需要作如下的更改，'123123是代表MySQL的密码'
mysql> ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123123';
mysql> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123123';
然后远程就可以连接到本地的MySQL服务了
```

![image-20200711222503711](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/j7mgN8FfSoMXzqI.png)

3310是与MySQL端口号3306对应的

##### 多个MySQL实现数据共享

```bash
# 1. 先创建mysql01，然后将mysql01里面的conf.d和mysql设置成容器数据卷。

docker run -it -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123123 --name mysql01 

# 2. 然后创建mysql02，使用--volumes-from挂载到mysql01的容器数据卷，这样两个mysql之间就可以进行数据共享了
docker run -it -p 3311:3306 -e MYSQL_ROOT_PASSWORD=123123 --name mysql02 --volumes-from mysql01 mysql
```



#### DockerFile

> 以构建tomcat镜像为例

```bash
FROM centos # 以centos为基础

MAINTAINER banjo<mr.singledog@gmail.com> # 表明作者是谁

ADD jdk-8u251-linux-x64.tar.gz /usr/local 
ADD apache-tomcat-9.0.37.tar.gz /usr/local

RUN yum -y install vim # 镜像构建的时候需要运行的命令
RUN yum -y install net-tools

ENV MYPATH /usr/local # 构建镜像的时候设置环境变量

### VOLUME 表示挂载的目录

WORKDIR $MYPATH # 镜像的工作目录

ENV JAVA_HOME /usr/local/jdk1.8.0_251
ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.37
ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.37
ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin

EXPOSE 8080 # 需要开放的端口

CMD /usr/local/apache-tomcat-9.0.37/bin/startup.sh  # 指定容器启动的时候需要运行的命令

ENTRYPOINT #也是指定运行的命令
```

首先这些文件要在同一目录下，并且这个目录最好只有这些文件![image-20200712174104663](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712174104663.png)



然后进行构建，因为Dockerfile名是官方指定的，所以会直接找到

![image-20200712174153322](https://i.loli.net/2020/07/17/NRQxWZsT2e7Ir96.png)



现在就可以看到diytomcat镜像了![image-20200712174322428](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712221352651.png)



#### Docker 打包部署SpringBoot项目

> 在羡慕里的Maven，将项目打包

![image-20200712170007269](https://i.loli.net/2020/07/17/1FUXAt8pMcqGgvo.png)

> 如果打包成功，会在下图位置找到打包好了的jar包

![image-20200712170127230](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712170127230.png)

> 注意，MySQL的配置需要使用docker里面的MySQL配置。

![image-20200712221352651](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712221446247.png)



> 同时还需要一个Dockerfile文件，如下配置

![image-20200712221446247](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200713113733838.png)



然后将他们传输到远程服务器，并且使用docker进行build

```bash
-t 目标对象 叫blog
. 表示在当前目录
docker build -t blog .
```



#### IDEA 集成Docker

```bash
# 首先更改docker的service文件，开放端口。其中2375可以是其他的没被占用的端口

# vim /lib/systemd/system/docker.service
```

![image-20200713113733838](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711225525788.png)

```bash
# 重启docker服务
systemctl daemon-reload

# 然后重新加载配置文件 
systemctl restart docker.service

# 接着在Linux防火墙中开放2375端口
firewall-cmd --add-port=2375/tcp --permanent
firewall-cmd --reload

# 然后使用netstat -nlpt 查看2375是否开放
# 用下面的进行验证
curl http://localhost:2375/info
可以打印出来数据，表示成功
```

然后就可以在IDEA中进行连接

其中的URL是远程服务器的地址，端口是docker的端口

![image-20200713114258061](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200713114258061.png)



然后在service里面点击，就可以看到当前docker里面的容器和镜像

![image-20200713120710743](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200713120710743.png)

, description=The notes of docker , createTime=2020-08-05, updateTime=2021-02-25, category=Category{id=7, name='Docker'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=19, title=Linux Notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=23, content=#### 1. Mac连接虚拟机Linux

##### a. Mac terminal 下操作

在Linux的终端中输入ifconfig来查看ip，然后再在Mac的终端中如下操作

![image-20200708112812503](https://i.loli.net/2020/07/17/V7vLXODN2ipJ6bx.png)



会要求输入Linux的密码



##### b. 从Mac传输文件到Linux

使用FileZilla，通过连接。然后直接将Mac上的文件拖放到虚拟机的Linux上面即可![image-20200708114129842](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200708114129842.png)



==Linux一般没有输出就代表操作成功==



#### Linux 基本命令：

```bash
#可以使用 man + 命令  来查看相关的选项和参数

sync # 将数据由内存同步到硬盘中

shutdown # 关机指令

### 注意在关机前，先执行sync命令将数据保存到硬盘中

reboot # 重启

shutdown -r now # 系统立马重启

######文件操作命令########

ls：列出目录
ls -a：列出全部的文件
ls -l：列出文件，并且显示文件的属性和操作权限 
ls -al: Linux的命令可以合并使用，就是上面的功能的合并

cd + 路径：切换到指定路径
cd ..：切换到上一级
cd /：回到根目录

pwd：显示当前目录

mkdir + 目录名称：创建一个新的目录 
mkdir + 参数(-m 或 -p)：
# -m: 配置文件的权限！直接配置，不需要看默认权限
# -p: 帮助你直接将所需要的目录(包含上一级目录)递归创建起来！

#例子 -p
# mkdir test1/test2/ 如果没有test1的话，那么就会显示No such file or directory  
# 所以需要加上 mkdir -p test1/test2 这样的话，如果没有test1 那么就会创建test1，接着再创建test2.

#例子 -m
# mkdir -m 711 test2 为test2 创建权限

rmdir + 目录名称：删除指定的目录

cp：复制文件或者是目录
# 用法：cp source to destination
# 例子：cp test.txt  /home 将test.txt 文件复制到home路径

rm：删除文件或者目录 ##一定要谨慎使用
# 选项与参数：
# -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；
# -i ：互动模式，在删除前会询问使用者是否动作
# -r ：递归删除！最常用在目录的删除了！这是非常危险的选项！！！


mv：移动文件或者目录
#用法与cp复制文件类似
```

#### Linux 重要的文件目录

```bash
/bin：这个目录是存放着最常用的命令

/boot：存放的是启动Linux时使用的核心文件 ###不要动

/etc：用来存放所有的系统管理需要的配置文件和子目录

/home：用户的主目录

/lib：## 不要动

/lost+found：## 一般存在于云服务器

/opt： 给服务器安装额外的软件的目录，比如说安装的数据库就可以放在这个目录

/root：根目录

/sbin：存放着系统管理员使用的系统管理程序 ##不要动

/usr：##非常重要 用户的很多应用程序和文件都放在该目录下
 
```

#### Linux 文件的属性和权限

![image-20200708142059786](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/3JoYV8kn4pdgWOB.png)

>##### 通过==10个字符==来表示文件的种类和文件的权限

第一个字符：

- 当为[ **d** ]则是目录
- 当为[ **-** ]则是文件；
- 若是[ **l** ]则表示为链接文档 ( link file )；
- 若是[ **b** ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；
- 若是[ **c** ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。

后面9个字符，是每三个为一组，分别表示如下图

其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。

![image-20200708142437235](https://i.loli.net/2020/07/17/XozlwuD6ZILpKfC.png)



如果用=="-"==字符表示没有该权限；比如上图的第三格，表示有读和执行的权限，没有写的权限

#### 修改文件权限

> Linux文件属性有两种设置方法，一种是数字，一种是符号。

每种权限对应一个分数，如下

==read: 4  write: 2 execute:1==  缩写 ==r: 4 w:2 x:1==

> Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。

用对test.txt的权限操作举例：

- owner = rwx = 4+2+1 = 7
- group = rwx = 4+2+1 = 7
- others= --- = 0+0+0 = 0

chmod 770 test.txt 表示除了others组的用户，其余的都可以对该文件进行 读，写和执行的操作

#### 查看文件内容

>Linux 系统中使用以下命令来查看文件的内容

- cat 由第一行开始显示文件内容
- tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！
- nl  显示的时候，顺道输出行号！
- more 一页一页的显示文件内容
- less 与 more 类似，但是比 more 更好的是，他可以往前翻页！
- head 只看头几行
- tail 只看尾巴几行

####  vim基本操作

```bash
vim readme.txt // 第一次使用会创建这个readme.txt文件。第二次输入该命令，则是用于修改该文件

进入文件之后，按键盘 i 可以进行文字的输入。输入完毕之后 按键盘 ESC键进行退出 然后按键盘 : 就可以进入底部命令行模式。并且输入 wq就是保存并退出。

在输入模式下，按键盘 x 表示删除光标位置的字符

以上就是基本操作
```



, description=The basic knowledge of Linux, createTime=2020-07-10, updateTime=2021-02-25, category=Category{id=23, name='Linux'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=18, title=React notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=11, content=### React 基础学习

#### React的安装

1. Mac系统先安装node，直接官网下载安装。成功之后在命令行输入 node -v 或者 npm -v 出现版本号表示安装成功

2. 使用命令：npm install -g create-react-app 安装


出现上图问题，直接给该文件夹的permission进行放行即可: sudo chmod 777 /usr/local/lib/node_modules

```bash
需要进入到项目的文件夹
npm start 是用于开发环境
npm run start 也是用于开发环境
npm run build 是用于生成环境
```

#### 创建项目

create-react-app todolist. 通过这个 命令会在当前文件夹下面创建一个叫做todolist的React项目

> 项目名称不能包含大写字母，否则会报如下的错误

![image-20201012204028354](/Users/laughingli/Library/Application Support/typora-user-images/image-20201012204028354.png)

#### 工程目录介绍

<img src="/Users/laughingli/Library/Application Support/typora-user-images/image-20201012210605456.png" alt="image-20201012210605456" style="zoom:50%;" />

1. README.md：工程的说明文件，添加关于项目的一些说明
2. package.json：项目的介绍
3. .gitignore：将该文件中指定的文件或者目录不push到git 仓库
4. node_modules：是自动下载的第三方依赖
5. public目录里面的index.html：项目首页的模板
6. public目录里面的favicon.ico：项目的图标

src目录：是项目源代码存放的目录

1. index.js：是项目代码的入口文件。

   ```react
   import React from 'react';   // 文件中使用JSX语法，就必须需引入React
   import ReactDOM from 'react-dom';
   import App from './App';
   
   ReactDOM.render(
     <React.StrictMode>
       <App /> // 将App组件挂载到id为root的dom节点下
     </React.StrictMode>,
     document.getElementById('root')
   );
   
   
   ```

   

#### React中的组件

一个组件会有如下的特征：会extends Component

```react
import React, { Component } from 'react';

class App extends Component {
  render() {  // 一个组件就是页面的一部分内容，由render()这个方法进行渲染
    return( // return就是渲染的内容
      <div>
          hello World
      </div>
    )
  }
}
export default App;
```



#### JSX语法

```jsx
	class TodoList extends Component {
    render () {
        return (
          // 这种情况下，会报错。必须要有一个parent tag
            <div>
                <input /><button>点击</button>
            </div>
            <ul>
                <li>学音乐</li>
                <li>halo</li>
            </ul>
					// 要像下面一样，包裹一个parent tag才行
          <Fragment> // Fragment 需要单独引入，跟Component一样
          	<div>
                <input /><button>点击</button>
            </div>
            <ul>
                <li>学音乐</li>
                <li>halo</li>
            </ul>
          </Fragment>
        )
    }
}


```



#### React使用范例

> 父组件，与下面的子组件相结合理解

```react
import React, { Component, Fragment } from 'react';
import './style.css';
import TodoItem from './TodoItem';

class TodoList extends Component {

    // 构造函数：props是固定的
    constructor(props) {
        super(props); // 调用父类Component的构造函数
        this.state = { // this.state表示组件的状态，它可以用来存储各种数据
            inputValue: '', // inputValue用于接收输入信息
            list: []        // list用于存储输入信息
        }
        // 通过下面的方法，让各种方法指向TodoList
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleItemDelete = this.handleItemDelete.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
    }

    render() {
        return (
            <Fragment>
                <div>
                    {/* 将input与组件的inputValue进行绑定
                    这个input的值，由inputValue决定 */}
                    {/* onChange，当输入框发生变化的时候，
                    调用handleInputChange方法 */}
                    {/* bind(this),改变方法的this指向
                    让其指向组件 */}
                    <input
                        className='input'
                        value={this.state.inputValue}
                        onChange={this.handleInputChange}
                    />
                    {/* 用于当点击发生的时候，来调用对应的方法 */}
                    <button onClick={this.handleBtnClick}>点击</button>
                </div>
                <ul>
                    {
                        this.getTodoItem()
                    }
                </ul>
            </Fragment>

        )
    }

    // 用于显示TodoItem组件的处理结果
    getTodoItem() {
        // Each child in a list should have a unique "key" prop.
        // 需要return，处理之后的结果才能被调用显示
        return this.state.list.map((item, index) => {
            // 最好不要用index作为key值
            // 当点击对应的数据的时候，将其删除handleItemDelete
            // index 用于传递给delete方法对相应的index的数据进行处理
            return (
                <TodoItem
                    // 将input的值通过content传递给了子组件 TodoItem
                    // 将index的值通过index传递给了子组件 TodoItem
                    // 将handleItemDelete方法绑定到了子组件的deleteItem上，
                    // 这样当子组件调用deleteItem的时候，就是在调用父组件的handleItemDelete
                    key={index}
                    content={item}
                    index={index}
                    deleteItem={this.handleItemDelete}
                />
            )
        })
    }

    handleInputChange(e) {
        // 用this.setState的方式来修改里面的值
        this.setState({
            inputValue: e.target.value
        })
    }

    handleBtnClick(e) {
        this.setState({
            // ...this.state.list用于获取，本来该list中含有的数据
            list: [...this.state.list, this.state.inputValue],
            // 下面用于添加完成后，将input输入框清空
            inputValue: ''
        })
    }

    handleItemDelete(index) {
        //先复制一份list原来的值，因为不能对state的内容直接进行操作
        const list = [...this.state.list];
        // 删除下标是index的内容，删除1个
        list.splice(index, 1);
        this.setState({
            list: list
        })
    }


}

export default TodoList;
```

#### 如何引用CSS文件

```jsx
import './style.css'; // 首先在头部引用CSS文件

<input 
    className='input'  // 然后再在需要使用的地方引用具体的css，记住是className而不是class
    value={this.state.inputValue} 
    onChange={this.handleInputChange.bind(this)}
/>
```



#### 如何引入本地图片

```react
import lunbo from '../../../statics/lunbo.jpeg';

<img src={lunbo} alt=''/>
```



#### 组件之间的传值

> 子组件，与上面的父组件相结合来理解

```react
import React, { Component } from 'react';

class TodoItem extends Component {

    constructor(props) {
        super(props);
        // 让这个函数指向TodoItem
        this.handleClick = this.handleClick.bind(this);
    }

    render () {
        return (
            
        <div onClick={this.handleClick}>
            {/* 当点击子组件的每一项的时候，就会调用handleClick方法 */}
            {this.props.content}
        </div>
        )
    }

    handleClick() {
        // 调用deleteItem实际上是调用父组件的handleItemDelete方法
        // this.props.index，是指的对应要删除的每一项的下标
        this.props.deleteItem(this.props.index)
    }
}

export default TodoItem;
```



#### PropTypes和DefaultProps的应用

```react
// 为了做类型校验，需要引入PropTypes
import PropTypes from 'prop-types';

// 对TodoItem组件里的属性进行校验
TodoItem.propTypes = {
    // content的内容必须是string类型
    // 后面加上isRequired就表示必须要有输入值，否则会报错
    content: PropTypes.string.isRequired,

    // deleteItem传入的内容必须是一个函数
    deleteItem: PropTypes.func,

    // index传入的内容必须是number或者是string类型
    index: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
}
export default TodoItem;
```



#### Props，State与render函数

> 当组件的state或者是props发生改变的时候，render函数就会重新执行
>
> 当父组件的render函数被运行时，子组件的render函数也会重新执行



#### 生命周期函数

> 生命周期函数：指在某一个时刻组件会自动执行的函数
>
> 举例：React的render函数，当组件的state或者props发生改变的时候，render函数就会自动执行。这就是生命周期函数

```react
componentWillMount() { 
   //已经弃用。它的意思是在组件第一次挂载之前执行。 也就是组件第一次被渲染到页面的时候
        console.log('will mount')
    }

componentDidMount() { // 在组件第一次挂载之后会执行
        console.log('did mount')
    }

// 在组件的内容更新之前会自动被执行，会返回true或者false
// 无论返回true或者false，shouldComponentUpdate都会被执行
// 但是，如果是true则表示执行更新，如果是false则表示不执行更新。
shouldComponentUpdate() {
        console.log('should ?')
        return true
    }

// 在shouldComponentUpdate()返回了true之后才会被执行，它是在组件完成更新之前被执行
// Warning: componentWillUpdate has been renamed, and is not recommended for use. 弃用
componentWillUpdate() {
        console.log('componentWillUpdate')
    }

// 也是在shouldComponentUpdate()返回了true之后才会被执行。它是在组件完成更新之后被执行
componentDidUpdate() {
        console.log('componentDidUpdate')
    }

// Warning: componentWillReceiveProps has been renamed, 
// and is not recommended for use. 弃用
componentWillReceiveProps() {
        console.log('componentWillReceiveProps')
    }
```

####  生命周期函数使用场景

```react
// 举例，父组件中引用了子组件。如果父组件的render函数被执行了，那么子组件的render函数也会被执行。
// 这在有的时候就会带来性能上的损失，因为子组件不需要随时都被执行

// 在子组件的render函数之前添加该生命周期函数
shouldComponentUpdate(nextProps, nextState, nextContext) {
  			// 如果接下来的content内容不等于当前content的内容，那么子组件的render函数才会被执行
        return nextProps.content !== this.props.content;
    }
```

#### React使用ajax

```react
// 首先要安装对应的包，从命令行进入到工程项目 然后安装
npm install axios 
// 安装完成后
// 在需要使用到ajax的地方引入即可，下面是举例使用
import axios from "axios";

// ajax的使用，就是在componentDidMount这个生命周期函数之中：因为它只会执行一次
componentDidMount() {
        axios.get('/api/todolist')
            .then(() => {alert('success')})
            .catch(() => {alert('failed')})
    }

```



#### React Router

> router安装

```bash
npm install react-router-dom 进行安装
```



> router的使用

```react
import React, { Component } from 'react';
import Header from './common/header/header.js';
import { Provider } from 'react-redux';
import store from "./common/header/redux/store";

// 先将需要的页面编辑好，然后引入
import Home from './home/index';
import Detail from './Detail/index';
// 引入路由'BrowserRouter'和路由规则'Route'
import { BrowserRouter, Route } from 'react-router-dom';

function App() {
  return (
      <Provider store={store}>
          {/* BrowserRouter标签代表路由 */}
          <BrowserRouter>
              {/* Route代表路由规则，exact 表示路由必须完全相同才能够渲染
               路由完全相同的意思：http://localhost:3000/detail，因为这个URL里面也包含
               根目录，如果不加exact，那么下面的两个路由规则都会显示。加上exact的话，就只显示
               detail的
               */}
            	{/* 直接使用Component={} 来将其添加到路由 */}
              <Route path='/' exact Component={ Home }></Route>
              <Route path='/detail' Component={ Detail }></Route>
          </BrowserRouter>
          <Header />
      </Provider>
  );
}

export default App;
```



#### 安装Immutable.JS 

```bash
npm install immutable
```



### Redux 学习

#### Redux的工作流程

> 类比图书馆借书的过程

<img src="/Users/laughingli/Library/Application Support/typora-user-images/image-20201017094121868.png" alt="image-20201017094121868" style="zoom: 25%;" />

1. React Components 代表一个借书的用户
2. Action Creators 代表一个用户具体要借什么书这一个指令
3. Store 代表图书管的管理员。数据管理的仓库
4. Reducers 代表整个图书馆的数据库，记录了每一本书的基本信息和存放位置



#### Chrome 安装 Redux DevTools

1. 首先在Chrome的extensions商店搜索 Redux DevTools

2. ```react
   // 然后再在react的store文件里面添加如下一行代码
   // window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
   const store = createStore(reducer,
       window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
   ```

3. 然后就可以在Chrome里面点击Redux DevTools进行调试

####  安装Ant Design

```bash
// 首先在命令行中进入工程目录，然后执行下面的语句
npm install antd --save
```

#### 安装Redux

```bash
// 首先在命令行中进入工程目录，然后执行下面的语句
npm install redux
```

#### redux的使用范例

##### 第一步：创建reducer

```react
const defaultState = {
    inputValue: '123',
    list: ['1', '2']
}

// state 指的是整个store仓库里面存储的数据。这里给了一个初始化的数据 defaultState
export default (state = defaultState, action) => {
    // 根据action的type来进行判断，然后进行操作
    if (action.type === 'change input value') {
        // 先拷贝之前state里面原有的数据，因为react不推荐直接操作state
        const newState = JSON.parse(JSON.stringify(state));
        // 然后将action传递来的value复制到newState的inputValue
        newState.inputValue = action.value;
        // 会将newState返回给store，store会将newState替换掉老的state
        return newState;
    }

    if (action.type === 'add todo item') {
        // 先拷贝之前state里面原有的数据，因为react不推荐直接操作state
        const newState = JSON.parse(JSON.stringify(state));
        newState.list.push(newState.inputValue);
        newState.inputValue = '';
        return newState;
    }

    if (action.type === 'delete todo item') {
        // 先拷贝之前state里面原有的数据，因为react不推荐直接操作state
        const newState = JSON.parse(JSON.stringify(state));
        newState.list.splice(action.index, 1);
        return newState;
    }
    return state;
}
```

##### 第二步：创建store

```react
import { createStore } from 'redux';
// 将reducer引入store
import reducer from "./reducer";

// 根据reducer来创建store
const store = createStore(reducer,
                         window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());

export default store;
```

##### 第三步：将store引入到需要用到的Component组件当中

```react
import React, { Component, Fragment } from "react";
import 'antd/dist/antd.css';
import { Input, List } from 'antd';
// 将store引入到组件
import store from "./store";

class TodoList extends Component {

    constructor(props) {
        super(props);

        // 将数据仓库里的数据赋值给该组件的state，第一次挂载的时候
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        // 让store订阅handleStoreChange方法，只有这个方法发生变动，那么
        // store就会产生相应的变化
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return(
            <Fragment>
                {/* 上下左右有10px的边距 */}
                <div style={{margin: '10px 10px'}}>
                    <Input value={this.state.inputValue}
                           placeholder='todo list'
                           style={{width: '300px', marginRight: '5px'}}
                           onChange={this.handleInputChange}
                    />
                    <button onClick={this.handleBtnClick}>提交</button>

                    {/* 在渲染的时候会有一个index来表示该item的下标 */}
                    {/* 将index传递给handleDelete方法 */}
                    <List style={{width: '300px'}}
                          size="large"
                          bordered
                          dataSource={this.state.list}

                          renderItem={(item, index) => <List.Item onClick={this.handleDelete.bind(this, index)}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }

    handleInputChange(e) {
        const action = {
            // 创建一个action，其中的type是固定的，用于描述该动作
            type: 'change input value',
            value: e.target.value
        }
        // 通过dispatch将action传递给store
        store.dispatch(action);
    }

    // 将store的state替换掉TodoList这个组件的state，这样就可以随时渲染更新
    handleStoreChange() {
        this.setState(store.getState());
    }

    // 当点击按钮的时候，会触发的方法
    handleBtnClick() {
        const action = {
            type: 'add todo item',
        }
        store.dispatch(action);
    }

    // 这个方法接收一个index参数，index是对应item的下标
    handleDelete(index) {
        const action = {
            type: 'delete todo item',
            index
        }
        store.dispatch(action);
    }
}

export default TodoList;
```

##### 

#### UI组件和容器组件

> 是将渲染页面的语句和逻辑语句拆分开

##### 初始组件

```react
import React, { Component, Fragment } from "react";
import 'antd/dist/antd.css';
import { Input, List } from 'antd';
// 将store引入到组件
import store from "./store";

class TodoList extends Component {

    constructor(props) {
        super(props);

        // 将数据仓库里的数据赋值给该组件的state，第一次挂载的时候
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        // 让store订阅handleStoreChange方法，只有这个方法发生变动，那么
        // store就会产生相应的变化
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return(
            <Fragment>
                {/* 上下左右有10px的边距 */}
                <div style={{margin: '10px 10px'}}>
                    <Input value={this.state.inputValue}
                           placeholder='todo list'
                           style={{width: '300px', marginRight: '5px'}}
                           onChange={this.handleInputChange}
                    />
                    <button onClick={this.handleBtnClick}>提交</button>

                    {/* 在渲染的时候会有一个index来表示该item的下标 */}
                    {/* 将index传递给handleDelete方法 */}
                    <List style={{width: '300px'}}
                          size="large"
                          bordered
                          dataSource={this.state.list}

                          renderItem={(item, index) => <List.Item onClick={this.handleDelete.bind(this, index)}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }

    handleInputChange(e) {
        const action = {
            // 创建一个action，其中的type是固定的，用于描述该动作
            type: 'change input value',
            value: e.target.value
        }
        // 通过dispatch将action传递给store
        store.dispatch(action);
    }

    // 将store的state替换掉TodoList这个组件的state，这样就可以随时渲染更新
    handleStoreChange() {
        this.setState(store.getState());
    }

    // 当点击按钮的时候，会触发的方法
    handleBtnClick() {
        const action = {
            type: 'add todo item',
        }
        store.dispatch(action);
    }

    // 这个方法接收一个index参数，index是对应item的下标
    handleDelete(index) {
        const action = {
            type: 'delete todo item',
            index
        }
        store.dispatch(action);
    }
}

export default TodoList;

```



##### 拆分后的UI组件

```react
import React, { Component, Fragment } from "react";
import {Input, List} from "antd";

class TodoListUI extends Component {
    render() {
        return (
            <Fragment>
                <div style={{margin: '10px 10px'}}>
                    <Input
                        value={this.props.inputValue}
                        placeholder="Hello World"
                        style={{width: '300px', marginRight: '5px'}}
                        onChange={this.props.handleInputChange}
                    />
                    <button onClick={this.props.handleBtnClick}>点击</button>
                    <List
                        style={{width: '300px', marginTop: '10px'}}
                        size="small"
                        bordered
                        dataSource={this.props.list}
                        renderItem={(item, index) => <List.Item onClick={() => {this.props.deleteItem(index)}}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }
}

export default TodoListUI;
```



##### 拆分后的容器组件

```react
import React, { Component, Fragment } from "react";
import "antd/dist/antd.css"
import store from "./store";
import TodoListUI from './TodoListUI';

// 将所有的action抽取出来，放到一个叫做actionTypes的文件中
import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM } from "./actionTypes";

class TodoList extends Component {

    constructor(props) {
        super(props);
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.deleteItem = this.deleteItem.bind(this)
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return <TodoListUI
        // 将组件的各种状态传递给子组件        
        inputValue = {this.state.inputValue}
        list = {this.state.list}
        handleInputChange = {this.handleInputChange}
        handleBtnClick = {this.handleBtnClick}
        deleteItem = {this.deleteItem}
        handStoreChange = {this.handleStoreChange}
        />
    }

    handleInputChange(e) {
        const action = {
            type: CHANGE_INPUT_VALUE,
            value: e.target.value
        }
        store.dispatch(action);
    }

    handleBtnClick() {
        const action = {
            type: ADD_TODO_ITEM,
        }
        store.dispatch(action);
    }

    handleStoreChange() {
        this.setState(store.getState());
    }

    deleteItem(index) {
        const action = {
            type: DELETE_TODO_ITEM,
            index
        }
        store.dispatch(action);
    }
}

export default TodoList;
```

### Redux 中间件

#### redux-thunk

> redux-thunk的安装
>
> 它可以将异步操作从组建中移除，然后发到action文件当中去

```bash
npm install redux-thunk
```

> redux-thunk中间件的使用
>
> 它主要是在创建store的时候被引用

```react
// thunk和saga它们都是中间件，如果要使用，首先需要引入applyMiddleware
import {createStore, applyMiddleware, compose} from "redux";
// 然后再引入对应的中间件，这里是thunk
import thunk from "redux-thunk";
import reducer from "./reducer";

// 如果要同时使用redux的devtools和其他的中间件，那么就需要像下面一样来写。
// 因为redux devtools也是一个中间件
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
    //    compose需要从redux中引入
    }) : compose;

const enhancer = composeEnhancers(applyMiddleware(thunk))

const store = createStore(reducer, enhancer)

export default store;
```

> actionCreators 文件

```react
// 这里是返回的一个对象
export const getDeleteItemAction = (index) => ({
    type: DELETE_TODO_ITEM,
    index
})

export const getInitItemAction = (data) => ({
    type: INIT_LIST_ITEM,
    data
});

// 这里是返回的一个函数，运用到了react-thunk。如果没有它，那么久不能返回一个函数
export const getTodoList = () => {
    return (dispatch) => {
        axios.get('https://run.mocky.io/v3/06315b0b-6c7f-49c3-9e51-94e3a35da33b')
            .then((res) => {
                const data =res.data;
                dispatch(getInitItemAction(data));
            })
            .catch(() => {console.log('failed')})
    }
}
```





### react-redux 学习

> 安装react-redux

```bash
进入到工程目录
npm install react-redux
```

#### react-redux 使用范例

##### index.js 

```react
import React from 'react';
import ReactDOM from 'react-dom';
import TodoList from "./TodoList";
import store from "./store";
// react-redux 提供的核心API
import { Provider } from 'react-redux';

const App = (
    // Provider组件，由react-redux提供。
    // Provider的store属性的值，就是整个store数据仓库的值。
    // 这样，只要是在Provider下面的组件，例如TodoList组件
    // 都可以获取到store里面的内容
    <Provider store={store}>
        <TodoList />
    </Provider>
);

ReactDOM.render(
  <React.StrictMode>
    {/* 然后将App组件传给ReactDOM.render进行渲染 */}
      {App}
  </React.StrictMode>,
  document.getElementById('root')
);
```



##### store.js 和 reducer.js 页面不需要作改变

##### TodoList.js 组件

```react
import React, { Component, Fragment } from "react";
// react-redux 提供的核心API
import { connect } from 'react-redux';
import 'antd/dist/antd.css';
import { Input, List } from 'antd';

class TodoList extends Component {

    render() {
        return(
            <Fragment>
                <div style={{margin: '10px 10px'}}>
                    <Input
                        style={{width: '300px'}}
                        placeholder='todo list'
                        value={this.props.inputValue}
                        onChange={this.props.changeInputValue}
                    />
                    <button
                        style={{marginLeft: '5px'}}
                        onClick={this.props.handleBtnClick}
                    >提交</button>

                    <List style={{width: '300px', marginTop: '10px'}}
                          size="large"
                          bordered
                          dataSource={this.props.list}
                          renderItem={(item, index) => <List.Item onClick={this.props.deleteItem.bind(this, index)}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }
}

// 这个函数是用来将store里面的state传递给子组件的props
// 这里是传递给TodoList
const mapStateToProps = (state) => {
    return {
        // 让子组件的inputValue和store里面的inputValue产生关联
        inputValue: state.inputValue,
        // 让子组件的list和store里面的list产生关联
        list: state.list
    }
}

// 将store的 dispatch方法挂载到 props上
// 这个函数是用来，将修改后的子组件state中的数据返回给store
// 让store来更改修改过后的数据
const mapDispatchToProps = (dispatch) => {
    return {
        changeInputValue(e) {
            const action = {
                type: 'change input value',
                value: e.target.value
            }
            dispatch(action);
        },
        handleBtnClick() {
            const action = {
                type: 'add todo item'
            }
            dispatch(action);
        },
        deleteItem(index) {
            const action = {
                type: 'delete todo item',
                index
            }
            dispatch(action);
        }
    }
}

// 这里的意思是，让TodoList组件与store进行连接
export default connect(mapStateToProps, mapDispatchToProps)(TodoList);
```



### react 使用styled-components

> 运用styled-components来对react项目的css文件进行管理

将css放入一个叫style.js的文件中。

```react
import { createGlobalStyle } from 'styled-components';

export const GlobalStyle = createGlobalStyle`
  body{
    marigin: 0;
    padding: 0;
    background: green;
  }
`
```

然后再将其引入到需要使用这个css的组件当中

```react
import React from 'react';
// 引入css
import { GlobalStyle } from "./style";

function App() {
  return (
    <p style={{margin: "10px 10px"}}>
      // 使用css
      <GlobalStyle/>
      Hello World
    </p>
  );
}

export default App;

```

### React 过程中的坑

> 当运用了combineReducers这个组件之后，遇到的问题

整合的reducer文件

```react
import { combineReducers } from "redux";
import reducerHeader from "../header/redux/reducer";

export default combineReducers({
    header: reducerHeader
})
```



对应的组件当中就必须如下写。因为是拆分的，所以要带上其对应的header。以此类推

```react
const mapStateToProps = (state) => {
    return {
        // 将store里面存储的信息传递给子组件，也就是这里的Header组件
        focused: state.header.get('focused'),
        hotList: state.header.get('hotList'),
        totalPage: state.header.get('totalPage'),
        page: state.header.get('page'),
        mouseIn: state.header.get('mouseIn')
    }
}
```

### Component 和 PureComponent

Component：只要项目store里面的数据发生了变化，那么每一个组件就会被重新的渲染。这样就会造成性能的降低。为了避免这样的情况，可以在组件中使用shouldComponentUpdate()这个生命周期函数。通过这个函数来判断，store里面的数据更改是否和当下的组件相关。如果不相关的话，就不重新渲染



PureComponent：react底层帮助实现了上面的功能。但是需要配合immutable.js使用，否则会出现不可预测的问题



### 异步组件/withRouter路由使用

, description=React Study, createTime=2020-07-02, updateTime=2021-02-25, category=Category{id=25, name='React'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0)], isHasContent=true, first=true, last=false, isHasNext=true, isHasPrevious=false))
2021-03-25 18:17:43.162  INFO 36287 --- [http-nio-8080-exec-2] com.banjo.blogvue.aspect.LogAspect       : Request: RequestLog{url='http://localhost:8080/blog', ip='0:0:0:0:0:0:0:1', classMethod='com.banjo.blogvue.controller.admin.AdminPageController.listBlogs', args=[]}
2021-03-25 18:17:43.167  INFO 36287 --- [http-nio-8080-exec-2] com.banjo.blogvue.aspect.LogAspect       : Result: admin/listBlogs
2021-03-25 18:17:43.583  INFO 36287 --- [http-nio-8080-exec-2] com.banjo.blogvue.aspect.LogAspect       : Request: RequestLog{url='http://localhost:8080/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.banjo.blogvue.controller.admin.BlogController.list', args=[0, 4]}
2021-03-25 18:17:43.609  INFO 36287 --- [http-nio-8080-exec-2] com.banjo.blogvue.aspect.LogAspect       : Result: Result(code=0, message=, data=Page4Navigator(pageFromJPA=Page 1 of 2 containing com.banjo.blogvue.pojo.Blog instances, navigatePages=0, navigatePageNums=null, totalPages=2, number=0, totalElements=7, size=4, numberOfElements=4, content=[Blog(id=23, title=AWS Cloud, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Translation, views=11, content=#### 卸载自带jdk

```bash
# 先使用以下命令 查看当前的jdk
rpm -qa|grep jdk
java-1.7.0-openjdk-1.7.0.261-2.6.22.1.83.amzn1.x86_64
copy-jdk-configs-3.3-10.3.amzn1.noarch

# 然后根据对应版本的jdk 直接用下面的命令删除
sudo rpm -e --nodeps java-1.7.0-openjdk-1.7.0.261-2.6.22.1.83.amzn1.x86_64

# 然后使用yum下载jdk，使用下面的命令查看java可选版本
$ yum -y list java*

# 然后根据版本号，直接下载
sudo yum install -y java-1.8.0-openjdk-devel.x86_64
```



#### FileZilla 连接 AWS

1. 打开 FileZilla 的 "Edit" -> "Settings" 对话框，在左边的“选择页面” 选择“SFTP”， 右边点击 “添加密钥文件...” 按钮，导入Amazon给的密钥文件 

   ![image-20200713163800225](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/7gZEBIRuMvdbPli.png)

2. 打开File选择Site Manager

   Protocol中选择SFTP

   Host选择 公有DNS![image-20200713163956246](https://i.loli.net/2020/07/17/9fIEBSrGNMzgoLu.png)

![image-20200713163918562](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/OQzkdvYoGqKLs5B.png)

然后选择Interactive的方式登录，用户是ec2-user

或者选择key的方式都可以

然后就能连接成功

> 连接成功之后需要将一个用于接收上传文件的文件夹进行权限修改

如下：

![image-20200713170334089](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/TNozpkPF8OgeJyM.png)



#### 安装docker

```bash
# 先查看版本 
yum -y list docker*
# 然后根据版本来下载
sudo yum install -y docker.x86_64

# 下载之后需要启动Docker服务
sudo service docker start

# 然后将ec2-user添加到docker组，否则不能执行Docker命令
sudo usermod -a -G docker ec2-user

# 然后重启AWS实例，就可以开启docker服务了
```



#### Docker vim命令

```bash
首先进入容器，然后执行
 apt-get update
 
 然后执行
 apt-get install vim
```

#### AWS 安全组

```bash
# 1. 如果tomcat开启的端口是8080，那么就需要在AWS的安全组里面放行对8080端口的访问，同时还要对9001端口进行开放

docker run -d -p 9001:8080 tomcat

其他的服务如果需要使用其他的端口，那么也用相同的方法进行放行

下面以MySQL的连接为例，3310和3306都需要在安全组里面进行放行。

 mysql          "docker-entrypoint.s…"   17 hours ago        Up 17 hours         33060/tcp, 0.0.0.0:3310->3306/tcp   mysql01
```



![image-20200714180816580](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/ysLFVnza2wGp9E6.png)



#### IDEA 连接 AWS 上的docker

1. 首先修改docker需要监听的IP和端口

```bash
   1. 首先关闭docker服务
   sudo service docker stop
   2. 然后修改docker 服务端监听的端口和ip
   sudo dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375
   3. 然后启动docker服务
   sudo service docker start
   4. 然后修改客户端的
   docker -H tcp://0.0.0.0:2375 ps
   没有输出就表示成功。
   
   
   
   ```

2. 然后再aws里面的安全组里将2375端口进行放行

3. 然后再利用IDEA对docker进行远程连接即可

> 以systemd的方式连接

```bash
1. 先找到这个文件
/lib/systemd/system/docker.service

然后注释掉下面的
ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock $OPTIONS $DOCKER_STORAGE_OPTIONS $DOCKER_ADD_RUNTIMES

然后再添加
ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock
这样远程就能通过2375端口访问到了
```

#### AWS ec2 安装MySQL

```bash
# 先查看是否有旧版本MySQL
rpm -qa | grep -i mysql

# 如果有的话，使用下面的命令将其全部删除
sudo rpm -ev 加mysql的文件名


# 下载并进入到下载好的文件夹
 wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.17-linux-glibc2.12-x86_64.tar.xz
 # 解压下载的压缩包
 tar xvf mysql-8.0.17-linux-glibc2.12-x86_64.tar.xz
 
 # 将解压好的复制到/usr/local目录下并且重命名为mysql
 sudo mv mysql-8.0.17-linux-glibc2.12-x86_64 /usr/local/mysql
 
 # 进入到mysql目录，然后创建一个data文件夹，用于存放数据
 mkdir data
 
 # 创建mysql用户组和mysql用户
 sudo groupadd mysql
 sudo useradd -g mysql mysql
 
 # 改变mysql目录权限 注意后面都有一个点
 sudo chown -R mysql .
 sudo chgrp -R mysql .
 
 # 创建mysql_install_db安装文件，并且修改权限
sudo mkdir mysql_install_db
sudo chmod 777 ./mysql_install_db

# 初始化
sudo bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data
# 一定要记住临时密码
A temporary password is generated for root@localhost: 

# mysql配置，将support-files下的移动到init.d目录下，并且重命名，两个都要
sudo cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld
sudo cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql
# 修改或者创建my.cnf文件，并且加入下面的命令

[mysqld]
    basedir = /usr/local/mysql
    datadir = /usr/local/mysql/data
    socket = /usr/local/mysql/mysql.sock
    character-set-server=utf8
    port = 3306
   sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
 [client]
   socket = /usr/local/mysql/mysql.sock
   default-character-set=utf8
   
# 建立MySQL服务
sudo chmod +x /etc/init.d/mysqld
sudo chmod +x /etc/init.d/mysql
# 添加到系统服务
sudo chkconfig --add mysqld
sudo chkconfig --add mysql
#配置全局环境变量

先设置 /etc/profile文件的权限，可以读写
sudo /etc/profile chmod 777
然后再在里面添加以下配置
export PATH=$PATH:/usr/local/mysql/bin:/usr/local/mysql/lib
export PATH

# 设置环境变量立即生效
source /etc/profile

# 启动MySQL服务

sudo service mysql start

# 登录MySQL
mysql -u root -p 回车
输入上面的临时密码即可

# 修改初始密码
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY'自己的密码';

# 设置远程可登录
进入mysql
1. use mysql
2. update user set host='%' where user='root' limit 1;
3. flush privileges; # 刷新权限

然后就可以进行远程登录
```

, description=Learn how to set up a clear AWS cloud, createTime=2021-02-17, updateTime=2021-02-25, category=Category{id=17, name='AWS Cloud'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=21, title=Docker Notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=14, content=#### Linux 安装 docker

```bash
# 1. 首先用下面的命令卸载旧版本，如果有的话
sudo yum remove docker \ 
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
                  
# 2. 安装依赖包
sudo yum install -y yum-utils        

# 3. 设置镜像仓库
sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo

# 4. 安装docker引擎
sudo yum install docker-ce docker-ce-cli containerd.io

# 5. 启动docker 和重启
sudo systemctl start docker
sudo systemctl restart docker

# 6. 测试是否启动成功
sudo docker run hello-world

# 7. 卸载依赖和删除资源
sudo yum remove docker-ce docker-ce-cli containerd.io
sudo rm -rf /var/lib/docker
```



docker run hello-world的流程图

1. docker会在本地仓库寻找hello-world的镜像，找到就运行。
2. 没找到，docker client就会跟 docker daemon联系，然后下载hello-world镜像到本地
3. 下载到本地之后，再运行该镜像。

 ![image-20200710230333325](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200710230333325.png)![image-20200710230221724](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200710230221724.png)



#### Docker 常用命令

##### 帮助命令

```shell
docker version # 查看docker信息
docker info		 # 查看docker系统信息，包括有多少镜像和容器
docker --help  # 帮助命令
```



##### 镜像命令

> 查看镜像

```bash
docker images  # 查看当前主机上的所有镜像
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              bf756fb1ae65        6 months ago        13.3kB

# docker images 命令的可选性
-a, --all 	# 列出所有的镜像跟默认的docker images一样
-q, --quit	# 只显示镜像的id,-q 和 --quit一样

[root@localhost ~]# docker images --quiet
bf756fb1ae65

[root@localhost ~]# docker images -q
bf756fb1ae65

docker search mysql 搜索mysql的镜像 #镜像的搜索
```

> 搜索镜像

```bash
docker search mysql 搜索mysql的镜像 #镜像的搜索
# 只需要添加想要的镜像的名称，就可以进行搜索。
[root@localhost ~]# docker search mysql
NAME                              DESCRIPTION                                     STARS               
mysql                             MySQL is a widely used, open-source relation…   9718
```

> 下载镜像

```bash
docker pull mysql  # 下载mysql

[root@localhost ~]# docker pull mysql
Using default tag: latest #如果不指定tag，就默认下载最新版本
latest: Pulling from library/mysql
8559a31e96f4: Pull complete	# 分层下载， docker images的核心 联合文件系统
d51ce1c2e575: Pull complete	# 好处：举例--如果要更新到更新版本的MySQL，那么下次执行pull的
c2344adc4858: Pull complete	# 时候只需要下载被更新的部分，其余没更新的不会被重复下载
fcf3ceff18fc: Pull complete
16da0c38dc5b: Pull complete
b905d1797e97: Pull complete
4b50d1c6b05c: Pull complete
c75914a65ca2: Pull complete
1ae8042bdd09: Pull complete
453ac13c00a3: Pull complete
9e680cd72f08: Pull complete
a6b5dc864b6c: Pull complete
Digest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest # 这里是真实的mysql的地址

docker pull mysql 等价于  docker pull docker.io/library/mysql:lastest
```



> 删除镜像

```bash
docker rmi -f 加上(镜像的id) 

[root@localhost ~]# docker rmi -f bf756fb1ae65
Untagged: hello-world:latest
Untagged: hello-world@sha256:d58e752213a51785838f9eed2b7a498ffa1cb3aa7f946dda11af39286c3db9a9
Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b

##或者 docker rmi -f 加上(镜像的repository名称) 
docker rmi -f hello-world

[root@localhost ~]# docker rmi -f hello-world
Untagged: hello-world:latest
Untagged: hello-world@sha256:d58e752213a51785838f9eed2b7a498ffa1cb3aa7f946dda11af39286c3db9a9
Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b

```



##### 容器命令

> 先有镜像，才能创建容器。以下用docker下载centos来进行举例学习

> 新建容器并启动

```bash
# -it 表示使用交互方式运行，进入容器查看内容
[root@localhost ~]# docker run -it centos /bin/bash  
									# docker run -d centos   表示后台启动容器
[root@f72fb12d27fc /]# ls  这里表示已经进入到了centos这个容器当中
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

[root@f72fb12d27fc /]# exit  退出并且停止容器
exit
[root@localhost ~]#

删除所有容器
docker rm $(docker ps -aq)
```

> 查看运行和曾经运行过的容器

```bash
[root@localhost ~]# docker ps -a 表示查看当前在运行的和曾经运行过的容器
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
f72fb12d27fc        centos              "/bin/bash"         3 minutes ago       Exited (0) 2 minutes ago                       hopeful_mcnulty
3af87bce0732        bf756fb1ae65        "/hello"            12 hours ago        Exited (0) 12 hours ago                        lucid_sammet
b22be932b11a        bf756fb1ae65        "/hello"            12 hours ago        Exited (0) 12 hours ago                        vigorous_chaplygin
[root@localhost ~]# docker ps  表示查看正在运行的容器
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
[root@localhost ~]#

```

> 启动，停止，重启容器

```shell
docker start 容器id
docker restart 容器id
docker stop 容器id
docker kill 容器id #强制停止当前容器
```

> 退出容器

```bash
exit 表示退出且停止容器运行

Ctrl + P + Q #不停止容器运行，只退出容器

[root@f4b87ffb286b /]# [root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
f4b87ffb286b        centos              "/bin/bash"         13 seconds ago      Up 11 seconds                           laughing_darwin
[root@localhost ~]#

```



> 进入在运行的指定容器

```shell
docker exec -it 容器名 /bin/bash

[root@localhost ~]# docker exec -it 0f45f1d47525 /bin/bash
[root@0f45f1d47525 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

docker attach 容器名

[root@localhost ~]# docker attach 0f45f1d47525
[root@0f45f1d47525 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

###区别
docker exec			# 进入容器后开启一个新的终端，可以在里面操作(这个是常用的)。
docker attach		# 进入容器正在执行的终端，不会启动新的进程。

```



> 删除容器

```bash
docker rm 容器id
```

> 列出所有容器

```bash
docker container ls
```



> 日志打印

```bash
docker logs --tail 10 0f45f1d47525  
--tail 表示以字符串的形式打印，10是--tail的参数，打印10行。最后跟的是容器的id
```

> 查看容器进程信息

```bash
docker top 容器id
[root@localhost ~]# docker top 0f45f1d47525
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                13539               13521               0                   18:08               pts/0               00:00:00            /bin/bash
```

> 查看容器元数据(所有数据)

```bash
[root@localhost ~]# docker inspect 0f45f1d47525（容器id）
```



> 从容器中复制文件到主机

```bash
[root@6ad773845eab /]# cd home  开启容器 进入到home目录
[root@6ad773845eab home]# touch test.java	在home目录创建test.java文件
[root@6ad773845eab home]# ls
test.java
[root@6ad773845eab home]# exit 退出即可
exit
[root@localhost ~]# ls 当前文件夹下是没有test.java文件
anaconda-ks.cfg  Desktop  Documents  Downloads  Music  original-ks.cfg  Pictures  Public  study.txt  Templates  Videos  

# 将6ad773845eab:/home/test.java  将这个容器的home目录中的test.java文件复制到
# ~目录。
[root@localhost ~]# docker cp 6ad773845eab:/home/test.java ~
[root@localhost ~]# ls
anaconda-ks.cfg  Desktop  Documents  Downloads  Music  original-ks.cfg  Pictures  Public  study.txt  Templates  test.java  Videos
[root@localhost ~]#
```



#### Docker Nginx

##### 启动并验证Nginx

```bash
-d 表示后台运行
--name nginx01表示它的名字
-p 8082:80 #8082表示客户端访问的请求的端口，80表示本地与之对应的端口。
就是客户端访问8082端口会拿到本地80端口的数据

[root@localhost ~]# docker run -d --name nginx01 -p 8082:80 nginx
f0a1f169564a7c8faacb1aa73cae06449267e5b39493a05196086823b69f8972
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
f0a1f169564a        nginx               "/docker-entrypoint.…"   4 seconds ago       Up 3 seconds        0.0.0.0:8082->80/tcp   nginx01
6ad773845eab        centos              "/bin/bash"              56 minutes ago      Up 51 minutes                              elastic_mestorf
[root@localhost ~]# curl localhost:8082  验证是否能够访问成功
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
Nginx在docker里面的配置文件在 /etc/nginx路径下面
```



#### Docker Tomcat

```bash
# tomcat 的启动跟Nginx相似
也是要设置端口的映射。才能进行访问
[root@localhost ~]# docker run -d -p 9001:8080 tomcat
4126cf694a054e44dfa27a059da130ff8201d427b0e1aeeafb57a986f8fa8667
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
4126cf694a05        tomcat              "catalina.sh run"        4 seconds ago       Up 3 seconds        0.0.0.0:9001->8080/tcp   loving_bell
f0a1f169564a        nginx               "/docker-entrypoint.…"   27 minutes ago      Up 27 minutes       0.0.0.0:8082->80/tcp     nginx01
6ad773845eab        centos              "/bin/bash"              About an hour ago   Up About an hour                             elastic_mestorf

## 返回404 表示能够访问，但是当前的Tomcat里面还缺少可用于访问的文件
[root@localhost ~]# curl localhost:9001
<!doctype html><html lang="en"><head><title>HTTP Status 404 – Not Found</title><style type="text/css">body {font-family:Tahoma,Arial,sans-serif;} h1, h2, h3, b {color:white;background-color:#525D76;} h1 {font-size:22px;} h2 {font-size:16px;} h3 {font-size:14px;} p {font-size:12px;} a {color:black;} .line {height:1px;background-color:#525D76;border:none;}</style></head><body><h1>HTTP Status 404 – Not Found</h1><hr class="line" /><p><b>Type</b> Status Report</p><p><b>Description</b> The origin server did not find a current representation for the target resource or is [root@lo[root@localhost ~]#

# 解决办法

[root@localhost ~]# docker exec -it 4126cf694a05 /bin/bash 先重新进入Tomcat运行的容器
root@4126cf694a05:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work

## 将webapps.dist 文件夹的内容全部复制的 webapps即可

root@4126cf694a05:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work
root@4126cf694a05:/usr/local/tomcat# cd webapps.dist
root@4126cf694a05:/usr/local/tomcat/webapps.dist# ls
ROOT  docs  examples  host-manager  manager
root@4126cf694a05:/usr/local/tomcat/webapps.dist# cd examples
root@4126cf694a05:/usr/local/tomcat/webapps.dist/examples# ls
WEB-INF  index.html  jsp  servlets  websocket
root@4126cf694a05:/usr/local/tomcat/webapps.dist/examples# cd ..
root@4126cf694a05:/usr/local/tomcat/webapps.dist# cd ..
root@4126cf694a05:/usr/local/tomcat# cp -r webapps.dist/* webapps
root@4126cf694a05:/usr/local/tomcat#

#然后就能成功访问到index页面
```





#### Docker ElasticSearch

```bash
# 先下载ElasticSearch
# docker pull docker.elastic.co/elasticsearch/elasticsearch:7.8.0

# 官方推荐的开启单节点集群
# docker run -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" docker.elastic.co/elasticsearch/elasticsearch:7.8.0
但是上面的方式会暴露一个问题，那就是ES占内存非常大，而我们的虚拟机内存很小。所以不建议这样开启

# 其中 -e ES_JAVA_OPTS="-Xms64m -Xmx512m" 表示最小占用64M内存 最大占用512M
# docker run -d -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.8.0

然后去访问 即可验证
[root@localhost ~]# curl localhost:9200
{
  "name" : "88e49838ff71",
  "cluster_name" : "docker-cluster",
  "cluster_uuid" : "T6BQKfqySz63NlT_Tp9NYQ",
  "version" : {
    "number" : "7.8.0",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "757314695644ea9a1dc2fecd26d1a43856725e65",
    "build_date" : "2020-06-14T19:35:50.234439Z",
    "build_snapshot" : false,
    "lucene_version" : "8.5.1",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}
```



#### Docker 提交镜像

==提交了之后，只是在本地存在。还需要push到网络上，才能实现下载使用的功能==

```bash
举例：下载的Tomcat镜像中，webapps文件夹是没有东西的，所以我们在webapps文件夹下面创建一些文件。然后通过下面的命令将修改后的镜像commit
-m 用于添加描述信息，跟Git类似。-a 是作者名字。加上需要修改的容器id，然后 tomcat01是repository名

[root@localhost ~]# docker commit -m="docker with changes in webapps" -a="banjo" 6c9c1265f18e tomcat01
sha256:b1c6475b6b76c51fa3cb08edcb82ec37725c93643eca9274e12301e44594f781
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
6c9c1265f18e        tomcat              "catalina.sh run"   3 minutes ago       Up 3 minutes        0.0.0.0:9001->8080/tcp   recursing_thompson
[root@localhost ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
tomcat01            latest              b1c6475b6b76        9 seconds ago       652MB
nginx               latest              0901fa9da894        11 hours ago        132MB
tomcat              latest              6055d4d564e1        4 days ago          647MB
centos              latest              831691599b88        3 weeks ago         215MB
elasticsearch       7.8.0               121454ddad72        3 weeks ago         810MB
mysql               latest              be0dbf01a0f3        4 weeks ago         541MB
```

![image-20200711174623196](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711192711325.png)



#### Docker 容器数据卷

容器数据卷可以帮助容器的持久化和同步操作，容器间的数据也可以共享

就是容器中的一个路径映射到本地主机上的一个路径，只要容器中的这个路径里面进行了操作，比如添加文件，删除文件，修改文件，那么在主机上的映射的这个目录也会有相同的操作。

==我的理解：以后可以在本地的/home 目录下面创建，centos，Tomcat，ES，redis，Nginx这些目录，然后将这些目录分别的映射到对应的容器中去，就可以保证容器中的重要数据不会丢失==

> 直接使用命令的方式进行挂载

```bash
举例: -v 是用来挂载的 : 有的时候在容器路径下 ### eg. /home:ro 或者 /home:rw 这表示read only或者read & write 表示在容器中这个路径下的文件是只读或者读写均可

将本地主机/home/centos 路径 与 容器centos的 /home路径进行绑定
[root@localhost ~]# docker run -it -v /home/centos:/home centos /bin/bash

然后使用 docker inspect 容器id就可以查看到以下信息，如果没有出现，则代表没有挂载成功。

测试方法，在容器的/home路径下面创建文件，然后再在本地主机的/home/centos下查看是否有相同的文件

同样的去本地主机创建文件，然后去容器中去查看也可以验证
```

![image-20200711192711325](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711174623196.png)



##### 匿名挂载

```bash
# 1. 匿名挂载
-d	后台运行
-P	大写的P表示随机的端口
这里没有指定本机的路径，所以就是匿名挂载
[root@localhost /]# docker run -d -P --name nginx01 -v /etc/nginx nginx
326008beb69c229e1a424d6127aba2dd409989092108b90a60aaff11fa3abb93

[root@localhost /]# docker volume ls 通过这个命令可以拿到匿名挂载的名称
DRIVER              VOLUME NAME
local               626a093ff31bcf34ef1741f5eab3e3077a7bf445a1280fd2f2cb3fd6f448a004
local               6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70

[root@localhost /]# docker volume inspect 6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70 然后通过这个命令查看当前的匿名挂载是映射到本机的什么位置，可以看到是在/var/lib/docker/volumes下面
[
    {
        "CreatedAt": "2020-07-11T05:50:36-07:00",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70/_data",
        "Name": "6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70",
        "Options": null,
        "Scope": "local"
    }
]

```

![image-20200711225525788](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712112330604.png)

##### 具名挂载

```bash
# 2. 具名挂载
test-nginx 就是这个挂载的名字
[root@localhost /]# docker run -d -P --name nginx02 -v test-nginx:/etc/nginx nginx
```

![image-20200711225848468](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711225848468.png)



##### Dockerfile方式挂载

```bash
# 先在主机的一个路径里面生成一个叫做dockerfile的文件
[root@localhost ~]# mkdir /home/docker-test-volume 创建这个目录
[root@localhost ~]# cd /home/docker-test-volume 进入这个目录
[root@localhost docker-test-volume]# ls
[root@localhost docker-test-volume]# vim dockerfile1  创建dockerfile1 文件并写下下面的内容
[root@localhost docker-test-volume]# cat dockerfile1
FROM centos ##以镜像centos为基础

VOLUME ["volume01", "volume02"]  ## 挂载两个卷

CMD echo "-----success------"   ## 成功后的输出
CMD /bin/bash		## 然后会进入该路径

# build 用于创建dockerfile
# -f 		哪一个file文件
# -t		生成的对象
# .			生成在当前目录下

[root@localhost docker-test-volume]# docker build -f /home/docker-test-volume/dockerfile1 -t test/centos .

Sending build context to Docker daemon  2.048kB
Step 1/4 : FROM centos
 ---> 831691599b88
Step 2/4 : VOLUME ["volume01", "volume02"]
 ---> Running in 0c80409788d3
Removing intermediate container 0c80409788d3
 ---> 4e7fe085c688
Step 3/4 : CMD echo "-----success------"
 ---> Running in 3a6eebcf35a9
Removing intermediate container 3a6eebcf35a9
 ---> ec43d897d893
Step 4/4 : CMD /bin/bash
 ---> Running in 7f1029e69632
Removing intermediate container 7f1029e69632
 ---> efd4071b1ad0
Successfully built efd4071b1ad0
Successfully tagged test/centos:latest
## 镜像生成成功
test/centos         latest              efd4071b1ad0        2 minutes ago       215MB
```

当我们利用这个镜像创建容器的时候，就可以看到挂载的卷。

![image-20200712112330604](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712112754635.png)

![image-20200712112754635](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712174322428.png)



##### 数据卷容器

> **--volumes-from** 顾名思义，就是从另一个容器当中挂载容器中已经创建好的数据卷。

以上面的为例，先创建centos01 里面有已经创建好的volume01和volume02的数据卷

然后创建centos02 从centos01中挂载已经创建好的这两个数据卷。

挂载好之后，无论在哪一个容器中修改数据卷中的内容，两个容器都会同步。即使将centos01容器删除，centos02容器中数据卷中的数据也不会丢失

```bash
# 使用以下命令进行挂载
# 而且可以有多个容器对centos01进行挂载，比如centos03
--volumes-from 表示centos02 从 centos01中挂载已经创建好的volume01和volume02数据卷

# docker run -it --name centos02 --volumes-from centos01 test/centos

```





#### Docker MySQL 

```shell
# 需要在Linux中将MySQL的端口在防火墙中开放。
firewall-cmd --add-port=3306/tcp --permanent
firewall-cmd --add-port=3310/tcp --permanent

-d	后台运行
-p	端口映射
-v	卷挂载，可以多个
--name	容器的名字
-e	环境配置
# MYSQL_ROOT_PASSWORD 初始化root的密码
docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123123 --name mysql01 mysql

# 1 先开启MySQL容器
# docker run -it tomcat /bin/bash  
# 然后在MySQL里面 执行以下操作
root@3eeba4e8cfee:/# mysql -u root -p 
查看 root的加密方式
mysql> select host,user,plugin,authentication_string from mysql.user;
+-----------+------------------+-----------------------+
| host      | user             | plugin                | 
+-----------+------------------+-----------------------+
| %         | root             | caching_sha2_password | 
| localhost | mysql.infoschema | caching_sha2_password | 
| localhost | mysql.session    | caching_sha2_password |
| localhost | mysql.sys        | caching_sha2_password |
| localhost | root             | caching_sha2_password | 
如果root的plugin显示是caching_sha2_password 那么就需要作如下的更改，'123123是代表MySQL的密码'
mysql> ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123123';
mysql> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123123';
然后远程就可以连接到本地的MySQL服务了
```

![image-20200711222503711](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/j7mgN8FfSoMXzqI.png)

3310是与MySQL端口号3306对应的

##### 多个MySQL实现数据共享

```bash
# 1. 先创建mysql01，然后将mysql01里面的conf.d和mysql设置成容器数据卷。

docker run -it -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123123 --name mysql01 

# 2. 然后创建mysql02，使用--volumes-from挂载到mysql01的容器数据卷，这样两个mysql之间就可以进行数据共享了
docker run -it -p 3311:3306 -e MYSQL_ROOT_PASSWORD=123123 --name mysql02 --volumes-from mysql01 mysql
```



#### DockerFile

> 以构建tomcat镜像为例

```bash
FROM centos # 以centos为基础

MAINTAINER banjo<mr.singledog@gmail.com> # 表明作者是谁

ADD jdk-8u251-linux-x64.tar.gz /usr/local 
ADD apache-tomcat-9.0.37.tar.gz /usr/local

RUN yum -y install vim # 镜像构建的时候需要运行的命令
RUN yum -y install net-tools

ENV MYPATH /usr/local # 构建镜像的时候设置环境变量

### VOLUME 表示挂载的目录

WORKDIR $MYPATH # 镜像的工作目录

ENV JAVA_HOME /usr/local/jdk1.8.0_251
ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.37
ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.37
ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin

EXPOSE 8080 # 需要开放的端口

CMD /usr/local/apache-tomcat-9.0.37/bin/startup.sh  # 指定容器启动的时候需要运行的命令

ENTRYPOINT #也是指定运行的命令
```

首先这些文件要在同一目录下，并且这个目录最好只有这些文件![image-20200712174104663](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712174104663.png)



然后进行构建，因为Dockerfile名是官方指定的，所以会直接找到

![image-20200712174153322](https://i.loli.net/2020/07/17/NRQxWZsT2e7Ir96.png)



现在就可以看到diytomcat镜像了![image-20200712174322428](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712221352651.png)



#### Docker 打包部署SpringBoot项目

> 在羡慕里的Maven，将项目打包

![image-20200712170007269](https://i.loli.net/2020/07/17/1FUXAt8pMcqGgvo.png)

> 如果打包成功，会在下图位置找到打包好了的jar包

![image-20200712170127230](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712170127230.png)

> 注意，MySQL的配置需要使用docker里面的MySQL配置。

![image-20200712221352651](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712221446247.png)



> 同时还需要一个Dockerfile文件，如下配置

![image-20200712221446247](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200713113733838.png)



然后将他们传输到远程服务器，并且使用docker进行build

```bash
-t 目标对象 叫blog
. 表示在当前目录
docker build -t blog .
```



#### IDEA 集成Docker

```bash
# 首先更改docker的service文件，开放端口。其中2375可以是其他的没被占用的端口

# vim /lib/systemd/system/docker.service
```

![image-20200713113733838](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711225525788.png)

```bash
# 重启docker服务
systemctl daemon-reload

# 然后重新加载配置文件 
systemctl restart docker.service

# 接着在Linux防火墙中开放2375端口
firewall-cmd --add-port=2375/tcp --permanent
firewall-cmd --reload

# 然后使用netstat -nlpt 查看2375是否开放
# 用下面的进行验证
curl http://localhost:2375/info
可以打印出来数据，表示成功
```

然后就可以在IDEA中进行连接

其中的URL是远程服务器的地址，端口是docker的端口

![image-20200713114258061](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200713114258061.png)



然后在service里面点击，就可以看到当前docker里面的容器和镜像

![image-20200713120710743](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200713120710743.png)

, description=The notes of docker , createTime=2020-08-05, updateTime=2021-02-25, category=Category{id=7, name='Docker'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=19, title=Linux Notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=23, content=#### 1. Mac连接虚拟机Linux

##### a. Mac terminal 下操作

在Linux的终端中输入ifconfig来查看ip，然后再在Mac的终端中如下操作

![image-20200708112812503](https://i.loli.net/2020/07/17/V7vLXODN2ipJ6bx.png)



会要求输入Linux的密码



##### b. 从Mac传输文件到Linux

使用FileZilla，通过连接。然后直接将Mac上的文件拖放到虚拟机的Linux上面即可![image-20200708114129842](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200708114129842.png)



==Linux一般没有输出就代表操作成功==



#### Linux 基本命令：

```bash
#可以使用 man + 命令  来查看相关的选项和参数

sync # 将数据由内存同步到硬盘中

shutdown # 关机指令

### 注意在关机前，先执行sync命令将数据保存到硬盘中

reboot # 重启

shutdown -r now # 系统立马重启

######文件操作命令########

ls：列出目录
ls -a：列出全部的文件
ls -l：列出文件，并且显示文件的属性和操作权限 
ls -al: Linux的命令可以合并使用，就是上面的功能的合并

cd + 路径：切换到指定路径
cd ..：切换到上一级
cd /：回到根目录

pwd：显示当前目录

mkdir + 目录名称：创建一个新的目录 
mkdir + 参数(-m 或 -p)：
# -m: 配置文件的权限！直接配置，不需要看默认权限
# -p: 帮助你直接将所需要的目录(包含上一级目录)递归创建起来！

#例子 -p
# mkdir test1/test2/ 如果没有test1的话，那么就会显示No such file or directory  
# 所以需要加上 mkdir -p test1/test2 这样的话，如果没有test1 那么就会创建test1，接着再创建test2.

#例子 -m
# mkdir -m 711 test2 为test2 创建权限

rmdir + 目录名称：删除指定的目录

cp：复制文件或者是目录
# 用法：cp source to destination
# 例子：cp test.txt  /home 将test.txt 文件复制到home路径

rm：删除文件或者目录 ##一定要谨慎使用
# 选项与参数：
# -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；
# -i ：互动模式，在删除前会询问使用者是否动作
# -r ：递归删除！最常用在目录的删除了！这是非常危险的选项！！！


mv：移动文件或者目录
#用法与cp复制文件类似
```

#### Linux 重要的文件目录

```bash
/bin：这个目录是存放着最常用的命令

/boot：存放的是启动Linux时使用的核心文件 ###不要动

/etc：用来存放所有的系统管理需要的配置文件和子目录

/home：用户的主目录

/lib：## 不要动

/lost+found：## 一般存在于云服务器

/opt： 给服务器安装额外的软件的目录，比如说安装的数据库就可以放在这个目录

/root：根目录

/sbin：存放着系统管理员使用的系统管理程序 ##不要动

/usr：##非常重要 用户的很多应用程序和文件都放在该目录下
 
```

#### Linux 文件的属性和权限

![image-20200708142059786](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/3JoYV8kn4pdgWOB.png)

>##### 通过==10个字符==来表示文件的种类和文件的权限

第一个字符：

- 当为[ **d** ]则是目录
- 当为[ **-** ]则是文件；
- 若是[ **l** ]则表示为链接文档 ( link file )；
- 若是[ **b** ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；
- 若是[ **c** ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。

后面9个字符，是每三个为一组，分别表示如下图

其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。

![image-20200708142437235](https://i.loli.net/2020/07/17/XozlwuD6ZILpKfC.png)



如果用=="-"==字符表示没有该权限；比如上图的第三格，表示有读和执行的权限，没有写的权限

#### 修改文件权限

> Linux文件属性有两种设置方法，一种是数字，一种是符号。

每种权限对应一个分数，如下

==read: 4  write: 2 execute:1==  缩写 ==r: 4 w:2 x:1==

> Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。

用对test.txt的权限操作举例：

- owner = rwx = 4+2+1 = 7
- group = rwx = 4+2+1 = 7
- others= --- = 0+0+0 = 0

chmod 770 test.txt 表示除了others组的用户，其余的都可以对该文件进行 读，写和执行的操作

#### 查看文件内容

>Linux 系统中使用以下命令来查看文件的内容

- cat 由第一行开始显示文件内容
- tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！
- nl  显示的时候，顺道输出行号！
- more 一页一页的显示文件内容
- less 与 more 类似，但是比 more 更好的是，他可以往前翻页！
- head 只看头几行
- tail 只看尾巴几行

####  vim基本操作

```bash
vim readme.txt // 第一次使用会创建这个readme.txt文件。第二次输入该命令，则是用于修改该文件

进入文件之后，按键盘 i 可以进行文字的输入。输入完毕之后 按键盘 ESC键进行退出 然后按键盘 : 就可以进入底部命令行模式。并且输入 wq就是保存并退出。

在输入模式下，按键盘 x 表示删除光标位置的字符

以上就是基本操作
```



, description=The basic knowledge of Linux, createTime=2020-07-10, updateTime=2021-02-25, category=Category{id=23, name='Linux'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=18, title=React notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=11, content=### React 基础学习

#### React的安装

1. Mac系统先安装node，直接官网下载安装。成功之后在命令行输入 node -v 或者 npm -v 出现版本号表示安装成功

2. 使用命令：npm install -g create-react-app 安装


出现上图问题，直接给该文件夹的permission进行放行即可: sudo chmod 777 /usr/local/lib/node_modules

```bash
需要进入到项目的文件夹
npm start 是用于开发环境
npm run start 也是用于开发环境
npm run build 是用于生成环境
```

#### 创建项目

create-react-app todolist. 通过这个 命令会在当前文件夹下面创建一个叫做todolist的React项目

> 项目名称不能包含大写字母，否则会报如下的错误

![image-20201012204028354](/Users/laughingli/Library/Application Support/typora-user-images/image-20201012204028354.png)

#### 工程目录介绍

<img src="/Users/laughingli/Library/Application Support/typora-user-images/image-20201012210605456.png" alt="image-20201012210605456" style="zoom:50%;" />

1. README.md：工程的说明文件，添加关于项目的一些说明
2. package.json：项目的介绍
3. .gitignore：将该文件中指定的文件或者目录不push到git 仓库
4. node_modules：是自动下载的第三方依赖
5. public目录里面的index.html：项目首页的模板
6. public目录里面的favicon.ico：项目的图标

src目录：是项目源代码存放的目录

1. index.js：是项目代码的入口文件。

   ```react
   import React from 'react';   // 文件中使用JSX语法，就必须需引入React
   import ReactDOM from 'react-dom';
   import App from './App';
   
   ReactDOM.render(
     <React.StrictMode>
       <App /> // 将App组件挂载到id为root的dom节点下
     </React.StrictMode>,
     document.getElementById('root')
   );
   
   
   ```

   

#### React中的组件

一个组件会有如下的特征：会extends Component

```react
import React, { Component } from 'react';

class App extends Component {
  render() {  // 一个组件就是页面的一部分内容，由render()这个方法进行渲染
    return( // return就是渲染的内容
      <div>
          hello World
      </div>
    )
  }
}
export default App;
```



#### JSX语法

```jsx
	class TodoList extends Component {
    render () {
        return (
          // 这种情况下，会报错。必须要有一个parent tag
            <div>
                <input /><button>点击</button>
            </div>
            <ul>
                <li>学音乐</li>
                <li>halo</li>
            </ul>
					// 要像下面一样，包裹一个parent tag才行
          <Fragment> // Fragment 需要单独引入，跟Component一样
          	<div>
                <input /><button>点击</button>
            </div>
            <ul>
                <li>学音乐</li>
                <li>halo</li>
            </ul>
          </Fragment>
        )
    }
}


```



#### React使用范例

> 父组件，与下面的子组件相结合理解

```react
import React, { Component, Fragment } from 'react';
import './style.css';
import TodoItem from './TodoItem';

class TodoList extends Component {

    // 构造函数：props是固定的
    constructor(props) {
        super(props); // 调用父类Component的构造函数
        this.state = { // this.state表示组件的状态，它可以用来存储各种数据
            inputValue: '', // inputValue用于接收输入信息
            list: []        // list用于存储输入信息
        }
        // 通过下面的方法，让各种方法指向TodoList
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleItemDelete = this.handleItemDelete.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
    }

    render() {
        return (
            <Fragment>
                <div>
                    {/* 将input与组件的inputValue进行绑定
                    这个input的值，由inputValue决定 */}
                    {/* onChange，当输入框发生变化的时候，
                    调用handleInputChange方法 */}
                    {/* bind(this),改变方法的this指向
                    让其指向组件 */}
                    <input
                        className='input'
                        value={this.state.inputValue}
                        onChange={this.handleInputChange}
                    />
                    {/* 用于当点击发生的时候，来调用对应的方法 */}
                    <button onClick={this.handleBtnClick}>点击</button>
                </div>
                <ul>
                    {
                        this.getTodoItem()
                    }
                </ul>
            </Fragment>

        )
    }

    // 用于显示TodoItem组件的处理结果
    getTodoItem() {
        // Each child in a list should have a unique "key" prop.
        // 需要return，处理之后的结果才能被调用显示
        return this.state.list.map((item, index) => {
            // 最好不要用index作为key值
            // 当点击对应的数据的时候，将其删除handleItemDelete
            // index 用于传递给delete方法对相应的index的数据进行处理
            return (
                <TodoItem
                    // 将input的值通过content传递给了子组件 TodoItem
                    // 将index的值通过index传递给了子组件 TodoItem
                    // 将handleItemDelete方法绑定到了子组件的deleteItem上，
                    // 这样当子组件调用deleteItem的时候，就是在调用父组件的handleItemDelete
                    key={index}
                    content={item}
                    index={index}
                    deleteItem={this.handleItemDelete}
                />
            )
        })
    }

    handleInputChange(e) {
        // 用this.setState的方式来修改里面的值
        this.setState({
            inputValue: e.target.value
        })
    }

    handleBtnClick(e) {
        this.setState({
            // ...this.state.list用于获取，本来该list中含有的数据
            list: [...this.state.list, this.state.inputValue],
            // 下面用于添加完成后，将input输入框清空
            inputValue: ''
        })
    }

    handleItemDelete(index) {
        //先复制一份list原来的值，因为不能对state的内容直接进行操作
        const list = [...this.state.list];
        // 删除下标是index的内容，删除1个
        list.splice(index, 1);
        this.setState({
            list: list
        })
    }


}

export default TodoList;
```

#### 如何引用CSS文件

```jsx
import './style.css'; // 首先在头部引用CSS文件

<input 
    className='input'  // 然后再在需要使用的地方引用具体的css，记住是className而不是class
    value={this.state.inputValue} 
    onChange={this.handleInputChange.bind(this)}
/>
```



#### 如何引入本地图片

```react
import lunbo from '../../../statics/lunbo.jpeg';

<img src={lunbo} alt=''/>
```



#### 组件之间的传值

> 子组件，与上面的父组件相结合来理解

```react
import React, { Component } from 'react';

class TodoItem extends Component {

    constructor(props) {
        super(props);
        // 让这个函数指向TodoItem
        this.handleClick = this.handleClick.bind(this);
    }

    render () {
        return (
            
        <div onClick={this.handleClick}>
            {/* 当点击子组件的每一项的时候，就会调用handleClick方法 */}
            {this.props.content}
        </div>
        )
    }

    handleClick() {
        // 调用deleteItem实际上是调用父组件的handleItemDelete方法
        // this.props.index，是指的对应要删除的每一项的下标
        this.props.deleteItem(this.props.index)
    }
}

export default TodoItem;
```



#### PropTypes和DefaultProps的应用

```react
// 为了做类型校验，需要引入PropTypes
import PropTypes from 'prop-types';

// 对TodoItem组件里的属性进行校验
TodoItem.propTypes = {
    // content的内容必须是string类型
    // 后面加上isRequired就表示必须要有输入值，否则会报错
    content: PropTypes.string.isRequired,

    // deleteItem传入的内容必须是一个函数
    deleteItem: PropTypes.func,

    // index传入的内容必须是number或者是string类型
    index: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
}
export default TodoItem;
```



#### Props，State与render函数

> 当组件的state或者是props发生改变的时候，render函数就会重新执行
>
> 当父组件的render函数被运行时，子组件的render函数也会重新执行



#### 生命周期函数

> 生命周期函数：指在某一个时刻组件会自动执行的函数
>
> 举例：React的render函数，当组件的state或者props发生改变的时候，render函数就会自动执行。这就是生命周期函数

```react
componentWillMount() { 
   //已经弃用。它的意思是在组件第一次挂载之前执行。 也就是组件第一次被渲染到页面的时候
        console.log('will mount')
    }

componentDidMount() { // 在组件第一次挂载之后会执行
        console.log('did mount')
    }

// 在组件的内容更新之前会自动被执行，会返回true或者false
// 无论返回true或者false，shouldComponentUpdate都会被执行
// 但是，如果是true则表示执行更新，如果是false则表示不执行更新。
shouldComponentUpdate() {
        console.log('should ?')
        return true
    }

// 在shouldComponentUpdate()返回了true之后才会被执行，它是在组件完成更新之前被执行
// Warning: componentWillUpdate has been renamed, and is not recommended for use. 弃用
componentWillUpdate() {
        console.log('componentWillUpdate')
    }

// 也是在shouldComponentUpdate()返回了true之后才会被执行。它是在组件完成更新之后被执行
componentDidUpdate() {
        console.log('componentDidUpdate')
    }

// Warning: componentWillReceiveProps has been renamed, 
// and is not recommended for use. 弃用
componentWillReceiveProps() {
        console.log('componentWillReceiveProps')
    }
```

####  生命周期函数使用场景

```react
// 举例，父组件中引用了子组件。如果父组件的render函数被执行了，那么子组件的render函数也会被执行。
// 这在有的时候就会带来性能上的损失，因为子组件不需要随时都被执行

// 在子组件的render函数之前添加该生命周期函数
shouldComponentUpdate(nextProps, nextState, nextContext) {
  			// 如果接下来的content内容不等于当前content的内容，那么子组件的render函数才会被执行
        return nextProps.content !== this.props.content;
    }
```

#### React使用ajax

```react
// 首先要安装对应的包，从命令行进入到工程项目 然后安装
npm install axios 
// 安装完成后
// 在需要使用到ajax的地方引入即可，下面是举例使用
import axios from "axios";

// ajax的使用，就是在componentDidMount这个生命周期函数之中：因为它只会执行一次
componentDidMount() {
        axios.get('/api/todolist')
            .then(() => {alert('success')})
            .catch(() => {alert('failed')})
    }

```



#### React Router

> router安装

```bash
npm install react-router-dom 进行安装
```



> router的使用

```react
import React, { Component } from 'react';
import Header from './common/header/header.js';
import { Provider } from 'react-redux';
import store from "./common/header/redux/store";

// 先将需要的页面编辑好，然后引入
import Home from './home/index';
import Detail from './Detail/index';
// 引入路由'BrowserRouter'和路由规则'Route'
import { BrowserRouter, Route } from 'react-router-dom';

function App() {
  return (
      <Provider store={store}>
          {/* BrowserRouter标签代表路由 */}
          <BrowserRouter>
              {/* Route代表路由规则，exact 表示路由必须完全相同才能够渲染
               路由完全相同的意思：http://localhost:3000/detail，因为这个URL里面也包含
               根目录，如果不加exact，那么下面的两个路由规则都会显示。加上exact的话，就只显示
               detail的
               */}
            	{/* 直接使用Component={} 来将其添加到路由 */}
              <Route path='/' exact Component={ Home }></Route>
              <Route path='/detail' Component={ Detail }></Route>
          </BrowserRouter>
          <Header />
      </Provider>
  );
}

export default App;
```



#### 安装Immutable.JS 

```bash
npm install immutable
```



### Redux 学习

#### Redux的工作流程

> 类比图书馆借书的过程

<img src="/Users/laughingli/Library/Application Support/typora-user-images/image-20201017094121868.png" alt="image-20201017094121868" style="zoom: 25%;" />

1. React Components 代表一个借书的用户
2. Action Creators 代表一个用户具体要借什么书这一个指令
3. Store 代表图书管的管理员。数据管理的仓库
4. Reducers 代表整个图书馆的数据库，记录了每一本书的基本信息和存放位置



#### Chrome 安装 Redux DevTools

1. 首先在Chrome的extensions商店搜索 Redux DevTools

2. ```react
   // 然后再在react的store文件里面添加如下一行代码
   // window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
   const store = createStore(reducer,
       window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
   ```

3. 然后就可以在Chrome里面点击Redux DevTools进行调试

####  安装Ant Design

```bash
// 首先在命令行中进入工程目录，然后执行下面的语句
npm install antd --save
```

#### 安装Redux

```bash
// 首先在命令行中进入工程目录，然后执行下面的语句
npm install redux
```

#### redux的使用范例

##### 第一步：创建reducer

```react
const defaultState = {
    inputValue: '123',
    list: ['1', '2']
}

// state 指的是整个store仓库里面存储的数据。这里给了一个初始化的数据 defaultState
export default (state = defaultState, action) => {
    // 根据action的type来进行判断，然后进行操作
    if (action.type === 'change input value') {
        // 先拷贝之前state里面原有的数据，因为react不推荐直接操作state
        const newState = JSON.parse(JSON.stringify(state));
        // 然后将action传递来的value复制到newState的inputValue
        newState.inputValue = action.value;
        // 会将newState返回给store，store会将newState替换掉老的state
        return newState;
    }

    if (action.type === 'add todo item') {
        // 先拷贝之前state里面原有的数据，因为react不推荐直接操作state
        const newState = JSON.parse(JSON.stringify(state));
        newState.list.push(newState.inputValue);
        newState.inputValue = '';
        return newState;
    }

    if (action.type === 'delete todo item') {
        // 先拷贝之前state里面原有的数据，因为react不推荐直接操作state
        const newState = JSON.parse(JSON.stringify(state));
        newState.list.splice(action.index, 1);
        return newState;
    }
    return state;
}
```

##### 第二步：创建store

```react
import { createStore } from 'redux';
// 将reducer引入store
import reducer from "./reducer";

// 根据reducer来创建store
const store = createStore(reducer,
                         window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());

export default store;
```

##### 第三步：将store引入到需要用到的Component组件当中

```react
import React, { Component, Fragment } from "react";
import 'antd/dist/antd.css';
import { Input, List } from 'antd';
// 将store引入到组件
import store from "./store";

class TodoList extends Component {

    constructor(props) {
        super(props);

        // 将数据仓库里的数据赋值给该组件的state，第一次挂载的时候
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        // 让store订阅handleStoreChange方法，只有这个方法发生变动，那么
        // store就会产生相应的变化
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return(
            <Fragment>
                {/* 上下左右有10px的边距 */}
                <div style={{margin: '10px 10px'}}>
                    <Input value={this.state.inputValue}
                           placeholder='todo list'
                           style={{width: '300px', marginRight: '5px'}}
                           onChange={this.handleInputChange}
                    />
                    <button onClick={this.handleBtnClick}>提交</button>

                    {/* 在渲染的时候会有一个index来表示该item的下标 */}
                    {/* 将index传递给handleDelete方法 */}
                    <List style={{width: '300px'}}
                          size="large"
                          bordered
                          dataSource={this.state.list}

                          renderItem={(item, index) => <List.Item onClick={this.handleDelete.bind(this, index)}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }

    handleInputChange(e) {
        const action = {
            // 创建一个action，其中的type是固定的，用于描述该动作
            type: 'change input value',
            value: e.target.value
        }
        // 通过dispatch将action传递给store
        store.dispatch(action);
    }

    // 将store的state替换掉TodoList这个组件的state，这样就可以随时渲染更新
    handleStoreChange() {
        this.setState(store.getState());
    }

    // 当点击按钮的时候，会触发的方法
    handleBtnClick() {
        const action = {
            type: 'add todo item',
        }
        store.dispatch(action);
    }

    // 这个方法接收一个index参数，index是对应item的下标
    handleDelete(index) {
        const action = {
            type: 'delete todo item',
            index
        }
        store.dispatch(action);
    }
}

export default TodoList;
```

##### 

#### UI组件和容器组件

> 是将渲染页面的语句和逻辑语句拆分开

##### 初始组件

```react
import React, { Component, Fragment } from "react";
import 'antd/dist/antd.css';
import { Input, List } from 'antd';
// 将store引入到组件
import store from "./store";

class TodoList extends Component {

    constructor(props) {
        super(props);

        // 将数据仓库里的数据赋值给该组件的state，第一次挂载的时候
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        // 让store订阅handleStoreChange方法，只有这个方法发生变动，那么
        // store就会产生相应的变化
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return(
            <Fragment>
                {/* 上下左右有10px的边距 */}
                <div style={{margin: '10px 10px'}}>
                    <Input value={this.state.inputValue}
                           placeholder='todo list'
                           style={{width: '300px', marginRight: '5px'}}
                           onChange={this.handleInputChange}
                    />
                    <button onClick={this.handleBtnClick}>提交</button>

                    {/* 在渲染的时候会有一个index来表示该item的下标 */}
                    {/* 将index传递给handleDelete方法 */}
                    <List style={{width: '300px'}}
                          size="large"
                          bordered
                          dataSource={this.state.list}

                          renderItem={(item, index) => <List.Item onClick={this.handleDelete.bind(this, index)}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }

    handleInputChange(e) {
        const action = {
            // 创建一个action，其中的type是固定的，用于描述该动作
            type: 'change input value',
            value: e.target.value
        }
        // 通过dispatch将action传递给store
        store.dispatch(action);
    }

    // 将store的state替换掉TodoList这个组件的state，这样就可以随时渲染更新
    handleStoreChange() {
        this.setState(store.getState());
    }

    // 当点击按钮的时候，会触发的方法
    handleBtnClick() {
        const action = {
            type: 'add todo item',
        }
        store.dispatch(action);
    }

    // 这个方法接收一个index参数，index是对应item的下标
    handleDelete(index) {
        const action = {
            type: 'delete todo item',
            index
        }
        store.dispatch(action);
    }
}

export default TodoList;

```



##### 拆分后的UI组件

```react
import React, { Component, Fragment } from "react";
import {Input, List} from "antd";

class TodoListUI extends Component {
    render() {
        return (
            <Fragment>
                <div style={{margin: '10px 10px'}}>
                    <Input
                        value={this.props.inputValue}
                        placeholder="Hello World"
                        style={{width: '300px', marginRight: '5px'}}
                        onChange={this.props.handleInputChange}
                    />
                    <button onClick={this.props.handleBtnClick}>点击</button>
                    <List
                        style={{width: '300px', marginTop: '10px'}}
                        size="small"
                        bordered
                        dataSource={this.props.list}
                        renderItem={(item, index) => <List.Item onClick={() => {this.props.deleteItem(index)}}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }
}

export default TodoListUI;
```



##### 拆分后的容器组件

```react
import React, { Component, Fragment } from "react";
import "antd/dist/antd.css"
import store from "./store";
import TodoListUI from './TodoListUI';

// 将所有的action抽取出来，放到一个叫做actionTypes的文件中
import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM } from "./actionTypes";

class TodoList extends Component {

    constructor(props) {
        super(props);
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.deleteItem = this.deleteItem.bind(this)
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return <TodoListUI
        // 将组件的各种状态传递给子组件        
        inputValue = {this.state.inputValue}
        list = {this.state.list}
        handleInputChange = {this.handleInputChange}
        handleBtnClick = {this.handleBtnClick}
        deleteItem = {this.deleteItem}
        handStoreChange = {this.handleStoreChange}
        />
    }

    handleInputChange(e) {
        const action = {
            type: CHANGE_INPUT_VALUE,
            value: e.target.value
        }
        store.dispatch(action);
    }

    handleBtnClick() {
        const action = {
            type: ADD_TODO_ITEM,
        }
        store.dispatch(action);
    }

    handleStoreChange() {
        this.setState(store.getState());
    }

    deleteItem(index) {
        const action = {
            type: DELETE_TODO_ITEM,
            index
        }
        store.dispatch(action);
    }
}

export default TodoList;
```

### Redux 中间件

#### redux-thunk

> redux-thunk的安装
>
> 它可以将异步操作从组建中移除，然后发到action文件当中去

```bash
npm install redux-thunk
```

> redux-thunk中间件的使用
>
> 它主要是在创建store的时候被引用

```react
// thunk和saga它们都是中间件，如果要使用，首先需要引入applyMiddleware
import {createStore, applyMiddleware, compose} from "redux";
// 然后再引入对应的中间件，这里是thunk
import thunk from "redux-thunk";
import reducer from "./reducer";

// 如果要同时使用redux的devtools和其他的中间件，那么就需要像下面一样来写。
// 因为redux devtools也是一个中间件
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
    //    compose需要从redux中引入
    }) : compose;

const enhancer = composeEnhancers(applyMiddleware(thunk))

const store = createStore(reducer, enhancer)

export default store;
```

> actionCreators 文件

```react
// 这里是返回的一个对象
export const getDeleteItemAction = (index) => ({
    type: DELETE_TODO_ITEM,
    index
})

export const getInitItemAction = (data) => ({
    type: INIT_LIST_ITEM,
    data
});

// 这里是返回的一个函数，运用到了react-thunk。如果没有它，那么久不能返回一个函数
export const getTodoList = () => {
    return (dispatch) => {
        axios.get('https://run.mocky.io/v3/06315b0b-6c7f-49c3-9e51-94e3a35da33b')
            .then((res) => {
                const data =res.data;
                dispatch(getInitItemAction(data));
            })
            .catch(() => {console.log('failed')})
    }
}
```





### react-redux 学习

> 安装react-redux

```bash
进入到工程目录
npm install react-redux
```

#### react-redux 使用范例

##### index.js 

```react
import React from 'react';
import ReactDOM from 'react-dom';
import TodoList from "./TodoList";
import store from "./store";
// react-redux 提供的核心API
import { Provider } from 'react-redux';

const App = (
    // Provider组件，由react-redux提供。
    // Provider的store属性的值，就是整个store数据仓库的值。
    // 这样，只要是在Provider下面的组件，例如TodoList组件
    // 都可以获取到store里面的内容
    <Provider store={store}>
        <TodoList />
    </Provider>
);

ReactDOM.render(
  <React.StrictMode>
    {/* 然后将App组件传给ReactDOM.render进行渲染 */}
      {App}
  </React.StrictMode>,
  document.getElementById('root')
);
```



##### store.js 和 reducer.js 页面不需要作改变

##### TodoList.js 组件

```react
import React, { Component, Fragment } from "react";
// react-redux 提供的核心API
import { connect } from 'react-redux';
import 'antd/dist/antd.css';
import { Input, List } from 'antd';

class TodoList extends Component {

    render() {
        return(
            <Fragment>
                <div style={{margin: '10px 10px'}}>
                    <Input
                        style={{width: '300px'}}
                        placeholder='todo list'
                        value={this.props.inputValue}
                        onChange={this.props.changeInputValue}
                    />
                    <button
                        style={{marginLeft: '5px'}}
                        onClick={this.props.handleBtnClick}
                    >提交</button>

                    <List style={{width: '300px', marginTop: '10px'}}
                          size="large"
                          bordered
                          dataSource={this.props.list}
                          renderItem={(item, index) => <List.Item onClick={this.props.deleteItem.bind(this, index)}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }
}

// 这个函数是用来将store里面的state传递给子组件的props
// 这里是传递给TodoList
const mapStateToProps = (state) => {
    return {
        // 让子组件的inputValue和store里面的inputValue产生关联
        inputValue: state.inputValue,
        // 让子组件的list和store里面的list产生关联
        list: state.list
    }
}

// 将store的 dispatch方法挂载到 props上
// 这个函数是用来，将修改后的子组件state中的数据返回给store
// 让store来更改修改过后的数据
const mapDispatchToProps = (dispatch) => {
    return {
        changeInputValue(e) {
            const action = {
                type: 'change input value',
                value: e.target.value
            }
            dispatch(action);
        },
        handleBtnClick() {
            const action = {
                type: 'add todo item'
            }
            dispatch(action);
        },
        deleteItem(index) {
            const action = {
                type: 'delete todo item',
                index
            }
            dispatch(action);
        }
    }
}

// 这里的意思是，让TodoList组件与store进行连接
export default connect(mapStateToProps, mapDispatchToProps)(TodoList);
```



### react 使用styled-components

> 运用styled-components来对react项目的css文件进行管理

将css放入一个叫style.js的文件中。

```react
import { createGlobalStyle } from 'styled-components';

export const GlobalStyle = createGlobalStyle`
  body{
    marigin: 0;
    padding: 0;
    background: green;
  }
`
```

然后再将其引入到需要使用这个css的组件当中

```react
import React from 'react';
// 引入css
import { GlobalStyle } from "./style";

function App() {
  return (
    <p style={{margin: "10px 10px"}}>
      // 使用css
      <GlobalStyle/>
      Hello World
    </p>
  );
}

export default App;

```

### React 过程中的坑

> 当运用了combineReducers这个组件之后，遇到的问题

整合的reducer文件

```react
import { combineReducers } from "redux";
import reducerHeader from "../header/redux/reducer";

export default combineReducers({
    header: reducerHeader
})
```



对应的组件当中就必须如下写。因为是拆分的，所以要带上其对应的header。以此类推

```react
const mapStateToProps = (state) => {
    return {
        // 将store里面存储的信息传递给子组件，也就是这里的Header组件
        focused: state.header.get('focused'),
        hotList: state.header.get('hotList'),
        totalPage: state.header.get('totalPage'),
        page: state.header.get('page'),
        mouseIn: state.header.get('mouseIn')
    }
}
```

### Component 和 PureComponent

Component：只要项目store里面的数据发生了变化，那么每一个组件就会被重新的渲染。这样就会造成性能的降低。为了避免这样的情况，可以在组件中使用shouldComponentUpdate()这个生命周期函数。通过这个函数来判断，store里面的数据更改是否和当下的组件相关。如果不相关的话，就不重新渲染



PureComponent：react底层帮助实现了上面的功能。但是需要配合immutable.js使用，否则会出现不可预测的问题



### 异步组件/withRouter路由使用

, description=React Study, createTime=2020-07-02, updateTime=2021-02-25, category=Category{id=25, name='React'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0)], isHasContent=true, first=true, last=false, isHasNext=true, isHasPrevious=false))
2021-03-25 18:26:38.017  INFO 36287 --- [http-nio-8080-exec-2] com.banjo.blogvue.aspect.LogAspect       : Request: RequestLog{url='http://localhost:8080/blog', ip='0:0:0:0:0:0:0:1', classMethod='com.banjo.blogvue.controller.admin.AdminPageController.listBlogs', args=[]}
2021-03-25 18:26:38.017  INFO 36287 --- [http-nio-8080-exec-2] com.banjo.blogvue.aspect.LogAspect       : Result: admin/listBlogs
2021-03-25 18:26:38.545  INFO 36287 --- [http-nio-8080-exec-2] com.banjo.blogvue.aspect.LogAspect       : Request: RequestLog{url='http://localhost:8080/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.banjo.blogvue.controller.admin.BlogController.list', args=[0, 4]}
2021-03-25 18:26:38.575  INFO 36287 --- [http-nio-8080-exec-2] com.banjo.blogvue.aspect.LogAspect       : Result: Result(code=0, message=, data=Page4Navigator(pageFromJPA=Page 1 of 2 containing com.banjo.blogvue.pojo.Blog instances, navigatePages=0, navigatePageNums=null, totalPages=2, number=0, totalElements=7, size=4, numberOfElements=4, content=[Blog(id=23, title=AWS Cloud, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Translation, views=11, content=#### 卸载自带jdk

```bash
# 先使用以下命令 查看当前的jdk
rpm -qa|grep jdk
java-1.7.0-openjdk-1.7.0.261-2.6.22.1.83.amzn1.x86_64
copy-jdk-configs-3.3-10.3.amzn1.noarch

# 然后根据对应版本的jdk 直接用下面的命令删除
sudo rpm -e --nodeps java-1.7.0-openjdk-1.7.0.261-2.6.22.1.83.amzn1.x86_64

# 然后使用yum下载jdk，使用下面的命令查看java可选版本
$ yum -y list java*

# 然后根据版本号，直接下载
sudo yum install -y java-1.8.0-openjdk-devel.x86_64
```



#### FileZilla 连接 AWS

1. 打开 FileZilla 的 "Edit" -> "Settings" 对话框，在左边的“选择页面” 选择“SFTP”， 右边点击 “添加密钥文件...” 按钮，导入Amazon给的密钥文件 

   ![image-20200713163800225](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/7gZEBIRuMvdbPli.png)

2. 打开File选择Site Manager

   Protocol中选择SFTP

   Host选择 公有DNS![image-20200713163956246](https://i.loli.net/2020/07/17/9fIEBSrGNMzgoLu.png)

![image-20200713163918562](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/OQzkdvYoGqKLs5B.png)

然后选择Interactive的方式登录，用户是ec2-user

或者选择key的方式都可以

然后就能连接成功

> 连接成功之后需要将一个用于接收上传文件的文件夹进行权限修改

如下：

![image-20200713170334089](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/TNozpkPF8OgeJyM.png)



#### 安装docker

```bash
# 先查看版本 
yum -y list docker*
# 然后根据版本来下载
sudo yum install -y docker.x86_64

# 下载之后需要启动Docker服务
sudo service docker start

# 然后将ec2-user添加到docker组，否则不能执行Docker命令
sudo usermod -a -G docker ec2-user

# 然后重启AWS实例，就可以开启docker服务了
```



#### Docker vim命令

```bash
首先进入容器，然后执行
 apt-get update
 
 然后执行
 apt-get install vim
```

#### AWS 安全组

```bash
# 1. 如果tomcat开启的端口是8080，那么就需要在AWS的安全组里面放行对8080端口的访问，同时还要对9001端口进行开放

docker run -d -p 9001:8080 tomcat

其他的服务如果需要使用其他的端口，那么也用相同的方法进行放行

下面以MySQL的连接为例，3310和3306都需要在安全组里面进行放行。

 mysql          "docker-entrypoint.s…"   17 hours ago        Up 17 hours         33060/tcp, 0.0.0.0:3310->3306/tcp   mysql01
```



![image-20200714180816580](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/ysLFVnza2wGp9E6.png)



#### IDEA 连接 AWS 上的docker

1. 首先修改docker需要监听的IP和端口

```bash
   1. 首先关闭docker服务
   sudo service docker stop
   2. 然后修改docker 服务端监听的端口和ip
   sudo dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375
   3. 然后启动docker服务
   sudo service docker start
   4. 然后修改客户端的
   docker -H tcp://0.0.0.0:2375 ps
   没有输出就表示成功。
   
   
   
   ```

2. 然后再aws里面的安全组里将2375端口进行放行

3. 然后再利用IDEA对docker进行远程连接即可

> 以systemd的方式连接

```bash
1. 先找到这个文件
/lib/systemd/system/docker.service

然后注释掉下面的
ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock $OPTIONS $DOCKER_STORAGE_OPTIONS $DOCKER_ADD_RUNTIMES

然后再添加
ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock
这样远程就能通过2375端口访问到了
```

#### AWS ec2 安装MySQL

```bash
# 先查看是否有旧版本MySQL
rpm -qa | grep -i mysql

# 如果有的话，使用下面的命令将其全部删除
sudo rpm -ev 加mysql的文件名


# 下载并进入到下载好的文件夹
 wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.17-linux-glibc2.12-x86_64.tar.xz
 # 解压下载的压缩包
 tar xvf mysql-8.0.17-linux-glibc2.12-x86_64.tar.xz
 
 # 将解压好的复制到/usr/local目录下并且重命名为mysql
 sudo mv mysql-8.0.17-linux-glibc2.12-x86_64 /usr/local/mysql
 
 # 进入到mysql目录，然后创建一个data文件夹，用于存放数据
 mkdir data
 
 # 创建mysql用户组和mysql用户
 sudo groupadd mysql
 sudo useradd -g mysql mysql
 
 # 改变mysql目录权限 注意后面都有一个点
 sudo chown -R mysql .
 sudo chgrp -R mysql .
 
 # 创建mysql_install_db安装文件，并且修改权限
sudo mkdir mysql_install_db
sudo chmod 777 ./mysql_install_db

# 初始化
sudo bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data
# 一定要记住临时密码
A temporary password is generated for root@localhost: 

# mysql配置，将support-files下的移动到init.d目录下，并且重命名，两个都要
sudo cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld
sudo cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql
# 修改或者创建my.cnf文件，并且加入下面的命令

[mysqld]
    basedir = /usr/local/mysql
    datadir = /usr/local/mysql/data
    socket = /usr/local/mysql/mysql.sock
    character-set-server=utf8
    port = 3306
   sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
 [client]
   socket = /usr/local/mysql/mysql.sock
   default-character-set=utf8
   
# 建立MySQL服务
sudo chmod +x /etc/init.d/mysqld
sudo chmod +x /etc/init.d/mysql
# 添加到系统服务
sudo chkconfig --add mysqld
sudo chkconfig --add mysql
#配置全局环境变量

先设置 /etc/profile文件的权限，可以读写
sudo /etc/profile chmod 777
然后再在里面添加以下配置
export PATH=$PATH:/usr/local/mysql/bin:/usr/local/mysql/lib
export PATH

# 设置环境变量立即生效
source /etc/profile

# 启动MySQL服务

sudo service mysql start

# 登录MySQL
mysql -u root -p 回车
输入上面的临时密码即可

# 修改初始密码
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY'自己的密码';

# 设置远程可登录
进入mysql
1. use mysql
2. update user set host='%' where user='root' limit 1;
3. flush privileges; # 刷新权限

然后就可以进行远程登录
```

, description=Learn how to set up a clear AWS cloud, createTime=2021-02-17, updateTime=2021-02-25, category=Category{id=17, name='AWS Cloud'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=21, title=Docker Notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=14, content=#### Linux 安装 docker

```bash
# 1. 首先用下面的命令卸载旧版本，如果有的话
sudo yum remove docker \ 
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
                  
# 2. 安装依赖包
sudo yum install -y yum-utils        

# 3. 设置镜像仓库
sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo

# 4. 安装docker引擎
sudo yum install docker-ce docker-ce-cli containerd.io

# 5. 启动docker 和重启
sudo systemctl start docker
sudo systemctl restart docker

# 6. 测试是否启动成功
sudo docker run hello-world

# 7. 卸载依赖和删除资源
sudo yum remove docker-ce docker-ce-cli containerd.io
sudo rm -rf /var/lib/docker
```



docker run hello-world的流程图

1. docker会在本地仓库寻找hello-world的镜像，找到就运行。
2. 没找到，docker client就会跟 docker daemon联系，然后下载hello-world镜像到本地
3. 下载到本地之后，再运行该镜像。

 ![image-20200710230333325](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200710230333325.png)![image-20200710230221724](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200710230221724.png)



#### Docker 常用命令

##### 帮助命令

```shell
docker version # 查看docker信息
docker info		 # 查看docker系统信息，包括有多少镜像和容器
docker --help  # 帮助命令
```



##### 镜像命令

> 查看镜像

```bash
docker images  # 查看当前主机上的所有镜像
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              bf756fb1ae65        6 months ago        13.3kB

# docker images 命令的可选性
-a, --all 	# 列出所有的镜像跟默认的docker images一样
-q, --quit	# 只显示镜像的id,-q 和 --quit一样

[root@localhost ~]# docker images --quiet
bf756fb1ae65

[root@localhost ~]# docker images -q
bf756fb1ae65

docker search mysql 搜索mysql的镜像 #镜像的搜索
```

> 搜索镜像

```bash
docker search mysql 搜索mysql的镜像 #镜像的搜索
# 只需要添加想要的镜像的名称，就可以进行搜索。
[root@localhost ~]# docker search mysql
NAME                              DESCRIPTION                                     STARS               
mysql                             MySQL is a widely used, open-source relation…   9718
```

> 下载镜像

```bash
docker pull mysql  # 下载mysql

[root@localhost ~]# docker pull mysql
Using default tag: latest #如果不指定tag，就默认下载最新版本
latest: Pulling from library/mysql
8559a31e96f4: Pull complete	# 分层下载， docker images的核心 联合文件系统
d51ce1c2e575: Pull complete	# 好处：举例--如果要更新到更新版本的MySQL，那么下次执行pull的
c2344adc4858: Pull complete	# 时候只需要下载被更新的部分，其余没更新的不会被重复下载
fcf3ceff18fc: Pull complete
16da0c38dc5b: Pull complete
b905d1797e97: Pull complete
4b50d1c6b05c: Pull complete
c75914a65ca2: Pull complete
1ae8042bdd09: Pull complete
453ac13c00a3: Pull complete
9e680cd72f08: Pull complete
a6b5dc864b6c: Pull complete
Digest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest # 这里是真实的mysql的地址

docker pull mysql 等价于  docker pull docker.io/library/mysql:lastest
```



> 删除镜像

```bash
docker rmi -f 加上(镜像的id) 

[root@localhost ~]# docker rmi -f bf756fb1ae65
Untagged: hello-world:latest
Untagged: hello-world@sha256:d58e752213a51785838f9eed2b7a498ffa1cb3aa7f946dda11af39286c3db9a9
Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b

##或者 docker rmi -f 加上(镜像的repository名称) 
docker rmi -f hello-world

[root@localhost ~]# docker rmi -f hello-world
Untagged: hello-world:latest
Untagged: hello-world@sha256:d58e752213a51785838f9eed2b7a498ffa1cb3aa7f946dda11af39286c3db9a9
Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b

```



##### 容器命令

> 先有镜像，才能创建容器。以下用docker下载centos来进行举例学习

> 新建容器并启动

```bash
# -it 表示使用交互方式运行，进入容器查看内容
[root@localhost ~]# docker run -it centos /bin/bash  
									# docker run -d centos   表示后台启动容器
[root@f72fb12d27fc /]# ls  这里表示已经进入到了centos这个容器当中
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

[root@f72fb12d27fc /]# exit  退出并且停止容器
exit
[root@localhost ~]#

删除所有容器
docker rm $(docker ps -aq)
```

> 查看运行和曾经运行过的容器

```bash
[root@localhost ~]# docker ps -a 表示查看当前在运行的和曾经运行过的容器
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
f72fb12d27fc        centos              "/bin/bash"         3 minutes ago       Exited (0) 2 minutes ago                       hopeful_mcnulty
3af87bce0732        bf756fb1ae65        "/hello"            12 hours ago        Exited (0) 12 hours ago                        lucid_sammet
b22be932b11a        bf756fb1ae65        "/hello"            12 hours ago        Exited (0) 12 hours ago                        vigorous_chaplygin
[root@localhost ~]# docker ps  表示查看正在运行的容器
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
[root@localhost ~]#

```

> 启动，停止，重启容器

```shell
docker start 容器id
docker restart 容器id
docker stop 容器id
docker kill 容器id #强制停止当前容器
```

> 退出容器

```bash
exit 表示退出且停止容器运行

Ctrl + P + Q #不停止容器运行，只退出容器

[root@f4b87ffb286b /]# [root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
f4b87ffb286b        centos              "/bin/bash"         13 seconds ago      Up 11 seconds                           laughing_darwin
[root@localhost ~]#

```



> 进入在运行的指定容器

```shell
docker exec -it 容器名 /bin/bash

[root@localhost ~]# docker exec -it 0f45f1d47525 /bin/bash
[root@0f45f1d47525 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

docker attach 容器名

[root@localhost ~]# docker attach 0f45f1d47525
[root@0f45f1d47525 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

###区别
docker exec			# 进入容器后开启一个新的终端，可以在里面操作(这个是常用的)。
docker attach		# 进入容器正在执行的终端，不会启动新的进程。

```



> 删除容器

```bash
docker rm 容器id
```

> 列出所有容器

```bash
docker container ls
```



> 日志打印

```bash
docker logs --tail 10 0f45f1d47525  
--tail 表示以字符串的形式打印，10是--tail的参数，打印10行。最后跟的是容器的id
```

> 查看容器进程信息

```bash
docker top 容器id
[root@localhost ~]# docker top 0f45f1d47525
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                13539               13521               0                   18:08               pts/0               00:00:00            /bin/bash
```

> 查看容器元数据(所有数据)

```bash
[root@localhost ~]# docker inspect 0f45f1d47525（容器id）
```



> 从容器中复制文件到主机

```bash
[root@6ad773845eab /]# cd home  开启容器 进入到home目录
[root@6ad773845eab home]# touch test.java	在home目录创建test.java文件
[root@6ad773845eab home]# ls
test.java
[root@6ad773845eab home]# exit 退出即可
exit
[root@localhost ~]# ls 当前文件夹下是没有test.java文件
anaconda-ks.cfg  Desktop  Documents  Downloads  Music  original-ks.cfg  Pictures  Public  study.txt  Templates  Videos  

# 将6ad773845eab:/home/test.java  将这个容器的home目录中的test.java文件复制到
# ~目录。
[root@localhost ~]# docker cp 6ad773845eab:/home/test.java ~
[root@localhost ~]# ls
anaconda-ks.cfg  Desktop  Documents  Downloads  Music  original-ks.cfg  Pictures  Public  study.txt  Templates  test.java  Videos
[root@localhost ~]#
```



#### Docker Nginx

##### 启动并验证Nginx

```bash
-d 表示后台运行
--name nginx01表示它的名字
-p 8082:80 #8082表示客户端访问的请求的端口，80表示本地与之对应的端口。
就是客户端访问8082端口会拿到本地80端口的数据

[root@localhost ~]# docker run -d --name nginx01 -p 8082:80 nginx
f0a1f169564a7c8faacb1aa73cae06449267e5b39493a05196086823b69f8972
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
f0a1f169564a        nginx               "/docker-entrypoint.…"   4 seconds ago       Up 3 seconds        0.0.0.0:8082->80/tcp   nginx01
6ad773845eab        centos              "/bin/bash"              56 minutes ago      Up 51 minutes                              elastic_mestorf
[root@localhost ~]# curl localhost:8082  验证是否能够访问成功
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
Nginx在docker里面的配置文件在 /etc/nginx路径下面
```



#### Docker Tomcat

```bash
# tomcat 的启动跟Nginx相似
也是要设置端口的映射。才能进行访问
[root@localhost ~]# docker run -d -p 9001:8080 tomcat
4126cf694a054e44dfa27a059da130ff8201d427b0e1aeeafb57a986f8fa8667
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
4126cf694a05        tomcat              "catalina.sh run"        4 seconds ago       Up 3 seconds        0.0.0.0:9001->8080/tcp   loving_bell
f0a1f169564a        nginx               "/docker-entrypoint.…"   27 minutes ago      Up 27 minutes       0.0.0.0:8082->80/tcp     nginx01
6ad773845eab        centos              "/bin/bash"              About an hour ago   Up About an hour                             elastic_mestorf

## 返回404 表示能够访问，但是当前的Tomcat里面还缺少可用于访问的文件
[root@localhost ~]# curl localhost:9001
<!doctype html><html lang="en"><head><title>HTTP Status 404 – Not Found</title><style type="text/css">body {font-family:Tahoma,Arial,sans-serif;} h1, h2, h3, b {color:white;background-color:#525D76;} h1 {font-size:22px;} h2 {font-size:16px;} h3 {font-size:14px;} p {font-size:12px;} a {color:black;} .line {height:1px;background-color:#525D76;border:none;}</style></head><body><h1>HTTP Status 404 – Not Found</h1><hr class="line" /><p><b>Type</b> Status Report</p><p><b>Description</b> The origin server did not find a current representation for the target resource or is [root@lo[root@localhost ~]#

# 解决办法

[root@localhost ~]# docker exec -it 4126cf694a05 /bin/bash 先重新进入Tomcat运行的容器
root@4126cf694a05:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work

## 将webapps.dist 文件夹的内容全部复制的 webapps即可

root@4126cf694a05:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work
root@4126cf694a05:/usr/local/tomcat# cd webapps.dist
root@4126cf694a05:/usr/local/tomcat/webapps.dist# ls
ROOT  docs  examples  host-manager  manager
root@4126cf694a05:/usr/local/tomcat/webapps.dist# cd examples
root@4126cf694a05:/usr/local/tomcat/webapps.dist/examples# ls
WEB-INF  index.html  jsp  servlets  websocket
root@4126cf694a05:/usr/local/tomcat/webapps.dist/examples# cd ..
root@4126cf694a05:/usr/local/tomcat/webapps.dist# cd ..
root@4126cf694a05:/usr/local/tomcat# cp -r webapps.dist/* webapps
root@4126cf694a05:/usr/local/tomcat#

#然后就能成功访问到index页面
```





#### Docker ElasticSearch

```bash
# 先下载ElasticSearch
# docker pull docker.elastic.co/elasticsearch/elasticsearch:7.8.0

# 官方推荐的开启单节点集群
# docker run -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" docker.elastic.co/elasticsearch/elasticsearch:7.8.0
但是上面的方式会暴露一个问题，那就是ES占内存非常大，而我们的虚拟机内存很小。所以不建议这样开启

# 其中 -e ES_JAVA_OPTS="-Xms64m -Xmx512m" 表示最小占用64M内存 最大占用512M
# docker run -d -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.8.0

然后去访问 即可验证
[root@localhost ~]# curl localhost:9200
{
  "name" : "88e49838ff71",
  "cluster_name" : "docker-cluster",
  "cluster_uuid" : "T6BQKfqySz63NlT_Tp9NYQ",
  "version" : {
    "number" : "7.8.0",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "757314695644ea9a1dc2fecd26d1a43856725e65",
    "build_date" : "2020-06-14T19:35:50.234439Z",
    "build_snapshot" : false,
    "lucene_version" : "8.5.1",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}
```



#### Docker 提交镜像

==提交了之后，只是在本地存在。还需要push到网络上，才能实现下载使用的功能==

```bash
举例：下载的Tomcat镜像中，webapps文件夹是没有东西的，所以我们在webapps文件夹下面创建一些文件。然后通过下面的命令将修改后的镜像commit
-m 用于添加描述信息，跟Git类似。-a 是作者名字。加上需要修改的容器id，然后 tomcat01是repository名

[root@localhost ~]# docker commit -m="docker with changes in webapps" -a="banjo" 6c9c1265f18e tomcat01
sha256:b1c6475b6b76c51fa3cb08edcb82ec37725c93643eca9274e12301e44594f781
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
6c9c1265f18e        tomcat              "catalina.sh run"   3 minutes ago       Up 3 minutes        0.0.0.0:9001->8080/tcp   recursing_thompson
[root@localhost ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
tomcat01            latest              b1c6475b6b76        9 seconds ago       652MB
nginx               latest              0901fa9da894        11 hours ago        132MB
tomcat              latest              6055d4d564e1        4 days ago          647MB
centos              latest              831691599b88        3 weeks ago         215MB
elasticsearch       7.8.0               121454ddad72        3 weeks ago         810MB
mysql               latest              be0dbf01a0f3        4 weeks ago         541MB
```

![image-20200711174623196](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711192711325.png)



#### Docker 容器数据卷

容器数据卷可以帮助容器的持久化和同步操作，容器间的数据也可以共享

就是容器中的一个路径映射到本地主机上的一个路径，只要容器中的这个路径里面进行了操作，比如添加文件，删除文件，修改文件，那么在主机上的映射的这个目录也会有相同的操作。

==我的理解：以后可以在本地的/home 目录下面创建，centos，Tomcat，ES，redis，Nginx这些目录，然后将这些目录分别的映射到对应的容器中去，就可以保证容器中的重要数据不会丢失==

> 直接使用命令的方式进行挂载

```bash
举例: -v 是用来挂载的 : 有的时候在容器路径下 ### eg. /home:ro 或者 /home:rw 这表示read only或者read & write 表示在容器中这个路径下的文件是只读或者读写均可

将本地主机/home/centos 路径 与 容器centos的 /home路径进行绑定
[root@localhost ~]# docker run -it -v /home/centos:/home centos /bin/bash

然后使用 docker inspect 容器id就可以查看到以下信息，如果没有出现，则代表没有挂载成功。

测试方法，在容器的/home路径下面创建文件，然后再在本地主机的/home/centos下查看是否有相同的文件

同样的去本地主机创建文件，然后去容器中去查看也可以验证
```

![image-20200711192711325](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711174623196.png)



##### 匿名挂载

```bash
# 1. 匿名挂载
-d	后台运行
-P	大写的P表示随机的端口
这里没有指定本机的路径，所以就是匿名挂载
[root@localhost /]# docker run -d -P --name nginx01 -v /etc/nginx nginx
326008beb69c229e1a424d6127aba2dd409989092108b90a60aaff11fa3abb93

[root@localhost /]# docker volume ls 通过这个命令可以拿到匿名挂载的名称
DRIVER              VOLUME NAME
local               626a093ff31bcf34ef1741f5eab3e3077a7bf445a1280fd2f2cb3fd6f448a004
local               6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70

[root@localhost /]# docker volume inspect 6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70 然后通过这个命令查看当前的匿名挂载是映射到本机的什么位置，可以看到是在/var/lib/docker/volumes下面
[
    {
        "CreatedAt": "2020-07-11T05:50:36-07:00",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70/_data",
        "Name": "6604beca4e447290b473cb29161186be8d079dac98483410a6d120337a40de70",
        "Options": null,
        "Scope": "local"
    }
]

```

![image-20200711225525788](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712112330604.png)

##### 具名挂载

```bash
# 2. 具名挂载
test-nginx 就是这个挂载的名字
[root@localhost /]# docker run -d -P --name nginx02 -v test-nginx:/etc/nginx nginx
```

![image-20200711225848468](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711225848468.png)



##### Dockerfile方式挂载

```bash
# 先在主机的一个路径里面生成一个叫做dockerfile的文件
[root@localhost ~]# mkdir /home/docker-test-volume 创建这个目录
[root@localhost ~]# cd /home/docker-test-volume 进入这个目录
[root@localhost docker-test-volume]# ls
[root@localhost docker-test-volume]# vim dockerfile1  创建dockerfile1 文件并写下下面的内容
[root@localhost docker-test-volume]# cat dockerfile1
FROM centos ##以镜像centos为基础

VOLUME ["volume01", "volume02"]  ## 挂载两个卷

CMD echo "-----success------"   ## 成功后的输出
CMD /bin/bash		## 然后会进入该路径

# build 用于创建dockerfile
# -f 		哪一个file文件
# -t		生成的对象
# .			生成在当前目录下

[root@localhost docker-test-volume]# docker build -f /home/docker-test-volume/dockerfile1 -t test/centos .

Sending build context to Docker daemon  2.048kB
Step 1/4 : FROM centos
 ---> 831691599b88
Step 2/4 : VOLUME ["volume01", "volume02"]
 ---> Running in 0c80409788d3
Removing intermediate container 0c80409788d3
 ---> 4e7fe085c688
Step 3/4 : CMD echo "-----success------"
 ---> Running in 3a6eebcf35a9
Removing intermediate container 3a6eebcf35a9
 ---> ec43d897d893
Step 4/4 : CMD /bin/bash
 ---> Running in 7f1029e69632
Removing intermediate container 7f1029e69632
 ---> efd4071b1ad0
Successfully built efd4071b1ad0
Successfully tagged test/centos:latest
## 镜像生成成功
test/centos         latest              efd4071b1ad0        2 minutes ago       215MB
```

当我们利用这个镜像创建容器的时候，就可以看到挂载的卷。

![image-20200712112330604](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712112754635.png)

![image-20200712112754635](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712174322428.png)



##### 数据卷容器

> **--volumes-from** 顾名思义，就是从另一个容器当中挂载容器中已经创建好的数据卷。

以上面的为例，先创建centos01 里面有已经创建好的volume01和volume02的数据卷

然后创建centos02 从centos01中挂载已经创建好的这两个数据卷。

挂载好之后，无论在哪一个容器中修改数据卷中的内容，两个容器都会同步。即使将centos01容器删除，centos02容器中数据卷中的数据也不会丢失

```bash
# 使用以下命令进行挂载
# 而且可以有多个容器对centos01进行挂载，比如centos03
--volumes-from 表示centos02 从 centos01中挂载已经创建好的volume01和volume02数据卷

# docker run -it --name centos02 --volumes-from centos01 test/centos

```





#### Docker MySQL 

```shell
# 需要在Linux中将MySQL的端口在防火墙中开放。
firewall-cmd --add-port=3306/tcp --permanent
firewall-cmd --add-port=3310/tcp --permanent

-d	后台运行
-p	端口映射
-v	卷挂载，可以多个
--name	容器的名字
-e	环境配置
# MYSQL_ROOT_PASSWORD 初始化root的密码
docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123123 --name mysql01 mysql

# 1 先开启MySQL容器
# docker run -it tomcat /bin/bash  
# 然后在MySQL里面 执行以下操作
root@3eeba4e8cfee:/# mysql -u root -p 
查看 root的加密方式
mysql> select host,user,plugin,authentication_string from mysql.user;
+-----------+------------------+-----------------------+
| host      | user             | plugin                | 
+-----------+------------------+-----------------------+
| %         | root             | caching_sha2_password | 
| localhost | mysql.infoschema | caching_sha2_password | 
| localhost | mysql.session    | caching_sha2_password |
| localhost | mysql.sys        | caching_sha2_password |
| localhost | root             | caching_sha2_password | 
如果root的plugin显示是caching_sha2_password 那么就需要作如下的更改，'123123是代表MySQL的密码'
mysql> ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123123';
mysql> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123123';
然后远程就可以连接到本地的MySQL服务了
```

![image-20200711222503711](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/j7mgN8FfSoMXzqI.png)

3310是与MySQL端口号3306对应的

##### 多个MySQL实现数据共享

```bash
# 1. 先创建mysql01，然后将mysql01里面的conf.d和mysql设置成容器数据卷。

docker run -it -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123123 --name mysql01 

# 2. 然后创建mysql02，使用--volumes-from挂载到mysql01的容器数据卷，这样两个mysql之间就可以进行数据共享了
docker run -it -p 3311:3306 -e MYSQL_ROOT_PASSWORD=123123 --name mysql02 --volumes-from mysql01 mysql
```



#### DockerFile

> 以构建tomcat镜像为例

```bash
FROM centos # 以centos为基础

MAINTAINER banjo<mr.singledog@gmail.com> # 表明作者是谁

ADD jdk-8u251-linux-x64.tar.gz /usr/local 
ADD apache-tomcat-9.0.37.tar.gz /usr/local

RUN yum -y install vim # 镜像构建的时候需要运行的命令
RUN yum -y install net-tools

ENV MYPATH /usr/local # 构建镜像的时候设置环境变量

### VOLUME 表示挂载的目录

WORKDIR $MYPATH # 镜像的工作目录

ENV JAVA_HOME /usr/local/jdk1.8.0_251
ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.37
ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.37
ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin

EXPOSE 8080 # 需要开放的端口

CMD /usr/local/apache-tomcat-9.0.37/bin/startup.sh  # 指定容器启动的时候需要运行的命令

ENTRYPOINT #也是指定运行的命令
```

首先这些文件要在同一目录下，并且这个目录最好只有这些文件![image-20200712174104663](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712174104663.png)



然后进行构建，因为Dockerfile名是官方指定的，所以会直接找到

![image-20200712174153322](https://i.loli.net/2020/07/17/NRQxWZsT2e7Ir96.png)



现在就可以看到diytomcat镜像了![image-20200712174322428](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712221352651.png)



#### Docker 打包部署SpringBoot项目

> 在羡慕里的Maven，将项目打包

![image-20200712170007269](https://i.loli.net/2020/07/17/1FUXAt8pMcqGgvo.png)

> 如果打包成功，会在下图位置找到打包好了的jar包

![image-20200712170127230](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712170127230.png)

> 注意，MySQL的配置需要使用docker里面的MySQL配置。

![image-20200712221352651](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200712221446247.png)



> 同时还需要一个Dockerfile文件，如下配置

![image-20200712221446247](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200713113733838.png)



然后将他们传输到远程服务器，并且使用docker进行build

```bash
-t 目标对象 叫blog
. 表示在当前目录
docker build -t blog .
```



#### IDEA 集成Docker

```bash
# 首先更改docker的service文件，开放端口。其中2375可以是其他的没被占用的端口

# vim /lib/systemd/system/docker.service
```

![image-20200713113733838](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200711225525788.png)

```bash
# 重启docker服务
systemctl daemon-reload

# 然后重新加载配置文件 
systemctl restart docker.service

# 接着在Linux防火墙中开放2375端口
firewall-cmd --add-port=2375/tcp --permanent
firewall-cmd --reload

# 然后使用netstat -nlpt 查看2375是否开放
# 用下面的进行验证
curl http://localhost:2375/info
可以打印出来数据，表示成功
```

然后就可以在IDEA中进行连接

其中的URL是远程服务器的地址，端口是docker的端口

![image-20200713114258061](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200713114258061.png)



然后在service里面点击，就可以看到当前docker里面的容器和镜像

![image-20200713120710743](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200713120710743.png)

, description=The notes of docker , createTime=2020-08-05, updateTime=2021-02-25, category=Category{id=7, name='Docker'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=19, title=Linux Notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=23, content=#### 1. Mac连接虚拟机Linux

##### a. Mac terminal 下操作

在Linux的终端中输入ifconfig来查看ip，然后再在Mac的终端中如下操作

![image-20200708112812503](https://i.loli.net/2020/07/17/V7vLXODN2ipJ6bx.png)



会要求输入Linux的密码



##### b. 从Mac传输文件到Linux

使用FileZilla，通过连接。然后直接将Mac上的文件拖放到虚拟机的Linux上面即可![image-20200708114129842](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/image-20200708114129842.png)



==Linux一般没有输出就代表操作成功==



#### Linux 基本命令：

```bash
#可以使用 man + 命令  来查看相关的选项和参数

sync # 将数据由内存同步到硬盘中

shutdown # 关机指令

### 注意在关机前，先执行sync命令将数据保存到硬盘中

reboot # 重启

shutdown -r now # 系统立马重启

######文件操作命令########

ls：列出目录
ls -a：列出全部的文件
ls -l：列出文件，并且显示文件的属性和操作权限 
ls -al: Linux的命令可以合并使用，就是上面的功能的合并

cd + 路径：切换到指定路径
cd ..：切换到上一级
cd /：回到根目录

pwd：显示当前目录

mkdir + 目录名称：创建一个新的目录 
mkdir + 参数(-m 或 -p)：
# -m: 配置文件的权限！直接配置，不需要看默认权限
# -p: 帮助你直接将所需要的目录(包含上一级目录)递归创建起来！

#例子 -p
# mkdir test1/test2/ 如果没有test1的话，那么就会显示No such file or directory  
# 所以需要加上 mkdir -p test1/test2 这样的话，如果没有test1 那么就会创建test1，接着再创建test2.

#例子 -m
# mkdir -m 711 test2 为test2 创建权限

rmdir + 目录名称：删除指定的目录

cp：复制文件或者是目录
# 用法：cp source to destination
# 例子：cp test.txt  /home 将test.txt 文件复制到home路径

rm：删除文件或者目录 ##一定要谨慎使用
# 选项与参数：
# -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；
# -i ：互动模式，在删除前会询问使用者是否动作
# -r ：递归删除！最常用在目录的删除了！这是非常危险的选项！！！


mv：移动文件或者目录
#用法与cp复制文件类似
```

#### Linux 重要的文件目录

```bash
/bin：这个目录是存放着最常用的命令

/boot：存放的是启动Linux时使用的核心文件 ###不要动

/etc：用来存放所有的系统管理需要的配置文件和子目录

/home：用户的主目录

/lib：## 不要动

/lost+found：## 一般存在于云服务器

/opt： 给服务器安装额外的软件的目录，比如说安装的数据库就可以放在这个目录

/root：根目录

/sbin：存放着系统管理员使用的系统管理程序 ##不要动

/usr：##非常重要 用户的很多应用程序和文件都放在该目录下
 
```

#### Linux 文件的属性和权限

![image-20200708142059786](https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/3JoYV8kn4pdgWOB.png)

>##### 通过==10个字符==来表示文件的种类和文件的权限

第一个字符：

- 当为[ **d** ]则是目录
- 当为[ **-** ]则是文件；
- 若是[ **l** ]则表示为链接文档 ( link file )；
- 若是[ **b** ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；
- 若是[ **c** ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。

后面9个字符，是每三个为一组，分别表示如下图

其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。

![image-20200708142437235](https://i.loli.net/2020/07/17/XozlwuD6ZILpKfC.png)



如果用=="-"==字符表示没有该权限；比如上图的第三格，表示有读和执行的权限，没有写的权限

#### 修改文件权限

> Linux文件属性有两种设置方法，一种是数字，一种是符号。

每种权限对应一个分数，如下

==read: 4  write: 2 execute:1==  缩写 ==r: 4 w:2 x:1==

> Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。

用对test.txt的权限操作举例：

- owner = rwx = 4+2+1 = 7
- group = rwx = 4+2+1 = 7
- others= --- = 0+0+0 = 0

chmod 770 test.txt 表示除了others组的用户，其余的都可以对该文件进行 读，写和执行的操作

#### 查看文件内容

>Linux 系统中使用以下命令来查看文件的内容

- cat 由第一行开始显示文件内容
- tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！
- nl  显示的时候，顺道输出行号！
- more 一页一页的显示文件内容
- less 与 more 类似，但是比 more 更好的是，他可以往前翻页！
- head 只看头几行
- tail 只看尾巴几行

####  vim基本操作

```bash
vim readme.txt // 第一次使用会创建这个readme.txt文件。第二次输入该命令，则是用于修改该文件

进入文件之后，按键盘 i 可以进行文字的输入。输入完毕之后 按键盘 ESC键进行退出 然后按键盘 : 就可以进入底部命令行模式。并且输入 wq就是保存并退出。

在输入模式下，按键盘 x 表示删除光标位置的字符

以上就是基本操作
```



, description=The basic knowledge of Linux, createTime=2020-07-10, updateTime=2021-02-25, category=Category{id=23, name='Linux'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0), Blog(id=18, title=React notes, picture=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, flag=Original, views=11, content=### React 基础学习

#### React的安装

1. Mac系统先安装node，直接官网下载安装。成功之后在命令行输入 node -v 或者 npm -v 出现版本号表示安装成功

2. 使用命令：npm install -g create-react-app 安装


出现上图问题，直接给该文件夹的permission进行放行即可: sudo chmod 777 /usr/local/lib/node_modules

```bash
需要进入到项目的文件夹
npm start 是用于开发环境
npm run start 也是用于开发环境
npm run build 是用于生成环境
```

#### 创建项目

create-react-app todolist. 通过这个 命令会在当前文件夹下面创建一个叫做todolist的React项目

> 项目名称不能包含大写字母，否则会报如下的错误

![image-20201012204028354](/Users/laughingli/Library/Application Support/typora-user-images/image-20201012204028354.png)

#### 工程目录介绍

<img src="/Users/laughingli/Library/Application Support/typora-user-images/image-20201012210605456.png" alt="image-20201012210605456" style="zoom:50%;" />

1. README.md：工程的说明文件，添加关于项目的一些说明
2. package.json：项目的介绍
3. .gitignore：将该文件中指定的文件或者目录不push到git 仓库
4. node_modules：是自动下载的第三方依赖
5. public目录里面的index.html：项目首页的模板
6. public目录里面的favicon.ico：项目的图标

src目录：是项目源代码存放的目录

1. index.js：是项目代码的入口文件。

   ```react
   import React from 'react';   // 文件中使用JSX语法，就必须需引入React
   import ReactDOM from 'react-dom';
   import App from './App';
   
   ReactDOM.render(
     <React.StrictMode>
       <App /> // 将App组件挂载到id为root的dom节点下
     </React.StrictMode>,
     document.getElementById('root')
   );
   
   
   ```

   

#### React中的组件

一个组件会有如下的特征：会extends Component

```react
import React, { Component } from 'react';

class App extends Component {
  render() {  // 一个组件就是页面的一部分内容，由render()这个方法进行渲染
    return( // return就是渲染的内容
      <div>
          hello World
      </div>
    )
  }
}
export default App;
```



#### JSX语法

```jsx
	class TodoList extends Component {
    render () {
        return (
          // 这种情况下，会报错。必须要有一个parent tag
            <div>
                <input /><button>点击</button>
            </div>
            <ul>
                <li>学音乐</li>
                <li>halo</li>
            </ul>
					// 要像下面一样，包裹一个parent tag才行
          <Fragment> // Fragment 需要单独引入，跟Component一样
          	<div>
                <input /><button>点击</button>
            </div>
            <ul>
                <li>学音乐</li>
                <li>halo</li>
            </ul>
          </Fragment>
        )
    }
}


```



#### React使用范例

> 父组件，与下面的子组件相结合理解

```react
import React, { Component, Fragment } from 'react';
import './style.css';
import TodoItem from './TodoItem';

class TodoList extends Component {

    // 构造函数：props是固定的
    constructor(props) {
        super(props); // 调用父类Component的构造函数
        this.state = { // this.state表示组件的状态，它可以用来存储各种数据
            inputValue: '', // inputValue用于接收输入信息
            list: []        // list用于存储输入信息
        }
        // 通过下面的方法，让各种方法指向TodoList
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleItemDelete = this.handleItemDelete.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
    }

    render() {
        return (
            <Fragment>
                <div>
                    {/* 将input与组件的inputValue进行绑定
                    这个input的值，由inputValue决定 */}
                    {/* onChange，当输入框发生变化的时候，
                    调用handleInputChange方法 */}
                    {/* bind(this),改变方法的this指向
                    让其指向组件 */}
                    <input
                        className='input'
                        value={this.state.inputValue}
                        onChange={this.handleInputChange}
                    />
                    {/* 用于当点击发生的时候，来调用对应的方法 */}
                    <button onClick={this.handleBtnClick}>点击</button>
                </div>
                <ul>
                    {
                        this.getTodoItem()
                    }
                </ul>
            </Fragment>

        )
    }

    // 用于显示TodoItem组件的处理结果
    getTodoItem() {
        // Each child in a list should have a unique "key" prop.
        // 需要return，处理之后的结果才能被调用显示
        return this.state.list.map((item, index) => {
            // 最好不要用index作为key值
            // 当点击对应的数据的时候，将其删除handleItemDelete
            // index 用于传递给delete方法对相应的index的数据进行处理
            return (
                <TodoItem
                    // 将input的值通过content传递给了子组件 TodoItem
                    // 将index的值通过index传递给了子组件 TodoItem
                    // 将handleItemDelete方法绑定到了子组件的deleteItem上，
                    // 这样当子组件调用deleteItem的时候，就是在调用父组件的handleItemDelete
                    key={index}
                    content={item}
                    index={index}
                    deleteItem={this.handleItemDelete}
                />
            )
        })
    }

    handleInputChange(e) {
        // 用this.setState的方式来修改里面的值
        this.setState({
            inputValue: e.target.value
        })
    }

    handleBtnClick(e) {
        this.setState({
            // ...this.state.list用于获取，本来该list中含有的数据
            list: [...this.state.list, this.state.inputValue],
            // 下面用于添加完成后，将input输入框清空
            inputValue: ''
        })
    }

    handleItemDelete(index) {
        //先复制一份list原来的值，因为不能对state的内容直接进行操作
        const list = [...this.state.list];
        // 删除下标是index的内容，删除1个
        list.splice(index, 1);
        this.setState({
            list: list
        })
    }


}

export default TodoList;
```

#### 如何引用CSS文件

```jsx
import './style.css'; // 首先在头部引用CSS文件

<input 
    className='input'  // 然后再在需要使用的地方引用具体的css，记住是className而不是class
    value={this.state.inputValue} 
    onChange={this.handleInputChange.bind(this)}
/>
```



#### 如何引入本地图片

```react
import lunbo from '../../../statics/lunbo.jpeg';

<img src={lunbo} alt=''/>
```



#### 组件之间的传值

> 子组件，与上面的父组件相结合来理解

```react
import React, { Component } from 'react';

class TodoItem extends Component {

    constructor(props) {
        super(props);
        // 让这个函数指向TodoItem
        this.handleClick = this.handleClick.bind(this);
    }

    render () {
        return (
            
        <div onClick={this.handleClick}>
            {/* 当点击子组件的每一项的时候，就会调用handleClick方法 */}
            {this.props.content}
        </div>
        )
    }

    handleClick() {
        // 调用deleteItem实际上是调用父组件的handleItemDelete方法
        // this.props.index，是指的对应要删除的每一项的下标
        this.props.deleteItem(this.props.index)
    }
}

export default TodoItem;
```



#### PropTypes和DefaultProps的应用

```react
// 为了做类型校验，需要引入PropTypes
import PropTypes from 'prop-types';

// 对TodoItem组件里的属性进行校验
TodoItem.propTypes = {
    // content的内容必须是string类型
    // 后面加上isRequired就表示必须要有输入值，否则会报错
    content: PropTypes.string.isRequired,

    // deleteItem传入的内容必须是一个函数
    deleteItem: PropTypes.func,

    // index传入的内容必须是number或者是string类型
    index: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
}
export default TodoItem;
```



#### Props，State与render函数

> 当组件的state或者是props发生改变的时候，render函数就会重新执行
>
> 当父组件的render函数被运行时，子组件的render函数也会重新执行



#### 生命周期函数

> 生命周期函数：指在某一个时刻组件会自动执行的函数
>
> 举例：React的render函数，当组件的state或者props发生改变的时候，render函数就会自动执行。这就是生命周期函数

```react
componentWillMount() { 
   //已经弃用。它的意思是在组件第一次挂载之前执行。 也就是组件第一次被渲染到页面的时候
        console.log('will mount')
    }

componentDidMount() { // 在组件第一次挂载之后会执行
        console.log('did mount')
    }

// 在组件的内容更新之前会自动被执行，会返回true或者false
// 无论返回true或者false，shouldComponentUpdate都会被执行
// 但是，如果是true则表示执行更新，如果是false则表示不执行更新。
shouldComponentUpdate() {
        console.log('should ?')
        return true
    }

// 在shouldComponentUpdate()返回了true之后才会被执行，它是在组件完成更新之前被执行
// Warning: componentWillUpdate has been renamed, and is not recommended for use. 弃用
componentWillUpdate() {
        console.log('componentWillUpdate')
    }

// 也是在shouldComponentUpdate()返回了true之后才会被执行。它是在组件完成更新之后被执行
componentDidUpdate() {
        console.log('componentDidUpdate')
    }

// Warning: componentWillReceiveProps has been renamed, 
// and is not recommended for use. 弃用
componentWillReceiveProps() {
        console.log('componentWillReceiveProps')
    }
```

####  生命周期函数使用场景

```react
// 举例，父组件中引用了子组件。如果父组件的render函数被执行了，那么子组件的render函数也会被执行。
// 这在有的时候就会带来性能上的损失，因为子组件不需要随时都被执行

// 在子组件的render函数之前添加该生命周期函数
shouldComponentUpdate(nextProps, nextState, nextContext) {
  			// 如果接下来的content内容不等于当前content的内容，那么子组件的render函数才会被执行
        return nextProps.content !== this.props.content;
    }
```

#### React使用ajax

```react
// 首先要安装对应的包，从命令行进入到工程项目 然后安装
npm install axios 
// 安装完成后
// 在需要使用到ajax的地方引入即可，下面是举例使用
import axios from "axios";

// ajax的使用，就是在componentDidMount这个生命周期函数之中：因为它只会执行一次
componentDidMount() {
        axios.get('/api/todolist')
            .then(() => {alert('success')})
            .catch(() => {alert('failed')})
    }

```



#### React Router

> router安装

```bash
npm install react-router-dom 进行安装
```



> router的使用

```react
import React, { Component } from 'react';
import Header from './common/header/header.js';
import { Provider } from 'react-redux';
import store from "./common/header/redux/store";

// 先将需要的页面编辑好，然后引入
import Home from './home/index';
import Detail from './Detail/index';
// 引入路由'BrowserRouter'和路由规则'Route'
import { BrowserRouter, Route } from 'react-router-dom';

function App() {
  return (
      <Provider store={store}>
          {/* BrowserRouter标签代表路由 */}
          <BrowserRouter>
              {/* Route代表路由规则，exact 表示路由必须完全相同才能够渲染
               路由完全相同的意思：http://localhost:3000/detail，因为这个URL里面也包含
               根目录，如果不加exact，那么下面的两个路由规则都会显示。加上exact的话，就只显示
               detail的
               */}
            	{/* 直接使用Component={} 来将其添加到路由 */}
              <Route path='/' exact Component={ Home }></Route>
              <Route path='/detail' Component={ Detail }></Route>
          </BrowserRouter>
          <Header />
      </Provider>
  );
}

export default App;
```



#### 安装Immutable.JS 

```bash
npm install immutable
```



### Redux 学习

#### Redux的工作流程

> 类比图书馆借书的过程

<img src="/Users/laughingli/Library/Application Support/typora-user-images/image-20201017094121868.png" alt="image-20201017094121868" style="zoom: 25%;" />

1. React Components 代表一个借书的用户
2. Action Creators 代表一个用户具体要借什么书这一个指令
3. Store 代表图书管的管理员。数据管理的仓库
4. Reducers 代表整个图书馆的数据库，记录了每一本书的基本信息和存放位置



#### Chrome 安装 Redux DevTools

1. 首先在Chrome的extensions商店搜索 Redux DevTools

2. ```react
   // 然后再在react的store文件里面添加如下一行代码
   // window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
   const store = createStore(reducer,
       window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
   ```

3. 然后就可以在Chrome里面点击Redux DevTools进行调试

####  安装Ant Design

```bash
// 首先在命令行中进入工程目录，然后执行下面的语句
npm install antd --save
```

#### 安装Redux

```bash
// 首先在命令行中进入工程目录，然后执行下面的语句
npm install redux
```

#### redux的使用范例

##### 第一步：创建reducer

```react
const defaultState = {
    inputValue: '123',
    list: ['1', '2']
}

// state 指的是整个store仓库里面存储的数据。这里给了一个初始化的数据 defaultState
export default (state = defaultState, action) => {
    // 根据action的type来进行判断，然后进行操作
    if (action.type === 'change input value') {
        // 先拷贝之前state里面原有的数据，因为react不推荐直接操作state
        const newState = JSON.parse(JSON.stringify(state));
        // 然后将action传递来的value复制到newState的inputValue
        newState.inputValue = action.value;
        // 会将newState返回给store，store会将newState替换掉老的state
        return newState;
    }

    if (action.type === 'add todo item') {
        // 先拷贝之前state里面原有的数据，因为react不推荐直接操作state
        const newState = JSON.parse(JSON.stringify(state));
        newState.list.push(newState.inputValue);
        newState.inputValue = '';
        return newState;
    }

    if (action.type === 'delete todo item') {
        // 先拷贝之前state里面原有的数据，因为react不推荐直接操作state
        const newState = JSON.parse(JSON.stringify(state));
        newState.list.splice(action.index, 1);
        return newState;
    }
    return state;
}
```

##### 第二步：创建store

```react
import { createStore } from 'redux';
// 将reducer引入store
import reducer from "./reducer";

// 根据reducer来创建store
const store = createStore(reducer,
                         window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());

export default store;
```

##### 第三步：将store引入到需要用到的Component组件当中

```react
import React, { Component, Fragment } from "react";
import 'antd/dist/antd.css';
import { Input, List } from 'antd';
// 将store引入到组件
import store from "./store";

class TodoList extends Component {

    constructor(props) {
        super(props);

        // 将数据仓库里的数据赋值给该组件的state，第一次挂载的时候
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        // 让store订阅handleStoreChange方法，只有这个方法发生变动，那么
        // store就会产生相应的变化
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return(
            <Fragment>
                {/* 上下左右有10px的边距 */}
                <div style={{margin: '10px 10px'}}>
                    <Input value={this.state.inputValue}
                           placeholder='todo list'
                           style={{width: '300px', marginRight: '5px'}}
                           onChange={this.handleInputChange}
                    />
                    <button onClick={this.handleBtnClick}>提交</button>

                    {/* 在渲染的时候会有一个index来表示该item的下标 */}
                    {/* 将index传递给handleDelete方法 */}
                    <List style={{width: '300px'}}
                          size="large"
                          bordered
                          dataSource={this.state.list}

                          renderItem={(item, index) => <List.Item onClick={this.handleDelete.bind(this, index)}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }

    handleInputChange(e) {
        const action = {
            // 创建一个action，其中的type是固定的，用于描述该动作
            type: 'change input value',
            value: e.target.value
        }
        // 通过dispatch将action传递给store
        store.dispatch(action);
    }

    // 将store的state替换掉TodoList这个组件的state，这样就可以随时渲染更新
    handleStoreChange() {
        this.setState(store.getState());
    }

    // 当点击按钮的时候，会触发的方法
    handleBtnClick() {
        const action = {
            type: 'add todo item',
        }
        store.dispatch(action);
    }

    // 这个方法接收一个index参数，index是对应item的下标
    handleDelete(index) {
        const action = {
            type: 'delete todo item',
            index
        }
        store.dispatch(action);
    }
}

export default TodoList;
```

##### 

#### UI组件和容器组件

> 是将渲染页面的语句和逻辑语句拆分开

##### 初始组件

```react
import React, { Component, Fragment } from "react";
import 'antd/dist/antd.css';
import { Input, List } from 'antd';
// 将store引入到组件
import store from "./store";

class TodoList extends Component {

    constructor(props) {
        super(props);

        // 将数据仓库里的数据赋值给该组件的state，第一次挂载的时候
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        // 让store订阅handleStoreChange方法，只有这个方法发生变动，那么
        // store就会产生相应的变化
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return(
            <Fragment>
                {/* 上下左右有10px的边距 */}
                <div style={{margin: '10px 10px'}}>
                    <Input value={this.state.inputValue}
                           placeholder='todo list'
                           style={{width: '300px', marginRight: '5px'}}
                           onChange={this.handleInputChange}
                    />
                    <button onClick={this.handleBtnClick}>提交</button>

                    {/* 在渲染的时候会有一个index来表示该item的下标 */}
                    {/* 将index传递给handleDelete方法 */}
                    <List style={{width: '300px'}}
                          size="large"
                          bordered
                          dataSource={this.state.list}

                          renderItem={(item, index) => <List.Item onClick={this.handleDelete.bind(this, index)}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }

    handleInputChange(e) {
        const action = {
            // 创建一个action，其中的type是固定的，用于描述该动作
            type: 'change input value',
            value: e.target.value
        }
        // 通过dispatch将action传递给store
        store.dispatch(action);
    }

    // 将store的state替换掉TodoList这个组件的state，这样就可以随时渲染更新
    handleStoreChange() {
        this.setState(store.getState());
    }

    // 当点击按钮的时候，会触发的方法
    handleBtnClick() {
        const action = {
            type: 'add todo item',
        }
        store.dispatch(action);
    }

    // 这个方法接收一个index参数，index是对应item的下标
    handleDelete(index) {
        const action = {
            type: 'delete todo item',
            index
        }
        store.dispatch(action);
    }
}

export default TodoList;

```



##### 拆分后的UI组件

```react
import React, { Component, Fragment } from "react";
import {Input, List} from "antd";

class TodoListUI extends Component {
    render() {
        return (
            <Fragment>
                <div style={{margin: '10px 10px'}}>
                    <Input
                        value={this.props.inputValue}
                        placeholder="Hello World"
                        style={{width: '300px', marginRight: '5px'}}
                        onChange={this.props.handleInputChange}
                    />
                    <button onClick={this.props.handleBtnClick}>点击</button>
                    <List
                        style={{width: '300px', marginTop: '10px'}}
                        size="small"
                        bordered
                        dataSource={this.props.list}
                        renderItem={(item, index) => <List.Item onClick={() => {this.props.deleteItem(index)}}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }
}

export default TodoListUI;
```



##### 拆分后的容器组件

```react
import React, { Component, Fragment } from "react";
import "antd/dist/antd.css"
import store from "./store";
import TodoListUI from './TodoListUI';

// 将所有的action抽取出来，放到一个叫做actionTypes的文件中
import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM } from "./actionTypes";

class TodoList extends Component {

    constructor(props) {
        super(props);
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.deleteItem = this.deleteItem.bind(this)
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return <TodoListUI
        // 将组件的各种状态传递给子组件        
        inputValue = {this.state.inputValue}
        list = {this.state.list}
        handleInputChange = {this.handleInputChange}
        handleBtnClick = {this.handleBtnClick}
        deleteItem = {this.deleteItem}
        handStoreChange = {this.handleStoreChange}
        />
    }

    handleInputChange(e) {
        const action = {
            type: CHANGE_INPUT_VALUE,
            value: e.target.value
        }
        store.dispatch(action);
    }

    handleBtnClick() {
        const action = {
            type: ADD_TODO_ITEM,
        }
        store.dispatch(action);
    }

    handleStoreChange() {
        this.setState(store.getState());
    }

    deleteItem(index) {
        const action = {
            type: DELETE_TODO_ITEM,
            index
        }
        store.dispatch(action);
    }
}

export default TodoList;
```

### Redux 中间件

#### redux-thunk

> redux-thunk的安装
>
> 它可以将异步操作从组建中移除，然后发到action文件当中去

```bash
npm install redux-thunk
```

> redux-thunk中间件的使用
>
> 它主要是在创建store的时候被引用

```react
// thunk和saga它们都是中间件，如果要使用，首先需要引入applyMiddleware
import {createStore, applyMiddleware, compose} from "redux";
// 然后再引入对应的中间件，这里是thunk
import thunk from "redux-thunk";
import reducer from "./reducer";

// 如果要同时使用redux的devtools和其他的中间件，那么就需要像下面一样来写。
// 因为redux devtools也是一个中间件
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
    //    compose需要从redux中引入
    }) : compose;

const enhancer = composeEnhancers(applyMiddleware(thunk))

const store = createStore(reducer, enhancer)

export default store;
```

> actionCreators 文件

```react
// 这里是返回的一个对象
export const getDeleteItemAction = (index) => ({
    type: DELETE_TODO_ITEM,
    index
})

export const getInitItemAction = (data) => ({
    type: INIT_LIST_ITEM,
    data
});

// 这里是返回的一个函数，运用到了react-thunk。如果没有它，那么久不能返回一个函数
export const getTodoList = () => {
    return (dispatch) => {
        axios.get('https://run.mocky.io/v3/06315b0b-6c7f-49c3-9e51-94e3a35da33b')
            .then((res) => {
                const data =res.data;
                dispatch(getInitItemAction(data));
            })
            .catch(() => {console.log('failed')})
    }
}
```





### react-redux 学习

> 安装react-redux

```bash
进入到工程目录
npm install react-redux
```

#### react-redux 使用范例

##### index.js 

```react
import React from 'react';
import ReactDOM from 'react-dom';
import TodoList from "./TodoList";
import store from "./store";
// react-redux 提供的核心API
import { Provider } from 'react-redux';

const App = (
    // Provider组件，由react-redux提供。
    // Provider的store属性的值，就是整个store数据仓库的值。
    // 这样，只要是在Provider下面的组件，例如TodoList组件
    // 都可以获取到store里面的内容
    <Provider store={store}>
        <TodoList />
    </Provider>
);

ReactDOM.render(
  <React.StrictMode>
    {/* 然后将App组件传给ReactDOM.render进行渲染 */}
      {App}
  </React.StrictMode>,
  document.getElementById('root')
);
```



##### store.js 和 reducer.js 页面不需要作改变

##### TodoList.js 组件

```react
import React, { Component, Fragment } from "react";
// react-redux 提供的核心API
import { connect } from 'react-redux';
import 'antd/dist/antd.css';
import { Input, List } from 'antd';

class TodoList extends Component {

    render() {
        return(
            <Fragment>
                <div style={{margin: '10px 10px'}}>
                    <Input
                        style={{width: '300px'}}
                        placeholder='todo list'
                        value={this.props.inputValue}
                        onChange={this.props.changeInputValue}
                    />
                    <button
                        style={{marginLeft: '5px'}}
                        onClick={this.props.handleBtnClick}
                    >提交</button>

                    <List style={{width: '300px', marginTop: '10px'}}
                          size="large"
                          bordered
                          dataSource={this.props.list}
                          renderItem={(item, index) => <List.Item onClick={this.props.deleteItem.bind(this, index)}>{item}</List.Item>}
                    />
                </div>
            </Fragment>
        )
    }
}

// 这个函数是用来将store里面的state传递给子组件的props
// 这里是传递给TodoList
const mapStateToProps = (state) => {
    return {
        // 让子组件的inputValue和store里面的inputValue产生关联
        inputValue: state.inputValue,
        // 让子组件的list和store里面的list产生关联
        list: state.list
    }
}

// 将store的 dispatch方法挂载到 props上
// 这个函数是用来，将修改后的子组件state中的数据返回给store
// 让store来更改修改过后的数据
const mapDispatchToProps = (dispatch) => {
    return {
        changeInputValue(e) {
            const action = {
                type: 'change input value',
                value: e.target.value
            }
            dispatch(action);
        },
        handleBtnClick() {
            const action = {
                type: 'add todo item'
            }
            dispatch(action);
        },
        deleteItem(index) {
            const action = {
                type: 'delete todo item',
                index
            }
            dispatch(action);
        }
    }
}

// 这里的意思是，让TodoList组件与store进行连接
export default connect(mapStateToProps, mapDispatchToProps)(TodoList);
```



### react 使用styled-components

> 运用styled-components来对react项目的css文件进行管理

将css放入一个叫style.js的文件中。

```react
import { createGlobalStyle } from 'styled-components';

export const GlobalStyle = createGlobalStyle`
  body{
    marigin: 0;
    padding: 0;
    background: green;
  }
`
```

然后再将其引入到需要使用这个css的组件当中

```react
import React from 'react';
// 引入css
import { GlobalStyle } from "./style";

function App() {
  return (
    <p style={{margin: "10px 10px"}}>
      // 使用css
      <GlobalStyle/>
      Hello World
    </p>
  );
}

export default App;

```

### React 过程中的坑

> 当运用了combineReducers这个组件之后，遇到的问题

整合的reducer文件

```react
import { combineReducers } from "redux";
import reducerHeader from "../header/redux/reducer";

export default combineReducers({
    header: reducerHeader
})
```



对应的组件当中就必须如下写。因为是拆分的，所以要带上其对应的header。以此类推

```react
const mapStateToProps = (state) => {
    return {
        // 将store里面存储的信息传递给子组件，也就是这里的Header组件
        focused: state.header.get('focused'),
        hotList: state.header.get('hotList'),
        totalPage: state.header.get('totalPage'),
        page: state.header.get('page'),
        mouseIn: state.header.get('mouseIn')
    }
}
```

### Component 和 PureComponent

Component：只要项目store里面的数据发生了变化，那么每一个组件就会被重新的渲染。这样就会造成性能的降低。为了避免这样的情况，可以在组件中使用shouldComponentUpdate()这个生命周期函数。通过这个函数来判断，store里面的数据更改是否和当下的组件相关。如果不相关的话，就不重新渲染



PureComponent：react底层帮助实现了上面的功能。但是需要配合immutable.js使用，否则会出现不可预测的问题



### 异步组件/withRouter路由使用

, description=React Study, createTime=2020-07-02, updateTime=2021-02-25, category=Category{id=25, name='React'}, user=User(id=1, avatar=https://raw.githubusercontent.com/laughing0li/FIgureBed/master/img/IMG_2316.JPG, username=banjo, password=4297f44b13955235245b2497399d7a93, email=mr.singledog@gmail.com, createTime=2019-07-11, updateTime=2020-07-10, category=null), category_id=0)], isHasContent=true, first=true, last=false, isHasNext=true, isHasPrevious=false))
2021-03-25 18:28:32.615  INFO 36287 --- [http-nio-8080-exec-7] com.banjo.blogvue.aspect.LogAspect       : Request: RequestLog{url='http://localhost:8080/blog', ip='0:0:0:0:0:0:0:1', classMethod='com.banjo.blogvue.controller.admin.AdminPageController.listBlogs', args=[]}
2021-03-25 18:28:32.615  INFO 36287 --- [http-nio-8080-exec-7] com.banjo.blogvue.aspect.LogAspect       : Result: admin/listBlogs
2021-03-25 18:28:32.644 ERROR 36287 --- [http-nio-8080-exec-7] org.thymeleaf.TemplateEngine             : [THYMELEAF][http-nio-8080-exec-7] Exception processing template "admin/listBlogs": An error happened during template parsing (template: "class path resource [templates/admin/listBlogs.html]")

org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/admin/listBlogs.html]")
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:241) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) [thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) [thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:366) [thymeleaf-spring5-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:190) [thymeleaf-spring5-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1393) [spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1138) [spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1077) [spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:962) [spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.3.3.jar:5.3.3]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:626) [tomcat-embed-core-9.0.41.jar:4.0.FR]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.3.3.jar:5.3.3]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733) [tomcat-embed-core-9.0.41.jar:4.0.FR]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.3.3.jar:5.3.3]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.3.3.jar:5.3.3]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.3.3.jar:5.3.3]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.3.3.jar:5.3.3]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.3.3.jar:5.3.3]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.3.3.jar:5.3.3]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:888) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_251]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_251]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_251]
Caused by: org.attoparser.ParseException: Exception evaluating SpringEL expression: "session.user.username" (template: "common/admin_fragments" - line 24, col 27)
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:393) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	... 48 common frames omitted
Caused by: org.thymeleaf.exceptions.TemplateProcessingException: Exception evaluating SpringEL expression: "session.user.username" (template: "common/admin_fragments" - line 24, col 27)
	at org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:292) ~[thymeleaf-spring5-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.VariableExpression.executeVariableExpression(VariableExpression.java:166) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:66) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:109) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:138) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:125) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.inline.AbstractStandardInliner.processExpression(AbstractStandardInliner.java:528) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.inline.AbstractStandardInliner.performInlining(AbstractStandardInliner.java:389) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.inline.AbstractStandardInliner.inline(AbstractStandardInliner.java:283) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.processor.StandardInliningCommentProcessor.doProcess(StandardInliningCommentProcessor.java:55) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.processor.comment.AbstractCommentProcessor.process(AbstractCommentProcessor.java:57) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.util.ProcessorConfigurationUtils$CommentProcessorWrapper.process(ProcessorConfigurationUtils.java:681) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.ProcessorTemplateHandler.handleComment(ProcessorTemplateHandler.java:665) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.Comment.beHandled(Comment.java:147) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.Model.process(Model.java:282) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1587) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.TemplateHandlerAdapterMarkupHandler.handleOpenElementEnd(TemplateHandlerAdapterMarkupHandler.java:304) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler$InlineMarkupAdapterPreProcessorHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:278) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.handleOpenElementEnd(OutputExpressionInlinePreProcessorHandler.java:186) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:124) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.attoparser.HtmlElement.handleOpenElementEnd(HtmlElement.java:109) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.HtmlMarkupHandler.handleOpenElementEnd(HtmlMarkupHandler.java:297) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupEventProcessorHandler.handleOpenElementEnd(MarkupEventProcessorHandler.java:402) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingElementMarkupUtil.parseOpenElement(ParsingElementMarkupUtil.java:159) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:710) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	... 50 common frames omitted
Caused by: org.springframework.expression.spel.SpelEvaluationException: EL1007E: Property or field 'username' cannot be found on null
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:213) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:104) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.access$000(PropertyOrFieldReference.java:51) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.PropertyOrFieldReference$AccessorLValue.getValue(PropertyOrFieldReference.java:406) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:92) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:112) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:337) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:265) ~[thymeleaf-spring5-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	... 75 common frames omitted

2021-03-25 18:28:32.647 ERROR 36287 --- [http-nio-8080-exec-7] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/admin/listBlogs.html]")] with root cause

org.springframework.expression.spel.SpelEvaluationException: EL1007E: Property or field 'username' cannot be found on null
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:213) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:104) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.access$000(PropertyOrFieldReference.java:51) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.PropertyOrFieldReference$AccessorLValue.getValue(PropertyOrFieldReference.java:406) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:92) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:112) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:337) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:265) ~[thymeleaf-spring5-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.VariableExpression.executeVariableExpression(VariableExpression.java:166) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:66) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:109) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:138) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:125) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.inline.AbstractStandardInliner.processExpression(AbstractStandardInliner.java:528) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.inline.AbstractStandardInliner.performInlining(AbstractStandardInliner.java:389) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.inline.AbstractStandardInliner.inline(AbstractStandardInliner.java:283) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.processor.StandardInliningCommentProcessor.doProcess(StandardInliningCommentProcessor.java:55) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.processor.comment.AbstractCommentProcessor.process(AbstractCommentProcessor.java:57) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.util.ProcessorConfigurationUtils$CommentProcessorWrapper.process(ProcessorConfigurationUtils.java:681) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.ProcessorTemplateHandler.handleComment(ProcessorTemplateHandler.java:665) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.Comment.beHandled(Comment.java:147) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.Model.process(Model.java:282) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1587) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.TemplateHandlerAdapterMarkupHandler.handleOpenElementEnd(TemplateHandlerAdapterMarkupHandler.java:304) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler$InlineMarkupAdapterPreProcessorHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:278) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.handleOpenElementEnd(OutputExpressionInlinePreProcessorHandler.java:186) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:124) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.attoparser.HtmlElement.handleOpenElementEnd(HtmlElement.java:109) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.HtmlMarkupHandler.handleOpenElementEnd(HtmlMarkupHandler.java:297) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupEventProcessorHandler.handleOpenElementEnd(MarkupEventProcessorHandler.java:402) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingElementMarkupUtil.parseOpenElement(ParsingElementMarkupUtil.java:159) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:710) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:366) ~[thymeleaf-spring5-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:190) ~[thymeleaf-spring5-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1393) ~[spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1138) ~[spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1077) ~[spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:962) ~[spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.3.3.jar:5.3.3]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:626) ~[tomcat-embed-core-9.0.41.jar:4.0.FR]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.3.3.jar:5.3.3]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733) ~[tomcat-embed-core-9.0.41.jar:4.0.FR]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.3.3.jar:5.3.3]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.3.jar:5.3.3]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.3.3.jar:5.3.3]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.3.jar:5.3.3]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.3.3.jar:5.3.3]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.3.jar:5.3.3]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:888) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_251]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_251]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_251]

2021-03-25 18:29:24.833  INFO 36287 --- [SpringContextShutdownHook] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'
2021-03-25 18:29:24.834  INFO 36287 --- [SpringContextShutdownHook] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'
2021-03-25 18:29:24.834  INFO 36287 --- [SpringContextShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-3 - Shutdown initiated...
2021-03-25 18:29:24.838  INFO 36287 --- [SpringContextShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-3 - Shutdown completed.
2021-03-25 18:29:27.877  INFO 70330 --- [restartedMain] com.banjo.blogvue.BlogVueApplication     : Starting BlogVueApplication using Java 1.8.0_251 on Laughings-MacBook-Pro.local with PID 70330 (/Users/laughingli/Documents/Java/blog-vue/target/classes started by laughingli in /Users/laughingli/Documents/Java/blog-vue)
2021-03-25 18:29:27.880 DEBUG 70330 --- [restartedMain] com.banjo.blogvue.BlogVueApplication     : Running with Spring Boot v2.4.2, Spring v5.3.3
2021-03-25 18:29:27.880  INFO 70330 --- [restartedMain] com.banjo.blogvue.BlogVueApplication     : The following profiles are active: dev
2021-03-25 18:29:27.928  INFO 70330 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2021-03-25 18:29:27.928  INFO 70330 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2021-03-25 18:29:28.525  INFO 70330 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2021-03-25 18:29:28.572  INFO 70330 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 39 ms. Found 2 JPA repository interfaces.
2021-03-25 18:29:29.192  INFO 70330 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
2021-03-25 18:29:29.199  INFO 70330 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2021-03-25 18:29:29.199  INFO 70330 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.41]
2021-03-25 18:29:29.257  INFO 70330 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2021-03-25 18:29:29.258  INFO 70330 --- [restartedMain] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1329 ms
2021-03-25 18:29:29.437  INFO 70330 --- [restartedMain] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2021-03-25 18:29:29.472  INFO 70330 --- [restartedMain] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 5.4.27.Final
2021-03-25 18:29:29.629  INFO 70330 --- [restartedMain] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.1.2.Final}
2021-03-25 18:29:29.712  INFO 70330 --- [restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2021-03-25 18:29:30.006  INFO 70330 --- [restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2021-03-25 18:29:30.023  INFO 70330 --- [restartedMain] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL8Dialect
2021-03-25 18:29:30.667  INFO 70330 --- [restartedMain] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
2021-03-25 18:29:30.675  INFO 70330 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2021-03-25 18:29:30.729  INFO 70330 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2021-03-25 18:29:31.281  WARN 70330 --- [restartedMain] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2021-03-25 18:29:31.427  INFO 70330 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2021-03-25 18:29:31.787  INFO 70330 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2021-03-25 18:29:31.797  INFO 70330 --- [restartedMain] com.banjo.blogvue.BlogVueApplication     : Started BlogVueApplication in 4.321 seconds (JVM running for 5.121)
2021-03-25 18:29:38.878  INFO 70330 --- [http-nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2021-03-25 18:29:38.879  INFO 70330 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2021-03-25 18:29:38.880  INFO 70330 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms
2021-03-25 18:29:38.904  INFO 70330 --- [http-nio-8080-exec-1] com.banjo.blogvue.aspect.LogAspect       : Request: RequestLog{url='http://localhost:8080/blog', ip='0:0:0:0:0:0:0:1', classMethod='com.banjo.blogvue.controller.admin.AdminPageController.listBlogs', args=[]}
2021-03-25 18:29:38.913  INFO 70330 --- [http-nio-8080-exec-1] com.banjo.blogvue.aspect.LogAspect       : Result: admin/listBlogs
2021-03-25 18:29:39.192 ERROR 70330 --- [http-nio-8080-exec-1] org.thymeleaf.TemplateEngine             : [THYMELEAF][http-nio-8080-exec-1] Exception processing template "admin/listBlogs": An error happened during template parsing (template: "class path resource [templates/admin/listBlogs.html]")

org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/admin/listBlogs.html]")
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:241) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) [thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) [thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:366) [thymeleaf-spring5-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:190) [thymeleaf-spring5-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1393) [spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1138) [spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1077) [spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:962) [spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.3.3.jar:5.3.3]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:626) [tomcat-embed-core-9.0.41.jar:4.0.FR]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.3.3.jar:5.3.3]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733) [tomcat-embed-core-9.0.41.jar:4.0.FR]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.3.3.jar:5.3.3]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.3.3.jar:5.3.3]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.3.3.jar:5.3.3]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.3.3.jar:5.3.3]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.3.3.jar:5.3.3]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.3.3.jar:5.3.3]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:888) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_251]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_251]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_251]
Caused by: org.attoparser.ParseException: Exception evaluating SpringEL expression: "session.user.username" (template: "common/admin_fragments" - line 24, col 27)
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:393) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	... 48 common frames omitted
Caused by: org.thymeleaf.exceptions.TemplateProcessingException: Exception evaluating SpringEL expression: "session.user.username" (template: "common/admin_fragments" - line 24, col 27)
	at org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:292) ~[thymeleaf-spring5-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.VariableExpression.executeVariableExpression(VariableExpression.java:166) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:66) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:109) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:138) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:125) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.inline.AbstractStandardInliner.processExpression(AbstractStandardInliner.java:528) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.inline.AbstractStandardInliner.performInlining(AbstractStandardInliner.java:389) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.inline.AbstractStandardInliner.inline(AbstractStandardInliner.java:283) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.processor.StandardInliningCommentProcessor.doProcess(StandardInliningCommentProcessor.java:55) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.processor.comment.AbstractCommentProcessor.process(AbstractCommentProcessor.java:57) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.util.ProcessorConfigurationUtils$CommentProcessorWrapper.process(ProcessorConfigurationUtils.java:681) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.ProcessorTemplateHandler.handleComment(ProcessorTemplateHandler.java:665) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.Comment.beHandled(Comment.java:147) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.Model.process(Model.java:282) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1587) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.TemplateHandlerAdapterMarkupHandler.handleOpenElementEnd(TemplateHandlerAdapterMarkupHandler.java:304) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler$InlineMarkupAdapterPreProcessorHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:278) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.handleOpenElementEnd(OutputExpressionInlinePreProcessorHandler.java:186) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:124) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.attoparser.HtmlElement.handleOpenElementEnd(HtmlElement.java:109) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.HtmlMarkupHandler.handleOpenElementEnd(HtmlMarkupHandler.java:297) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupEventProcessorHandler.handleOpenElementEnd(MarkupEventProcessorHandler.java:402) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingElementMarkupUtil.parseOpenElement(ParsingElementMarkupUtil.java:159) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:710) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	... 50 common frames omitted
Caused by: org.springframework.expression.spel.SpelEvaluationException: EL1007E: Property or field 'username' cannot be found on null
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:213) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:104) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.access$000(PropertyOrFieldReference.java:51) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.PropertyOrFieldReference$AccessorLValue.getValue(PropertyOrFieldReference.java:406) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:92) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:112) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:337) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:265) ~[thymeleaf-spring5-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	... 75 common frames omitted

2021-03-25 18:29:39.197 ERROR 70330 --- [http-nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/admin/listBlogs.html]")] with root cause

org.springframework.expression.spel.SpelEvaluationException: EL1007E: Property or field 'username' cannot be found on null
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:213) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:104) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.access$000(PropertyOrFieldReference.java:51) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.PropertyOrFieldReference$AccessorLValue.getValue(PropertyOrFieldReference.java:406) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:92) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:112) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:337) ~[spring-expression-5.3.3.jar:5.3.3]
	at org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:265) ~[thymeleaf-spring5-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.VariableExpression.executeVariableExpression(VariableExpression.java:166) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:66) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:109) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:138) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:125) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.inline.AbstractStandardInliner.processExpression(AbstractStandardInliner.java:528) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.inline.AbstractStandardInliner.performInlining(AbstractStandardInliner.java:389) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.inline.AbstractStandardInliner.inline(AbstractStandardInliner.java:283) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.processor.StandardInliningCommentProcessor.doProcess(StandardInliningCommentProcessor.java:55) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.processor.comment.AbstractCommentProcessor.process(AbstractCommentProcessor.java:57) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.util.ProcessorConfigurationUtils$CommentProcessorWrapper.process(ProcessorConfigurationUtils.java:681) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.ProcessorTemplateHandler.handleComment(ProcessorTemplateHandler.java:665) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.Comment.beHandled(Comment.java:147) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.Model.process(Model.java:282) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1587) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.TemplateHandlerAdapterMarkupHandler.handleOpenElementEnd(TemplateHandlerAdapterMarkupHandler.java:304) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler$InlineMarkupAdapterPreProcessorHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:278) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.handleOpenElementEnd(OutputExpressionInlinePreProcessorHandler.java:186) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:124) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.attoparser.HtmlElement.handleOpenElementEnd(HtmlElement.java:109) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.HtmlMarkupHandler.handleOpenElementEnd(HtmlMarkupHandler.java:297) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupEventProcessorHandler.handleOpenElementEnd(MarkupEventProcessorHandler.java:402) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingElementMarkupUtil.parseOpenElement(ParsingElementMarkupUtil.java:159) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:710) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:366) ~[thymeleaf-spring5-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:190) ~[thymeleaf-spring5-3.0.12.RELEASE.jar:3.0.12.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1393) ~[spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1138) ~[spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1077) ~[spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:962) ~[spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.3.3.jar:5.3.3]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.3.3.jar:5.3.3]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:626) ~[tomcat-embed-core-9.0.41.jar:4.0.FR]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.3.3.jar:5.3.3]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733) ~[tomcat-embed-core-9.0.41.jar:4.0.FR]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.3.3.jar:5.3.3]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.3.jar:5.3.3]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.3.3.jar:5.3.3]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.3.jar:5.3.3]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.3.3.jar:5.3.3]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.3.jar:5.3.3]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:888) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_251]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_251]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.41.jar:9.0.41]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_251]

